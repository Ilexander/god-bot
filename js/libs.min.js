/**
 * Swiper 8.3.2
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * https://swiperjs.com
 *
 * Copyright 2014-2022 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: July 26, 2022
 */

! function (e, t) {
  "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).Swiper = t()
}(this, (function () {
  "use strict";

  function e(e) {
    return null !== e && "object" == typeof e && "constructor" in e && e.constructor === Object
  }

  function t(s, a) {
    void 0 === s && (s = {}), void 0 === a && (a = {}), Object.keys(a).forEach((i => {
      void 0 === s[i] ? s[i] = a[i] : e(a[i]) && e(s[i]) && Object.keys(a[i]).length > 0 && t(s[i], a[i])
    }))
  }
  const s = {
    body: {},
    addEventListener() {},
    removeEventListener() {},
    activeElement: {
      blur() {},
      nodeName: ""
    },
    querySelector: () => null,
    querySelectorAll: () => [],
    getElementById: () => null,
    createEvent: () => ({
      initEvent() {}
    }),
    createElement: () => ({
      children: [],
      childNodes: [],
      style: {},
      setAttribute() {},
      getElementsByTagName: () => []
    }),
    createElementNS: () => ({}),
    importNode: () => null,
    location: {
      hash: "",
      host: "",
      hostname: "",
      href: "",
      origin: "",
      pathname: "",
      protocol: "",
      search: ""
    }
  };

  function a() {
    const e = "undefined" != typeof document ? document : {};
    return t(e, s), e
  }
  const i = {
    document: s,
    navigator: {
      userAgent: ""
    },
    location: {
      hash: "",
      host: "",
      hostname: "",
      href: "",
      origin: "",
      pathname: "",
      protocol: "",
      search: ""
    },
    history: {
      replaceState() {},
      pushState() {},
      go() {},
      back() {}
    },
    CustomEvent: function () {
      return this
    },
    addEventListener() {},
    removeEventListener() {},
    getComputedStyle: () => ({
      getPropertyValue: () => ""
    }),
    Image() {},
    Date() {},
    screen: {},
    setTimeout() {},
    clearTimeout() {},
    matchMedia: () => ({}),
    requestAnimationFrame: e => "undefined" == typeof setTimeout ? (e(), null) : setTimeout(e, 0),
    cancelAnimationFrame(e) {
      "undefined" != typeof setTimeout && clearTimeout(e)
    }
  };

  function r() {
    const e = "undefined" != typeof window ? window : {};
    return t(e, i), e
  }
  class n extends Array {
    constructor(e) {
      "number" == typeof e ? super(e) : (super(...e || []), function (e) {
        const t = e.__proto__;
        Object.defineProperty(e, "__proto__", {
          get: () => t,
          set(e) {
            t.__proto__ = e
          }
        })
      }(this))
    }
  }

  function l(e) {
    void 0 === e && (e = []);
    const t = [];
    return e.forEach((e => {
      Array.isArray(e) ? t.push(...l(e)) : t.push(e)
    })), t
  }

  function o(e, t) {
    return Array.prototype.filter.call(e, t)
  }

  function d(e, t) {
    const s = r(),
      i = a();
    let l = [];
    if (!t && e instanceof n) return e;
    if (!e) return new n(l);
    if ("string" == typeof e) {
      const s = e.trim();
      if (s.indexOf("<") >= 0 && s.indexOf(">") >= 0) {
        let e = "div";
        0 === s.indexOf("<li") && (e = "ul"), 0 === s.indexOf("<tr") && (e = "tbody"), 0 !== s.indexOf("<td") && 0 !== s.indexOf("<th") || (e = "tr"), 0 === s.indexOf("<tbody") && (e = "table"), 0 === s.indexOf("<option") && (e = "select");
        const t = i.createElement(e);
        t.innerHTML = s;
        for (let e = 0; e < t.childNodes.length; e += 1) l.push(t.childNodes[e])
      } else l = function (e, t) {
        if ("string" != typeof e) return [e];
        const s = [],
          a = t.querySelectorAll(e);
        for (let e = 0; e < a.length; e += 1) s.push(a[e]);
        return s
      }(e.trim(), t || i)
    } else if (e.nodeType || e === s || e === i) l.push(e);
    else if (Array.isArray(e)) {
      if (e instanceof n) return e;
      l = e
    }
    return new n(function (e) {
      const t = [];
      for (let s = 0; s < e.length; s += 1) - 1 === t.indexOf(e[s]) && t.push(e[s]);
      return t
    }(l))
  }
  d.fn = n.prototype;
  const c = {
    addClass: function () {
      for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++) t[s] = arguments[s];
      const a = l(t.map((e => e.split(" "))));
      return this.forEach((e => {
        e.classList.add(...a)
      })), this
    },
    removeClass: function () {
      for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++) t[s] = arguments[s];
      const a = l(t.map((e => e.split(" "))));
      return this.forEach((e => {
        e.classList.remove(...a)
      })), this
    },
    hasClass: function () {
      for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++) t[s] = arguments[s];
      const a = l(t.map((e => e.split(" "))));
      return o(this, (e => a.filter((t => e.classList.contains(t))).length > 0)).length > 0
    },
    toggleClass: function () {
      for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++) t[s] = arguments[s];
      const a = l(t.map((e => e.split(" "))));
      this.forEach((e => {
        a.forEach((t => {
          e.classList.toggle(t)
        }))
      }))
    },
    attr: function (e, t) {
      if (1 === arguments.length && "string" == typeof e) return this[0] ? this[0].getAttribute(e) : void 0;
      for (let s = 0; s < this.length; s += 1)
        if (2 === arguments.length) this[s].setAttribute(e, t);
        else
          for (const t in e) this[s][t] = e[t], this[s].setAttribute(t, e[t]);
      return this
    },
    removeAttr: function (e) {
      for (let t = 0; t < this.length; t += 1) this[t].removeAttribute(e);
      return this
    },
    transform: function (e) {
      for (let t = 0; t < this.length; t += 1) this[t].style.transform = e;
      return this
    },
    transition: function (e) {
      for (let t = 0; t < this.length; t += 1) this[t].style.transitionDuration = "string" != typeof e ? `${e}ms` : e;
      return this
    },
    on: function () {
      for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++) t[s] = arguments[s];
      let [a, i, r, n] = t;

      function l(e) {
        const t = e.target;
        if (!t) return;
        const s = e.target.dom7EventData || [];
        if (s.indexOf(e) < 0 && s.unshift(e), d(t).is(i)) r.apply(t, s);
        else {
          const e = d(t).parents();
          for (let t = 0; t < e.length; t += 1) d(e[t]).is(i) && r.apply(e[t], s)
        }
      }

      function o(e) {
        const t = e && e.target && e.target.dom7EventData || [];
        t.indexOf(e) < 0 && t.unshift(e), r.apply(this, t)
      }
      "function" == typeof t[1] && ([a, r, n] = t, i = void 0), n || (n = !1);
      const c = a.split(" ");
      let p;
      for (let e = 0; e < this.length; e += 1) {
        const t = this[e];
        if (i)
          for (p = 0; p < c.length; p += 1) {
            const e = c[p];
            t.dom7LiveListeners || (t.dom7LiveListeners = {}), t.dom7LiveListeners[e] || (t.dom7LiveListeners[e] = []), t.dom7LiveListeners[e].push({
              listener: r,
              proxyListener: l
            }), t.addEventListener(e, l, n)
          } else
            for (p = 0; p < c.length; p += 1) {
              const e = c[p];
              t.dom7Listeners || (t.dom7Listeners = {}), t.dom7Listeners[e] || (t.dom7Listeners[e] = []), t.dom7Listeners[e].push({
                listener: r,
                proxyListener: o
              }), t.addEventListener(e, o, n)
            }
      }
      return this
    },
    off: function () {
      for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++) t[s] = arguments[s];
      let [a, i, r, n] = t;
      "function" == typeof t[1] && ([a, r, n] = t, i = void 0), n || (n = !1);
      const l = a.split(" ");
      for (let e = 0; e < l.length; e += 1) {
        const t = l[e];
        for (let e = 0; e < this.length; e += 1) {
          const s = this[e];
          let a;
          if (!i && s.dom7Listeners ? a = s.dom7Listeners[t] : i && s.dom7LiveListeners && (a = s.dom7LiveListeners[t]), a && a.length)
            for (let e = a.length - 1; e >= 0; e -= 1) {
              const i = a[e];
              r && i.listener === r || r && i.listener && i.listener.dom7proxy && i.listener.dom7proxy === r ? (s.removeEventListener(t, i.proxyListener, n), a.splice(e, 1)) : r || (s.removeEventListener(t, i.proxyListener, n), a.splice(e, 1))
            }
        }
      }
      return this
    },
    trigger: function () {
      const e = r();
      for (var t = arguments.length, s = new Array(t), a = 0; a < t; a++) s[a] = arguments[a];
      const i = s[0].split(" "),
        n = s[1];
      for (let t = 0; t < i.length; t += 1) {
        const a = i[t];
        for (let t = 0; t < this.length; t += 1) {
          const i = this[t];
          if (e.CustomEvent) {
            const t = new e.CustomEvent(a, {
              detail: n,
              bubbles: !0,
              cancelable: !0
            });
            i.dom7EventData = s.filter(((e, t) => t > 0)), i.dispatchEvent(t), i.dom7EventData = [], delete i.dom7EventData
          }
        }
      }
      return this
    },
    transitionEnd: function (e) {
      const t = this;
      return e && t.on("transitionend", (function s(a) {
        a.target === this && (e.call(this, a), t.off("transitionend", s))
      })), this
    },
    outerWidth: function (e) {
      if (this.length > 0) {
        if (e) {
          const e = this.styles();
          return this[0].offsetWidth + parseFloat(e.getPropertyValue("margin-right")) + parseFloat(e.getPropertyValue("margin-left"))
        }
        return this[0].offsetWidth
      }
      return null
    },
    outerHeight: function (e) {
      if (this.length > 0) {
        if (e) {
          const e = this.styles();
          return this[0].offsetHeight + parseFloat(e.getPropertyValue("margin-top")) + parseFloat(e.getPropertyValue("margin-bottom"))
        }
        return this[0].offsetHeight
      }
      return null
    },
    styles: function () {
      const e = r();
      return this[0] ? e.getComputedStyle(this[0], null) : {}
    },
    offset: function () {
      if (this.length > 0) {
        const e = r(),
          t = a(),
          s = this[0],
          i = s.getBoundingClientRect(),
          n = t.body,
          l = s.clientTop || n.clientTop || 0,
          o = s.clientLeft || n.clientLeft || 0,
          d = s === e ? e.scrollY : s.scrollTop,
          c = s === e ? e.scrollX : s.scrollLeft;
        return {
          top: i.top + d - l,
          left: i.left + c - o
        }
      }
      return null
    },
    css: function (e, t) {
      const s = r();
      let a;
      if (1 === arguments.length) {
        if ("string" != typeof e) {
          for (a = 0; a < this.length; a += 1)
            for (const t in e) this[a].style[t] = e[t];
          return this
        }
        if (this[0]) return s.getComputedStyle(this[0], null).getPropertyValue(e)
      }
      if (2 === arguments.length && "string" == typeof e) {
        for (a = 0; a < this.length; a += 1) this[a].style[e] = t;
        return this
      }
      return this
    },
    each: function (e) {
      return e ? (this.forEach(((t, s) => {
        e.apply(t, [t, s])
      })), this) : this
    },
    html: function (e) {
      if (void 0 === e) return this[0] ? this[0].innerHTML : null;
      for (let t = 0; t < this.length; t += 1) this[t].innerHTML = e;
      return this
    },
    text: function (e) {
      if (void 0 === e) return this[0] ? this[0].textContent.trim() : null;
      for (let t = 0; t < this.length; t += 1) this[t].textContent = e;
      return this
    },
    is: function (e) {
      const t = r(),
        s = a(),
        i = this[0];
      let l, o;
      if (!i || void 0 === e) return !1;
      if ("string" == typeof e) {
        if (i.matches) return i.matches(e);
        if (i.webkitMatchesSelector) return i.webkitMatchesSelector(e);
        if (i.msMatchesSelector) return i.msMatchesSelector(e);
        for (l = d(e), o = 0; o < l.length; o += 1)
          if (l[o] === i) return !0;
        return !1
      }
      if (e === s) return i === s;
      if (e === t) return i === t;
      if (e.nodeType || e instanceof n) {
        for (l = e.nodeType ? [e] : e, o = 0; o < l.length; o += 1)
          if (l[o] === i) return !0;
        return !1
      }
      return !1
    },
    index: function () {
      let e, t = this[0];
      if (t) {
        for (e = 0; null !== (t = t.previousSibling);) 1 === t.nodeType && (e += 1);
        return e
      }
    },
    eq: function (e) {
      if (void 0 === e) return this;
      const t = this.length;
      if (e > t - 1) return d([]);
      if (e < 0) {
        const s = t + e;
        return d(s < 0 ? [] : [this[s]])
      }
      return d([this[e]])
    },
    append: function () {
      let e;
      const t = a();
      for (let s = 0; s < arguments.length; s += 1) {
        e = s < 0 || arguments.length <= s ? void 0 : arguments[s];
        for (let s = 0; s < this.length; s += 1)
          if ("string" == typeof e) {
            const a = t.createElement("div");
            for (a.innerHTML = e; a.firstChild;) this[s].appendChild(a.firstChild)
          } else if (e instanceof n)
          for (let t = 0; t < e.length; t += 1) this[s].appendChild(e[t]);
        else this[s].appendChild(e)
      }
      return this
    },
    prepend: function (e) {
      const t = a();
      let s, i;
      for (s = 0; s < this.length; s += 1)
        if ("string" == typeof e) {
          const a = t.createElement("div");
          for (a.innerHTML = e, i = a.childNodes.length - 1; i >= 0; i -= 1) this[s].insertBefore(a.childNodes[i], this[s].childNodes[0])
        } else if (e instanceof n)
        for (i = 0; i < e.length; i += 1) this[s].insertBefore(e[i], this[s].childNodes[0]);
      else this[s].insertBefore(e, this[s].childNodes[0]);
      return this
    },
    next: function (e) {
      return this.length > 0 ? e ? this[0].nextElementSibling && d(this[0].nextElementSibling).is(e) ? d([this[0].nextElementSibling]) : d([]) : this[0].nextElementSibling ? d([this[0].nextElementSibling]) : d([]) : d([])
    },
    nextAll: function (e) {
      const t = [];
      let s = this[0];
      if (!s) return d([]);
      for (; s.nextElementSibling;) {
        const a = s.nextElementSibling;
        e ? d(a).is(e) && t.push(a) : t.push(a), s = a
      }
      return d(t)
    },
    prev: function (e) {
      if (this.length > 0) {
        const t = this[0];
        return e ? t.previousElementSibling && d(t.previousElementSibling).is(e) ? d([t.previousElementSibling]) : d([]) : t.previousElementSibling ? d([t.previousElementSibling]) : d([])
      }
      return d([])
    },
    prevAll: function (e) {
      const t = [];
      let s = this[0];
      if (!s) return d([]);
      for (; s.previousElementSibling;) {
        const a = s.previousElementSibling;
        e ? d(a).is(e) && t.push(a) : t.push(a), s = a
      }
      return d(t)
    },
    parent: function (e) {
      const t = [];
      for (let s = 0; s < this.length; s += 1) null !== this[s].parentNode && (e ? d(this[s].parentNode).is(e) && t.push(this[s].parentNode) : t.push(this[s].parentNode));
      return d(t)
    },
    parents: function (e) {
      const t = [];
      for (let s = 0; s < this.length; s += 1) {
        let a = this[s].parentNode;
        for (; a;) e ? d(a).is(e) && t.push(a) : t.push(a), a = a.parentNode
      }
      return d(t)
    },
    closest: function (e) {
      let t = this;
      return void 0 === e ? d([]) : (t.is(e) || (t = t.parents(e).eq(0)), t)
    },
    find: function (e) {
      const t = [];
      for (let s = 0; s < this.length; s += 1) {
        const a = this[s].querySelectorAll(e);
        for (let e = 0; e < a.length; e += 1) t.push(a[e])
      }
      return d(t)
    },
    children: function (e) {
      const t = [];
      for (let s = 0; s < this.length; s += 1) {
        const a = this[s].children;
        for (let s = 0; s < a.length; s += 1) e && !d(a[s]).is(e) || t.push(a[s])
      }
      return d(t)
    },
    filter: function (e) {
      return d(o(this, e))
    },
    remove: function () {
      for (let e = 0; e < this.length; e += 1) this[e].parentNode && this[e].parentNode.removeChild(this[e]);
      return this
    }
  };

  function p(e, t) {
    return void 0 === t && (t = 0), setTimeout(e, t)
  }

  function u() {
    return Date.now()
  }

  function h(e, t) {
    void 0 === t && (t = "x");
    const s = r();
    let a, i, n;
    const l = function (e) {
      const t = r();
      let s;
      return t.getComputedStyle && (s = t.getComputedStyle(e, null)), !s && e.currentStyle && (s = e.currentStyle), s || (s = e.style), s
    }(e);
    return s.WebKitCSSMatrix ? (i = l.transform || l.webkitTransform, i.split(",").length > 6 && (i = i.split(", ").map((e => e.replace(",", "."))).join(", ")), n = new s.WebKitCSSMatrix("none" === i ? "" : i)) : (n = l.MozTransform || l.OTransform || l.MsTransform || l.msTransform || l.transform || l.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), a = n.toString().split(",")), "x" === t && (i = s.WebKitCSSMatrix ? n.m41 : 16 === a.length ? parseFloat(a[12]) : parseFloat(a[4])), "y" === t && (i = s.WebKitCSSMatrix ? n.m42 : 16 === a.length ? parseFloat(a[13]) : parseFloat(a[5])), i || 0
  }

  function m(e) {
    return "object" == typeof e && null !== e && e.constructor && "Object" === Object.prototype.toString.call(e).slice(8, -1)
  }

  function f(e) {
    return "undefined" != typeof window && void 0 !== window.HTMLElement ? e instanceof HTMLElement : e && (1 === e.nodeType || 11 === e.nodeType)
  }

  function g() {
    const e = Object(arguments.length <= 0 ? void 0 : arguments[0]),
      t = ["__proto__", "constructor", "prototype"];
    for (let s = 1; s < arguments.length; s += 1) {
      const a = s < 0 || arguments.length <= s ? void 0 : arguments[s];
      if (null != a && !f(a)) {
        const s = Object.keys(Object(a)).filter((e => t.indexOf(e) < 0));
        for (let t = 0, i = s.length; t < i; t += 1) {
          const i = s[t],
            r = Object.getOwnPropertyDescriptor(a, i);
          void 0 !== r && r.enumerable && (m(e[i]) && m(a[i]) ? a[i].__swiper__ ? e[i] = a[i] : g(e[i], a[i]) : !m(e[i]) && m(a[i]) ? (e[i] = {}, a[i].__swiper__ ? e[i] = a[i] : g(e[i], a[i])) : e[i] = a[i])
        }
      }
    }
    return e
  }

  function v(e, t, s) {
    e.style.setProperty(t, s)
  }

  function w(e) {
    let {
      swiper: t,
      targetPosition: s,
      side: a
    } = e;
    const i = r(),
      n = -t.translate;
    let l, o = null;
    const d = t.params.speed;
    t.wrapperEl.style.scrollSnapType = "none", i.cancelAnimationFrame(t.cssModeFrameID);
    const c = s > n ? "next" : "prev",
      p = (e, t) => "next" === c && e >= t || "prev" === c && e <= t,
      u = () => {
        l = (new Date).getTime(), null === o && (o = l);
        const e = Math.max(Math.min((l - o) / d, 1), 0),
          r = .5 - Math.cos(e * Math.PI) / 2;
        let c = n + r * (s - n);
        if (p(c, s) && (c = s), t.wrapperEl.scrollTo({
            [a]: c
          }), p(c, s)) return t.wrapperEl.style.overflow = "hidden", t.wrapperEl.style.scrollSnapType = "", setTimeout((() => {
          t.wrapperEl.style.overflow = "", t.wrapperEl.scrollTo({
            [a]: c
          })
        })), void i.cancelAnimationFrame(t.cssModeFrameID);
        t.cssModeFrameID = i.requestAnimationFrame(u)
      };
    u()
  }
  let b, x, y;

  function E() {
    return b || (b = function () {
      const e = r(),
        t = a();
      return {
        smoothScroll: t.documentElement && "scrollBehavior" in t.documentElement.style,
        touch: !!("ontouchstart" in e || e.DocumentTouch && t instanceof e.DocumentTouch),
        passiveListener: function () {
          let t = !1;
          try {
            const s = Object.defineProperty({}, "passive", {
              get() {
                t = !0
              }
            });
            e.addEventListener("testPassiveListener", null, s)
          } catch (e) {}
          return t
        }(),
        gestures: "ongesturestart" in e
      }
    }()), b
  }

  function C(e) {
    return void 0 === e && (e = {}), x || (x = function (e) {
      let {
        userAgent: t
      } = void 0 === e ? {} : e;
      const s = E(),
        a = r(),
        i = a.navigator.platform,
        n = t || a.navigator.userAgent,
        l = {
          ios: !1,
          android: !1
        },
        o = a.screen.width,
        d = a.screen.height,
        c = n.match(/(Android);?[\s\/]+([\d.]+)?/);
      let p = n.match(/(iPad).*OS\s([\d_]+)/);
      const u = n.match(/(iPod)(.*OS\s([\d_]+))?/),
        h = !p && n.match(/(iPhone\sOS|iOS)\s([\d_]+)/),
        m = "Win32" === i;
      let f = "MacIntel" === i;
      return !p && f && s.touch && ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(`${o}x${d}`) >= 0 && (p = n.match(/(Version)\/([\d.]+)/), p || (p = [0, 1, "13_0_0"]), f = !1), c && !m && (l.os = "android", l.android = !0), (p || h || u) && (l.os = "ios", l.ios = !0), l
    }(e)), x
  }

  function T() {
    return y || (y = function () {
      const e = r();
      return {
        isSafari: function () {
          const t = e.navigator.userAgent.toLowerCase();
          return t.indexOf("safari") >= 0 && t.indexOf("chrome") < 0 && t.indexOf("android") < 0
        }(),
        isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent)
      }
    }()), y
  }
  Object.keys(c).forEach((e => {
    Object.defineProperty(d.fn, e, {
      value: c[e],
      writable: !0
    })
  }));
  var $ = {
    on(e, t, s) {
      const a = this;
      if (!a.eventsListeners || a.destroyed) return a;
      if ("function" != typeof t) return a;
      const i = s ? "unshift" : "push";
      return e.split(" ").forEach((e => {
        a.eventsListeners[e] || (a.eventsListeners[e] = []), a.eventsListeners[e][i](t)
      })), a
    },
    once(e, t, s) {
      const a = this;
      if (!a.eventsListeners || a.destroyed) return a;
      if ("function" != typeof t) return a;

      function i() {
        a.off(e, i), i.__emitterProxy && delete i.__emitterProxy;
        for (var s = arguments.length, r = new Array(s), n = 0; n < s; n++) r[n] = arguments[n];
        t.apply(a, r)
      }
      return i.__emitterProxy = t, a.on(e, i, s)
    },
    onAny(e, t) {
      const s = this;
      if (!s.eventsListeners || s.destroyed) return s;
      if ("function" != typeof e) return s;
      const a = t ? "unshift" : "push";
      return s.eventsAnyListeners.indexOf(e) < 0 && s.eventsAnyListeners[a](e), s
    },
    offAny(e) {
      const t = this;
      if (!t.eventsListeners || t.destroyed) return t;
      if (!t.eventsAnyListeners) return t;
      const s = t.eventsAnyListeners.indexOf(e);
      return s >= 0 && t.eventsAnyListeners.splice(s, 1), t
    },
    off(e, t) {
      const s = this;
      return !s.eventsListeners || s.destroyed ? s : s.eventsListeners ? (e.split(" ").forEach((e => {
        void 0 === t ? s.eventsListeners[e] = [] : s.eventsListeners[e] && s.eventsListeners[e].forEach(((a, i) => {
          (a === t || a.__emitterProxy && a.__emitterProxy === t) && s.eventsListeners[e].splice(i, 1)
        }))
      })), s) : s
    },
    emit() {
      const e = this;
      if (!e.eventsListeners || e.destroyed) return e;
      if (!e.eventsListeners) return e;
      let t, s, a;
      for (var i = arguments.length, r = new Array(i), n = 0; n < i; n++) r[n] = arguments[n];
      "string" == typeof r[0] || Array.isArray(r[0]) ? (t = r[0], s = r.slice(1, r.length), a = e) : (t = r[0].events, s = r[0].data, a = r[0].context || e), s.unshift(a);
      return (Array.isArray(t) ? t : t.split(" ")).forEach((t => {
        e.eventsAnyListeners && e.eventsAnyListeners.length && e.eventsAnyListeners.forEach((e => {
          e.apply(a, [t, ...s])
        })), e.eventsListeners && e.eventsListeners[t] && e.eventsListeners[t].forEach((e => {
          e.apply(a, s)
        }))
      })), e
    }
  };
  var S = {
    updateSize: function () {
      const e = this;
      let t, s;
      const a = e.$el;
      t = void 0 !== e.params.width && null !== e.params.width ? e.params.width : a[0].clientWidth, s = void 0 !== e.params.height && null !== e.params.height ? e.params.height : a[0].clientHeight, 0 === t && e.isHorizontal() || 0 === s && e.isVertical() || (t = t - parseInt(a.css("padding-left") || 0, 10) - parseInt(a.css("padding-right") || 0, 10), s = s - parseInt(a.css("padding-top") || 0, 10) - parseInt(a.css("padding-bottom") || 0, 10), Number.isNaN(t) && (t = 0), Number.isNaN(s) && (s = 0), Object.assign(e, {
        width: t,
        height: s,
        size: e.isHorizontal() ? t : s
      }))
    },
    updateSlides: function () {
      const e = this;

      function t(t) {
        return e.isHorizontal() ? t : {
          width: "height",
          "margin-top": "margin-left",
          "margin-bottom ": "margin-right",
          "margin-left": "margin-top",
          "margin-right": "margin-bottom",
          "padding-left": "padding-top",
          "padding-right": "padding-bottom",
          marginRight: "marginBottom"
        } [t]
      }

      function s(e, s) {
        return parseFloat(e.getPropertyValue(t(s)) || 0)
      }
      const a = e.params,
        {
          $wrapperEl: i,
          size: r,
          rtlTranslate: n,
          wrongRTL: l
        } = e,
        o = e.virtual && a.virtual.enabled,
        d = o ? e.virtual.slides.length : e.slides.length,
        c = i.children(`.${e.params.slideClass}`),
        p = o ? e.virtual.slides.length : c.length;
      let u = [];
      const h = [],
        m = [];
      let f = a.slidesOffsetBefore;
      "function" == typeof f && (f = a.slidesOffsetBefore.call(e));
      let g = a.slidesOffsetAfter;
      "function" == typeof g && (g = a.slidesOffsetAfter.call(e));
      const w = e.snapGrid.length,
        b = e.slidesGrid.length;
      let x = a.spaceBetween,
        y = -f,
        E = 0,
        C = 0;
      if (void 0 === r) return;
      "string" == typeof x && x.indexOf("%") >= 0 && (x = parseFloat(x.replace("%", "")) / 100 * r), e.virtualSize = -x, n ? c.css({
        marginLeft: "",
        marginBottom: "",
        marginTop: ""
      }) : c.css({
        marginRight: "",
        marginBottom: "",
        marginTop: ""
      }), a.centeredSlides && a.cssMode && (v(e.wrapperEl, "--swiper-centered-offset-before", ""), v(e.wrapperEl, "--swiper-centered-offset-after", ""));
      const T = a.grid && a.grid.rows > 1 && e.grid;
      let $;
      T && e.grid.initSlides(p);
      const S = "auto" === a.slidesPerView && a.breakpoints && Object.keys(a.breakpoints).filter((e => void 0 !== a.breakpoints[e].slidesPerView)).length > 0;
      for (let i = 0; i < p; i += 1) {
        $ = 0;
        const n = c.eq(i);
        if (T && e.grid.updateSlide(i, n, p, t), "none" !== n.css("display")) {
          if ("auto" === a.slidesPerView) {
            S && (c[i].style[t("width")] = "");
            const r = getComputedStyle(n[0]),
              l = n[0].style.transform,
              o = n[0].style.webkitTransform;
            if (l && (n[0].style.transform = "none"), o && (n[0].style.webkitTransform = "none"), a.roundLengths) $ = e.isHorizontal() ? n.outerWidth(!0) : n.outerHeight(!0);
            else {
              const e = s(r, "width"),
                t = s(r, "padding-left"),
                a = s(r, "padding-right"),
                i = s(r, "margin-left"),
                l = s(r, "margin-right"),
                o = r.getPropertyValue("box-sizing");
              if (o && "border-box" === o) $ = e + i + l;
              else {
                const {
                  clientWidth: s,
                  offsetWidth: r
                } = n[0];
                $ = e + t + a + i + l + (r - s)
              }
            }
            l && (n[0].style.transform = l), o && (n[0].style.webkitTransform = o), a.roundLengths && ($ = Math.floor($))
          } else $ = (r - (a.slidesPerView - 1) * x) / a.slidesPerView, a.roundLengths && ($ = Math.floor($)), c[i] && (c[i].style[t("width")] = `${$}px`);
          c[i] && (c[i].swiperSlideSize = $), m.push($), a.centeredSlides ? (y = y + $ / 2 + E / 2 + x, 0 === E && 0 !== i && (y = y - r / 2 - x), 0 === i && (y = y - r / 2 - x), Math.abs(y) < .001 && (y = 0), a.roundLengths && (y = Math.floor(y)), C % a.slidesPerGroup == 0 && u.push(y), h.push(y)) : (a.roundLengths && (y = Math.floor(y)), (C - Math.min(e.params.slidesPerGroupSkip, C)) % e.params.slidesPerGroup == 0 && u.push(y), h.push(y), y = y + $ + x), e.virtualSize += $ + x, E = $, C += 1
        }
      }
      if (e.virtualSize = Math.max(e.virtualSize, r) + g, n && l && ("slide" === a.effect || "coverflow" === a.effect) && i.css({
          width: `${e.virtualSize+a.spaceBetween}px`
        }), a.setWrapperSize && i.css({
          [t("width")]: `${e.virtualSize+a.spaceBetween}px`
        }), T && e.grid.updateWrapperSize($, u, t), !a.centeredSlides) {
        const t = [];
        for (let s = 0; s < u.length; s += 1) {
          let i = u[s];
          a.roundLengths && (i = Math.floor(i)), u[s] <= e.virtualSize - r && t.push(i)
        }
        u = t, Math.floor(e.virtualSize - r) - Math.floor(u[u.length - 1]) > 1 && u.push(e.virtualSize - r)
      }
      if (0 === u.length && (u = [0]), 0 !== a.spaceBetween) {
        const s = e.isHorizontal() && n ? "marginLeft" : t("marginRight");
        c.filter(((e, t) => !a.cssMode || t !== c.length - 1)).css({
          [s]: `${x}px`
        })
      }
      if (a.centeredSlides && a.centeredSlidesBounds) {
        let e = 0;
        m.forEach((t => {
          e += t + (a.spaceBetween ? a.spaceBetween : 0)
        })), e -= a.spaceBetween;
        const t = e - r;
        u = u.map((e => e < 0 ? -f : e > t ? t + g : e))
      }
      if (a.centerInsufficientSlides) {
        let e = 0;
        if (m.forEach((t => {
            e += t + (a.spaceBetween ? a.spaceBetween : 0)
          })), e -= a.spaceBetween, e < r) {
          const t = (r - e) / 2;
          u.forEach(((e, s) => {
            u[s] = e - t
          })), h.forEach(((e, s) => {
            h[s] = e + t
          }))
        }
      }
      if (Object.assign(e, {
          slides: c,
          snapGrid: u,
          slidesGrid: h,
          slidesSizesGrid: m
        }), a.centeredSlides && a.cssMode && !a.centeredSlidesBounds) {
        v(e.wrapperEl, "--swiper-centered-offset-before", -u[0] + "px"), v(e.wrapperEl, "--swiper-centered-offset-after", e.size / 2 - m[m.length - 1] / 2 + "px");
        const t = -e.snapGrid[0],
          s = -e.slidesGrid[0];
        e.snapGrid = e.snapGrid.map((e => e + t)), e.slidesGrid = e.slidesGrid.map((e => e + s))
      }
      if (p !== d && e.emit("slidesLengthChange"), u.length !== w && (e.params.watchOverflow && e.checkOverflow(), e.emit("snapGridLengthChange")), h.length !== b && e.emit("slidesGridLengthChange"), a.watchSlidesProgress && e.updateSlidesOffset(), !(o || a.cssMode || "slide" !== a.effect && "fade" !== a.effect)) {
        const t = `${a.containerModifierClass}backface-hidden`,
          s = e.$el.hasClass(t);
        p <= a.maxBackfaceHiddenSlides ? s || e.$el.addClass(t) : s && e.$el.removeClass(t)
      }
    },
    updateAutoHeight: function (e) {
      const t = this,
        s = [],
        a = t.virtual && t.params.virtual.enabled;
      let i, r = 0;
      "number" == typeof e ? t.setTransition(e) : !0 === e && t.setTransition(t.params.speed);
      const n = e => a ? t.slides.filter((t => parseInt(t.getAttribute("data-swiper-slide-index"), 10) === e))[0] : t.slides.eq(e)[0];
      if ("auto" !== t.params.slidesPerView && t.params.slidesPerView > 1)
        if (t.params.centeredSlides)(t.visibleSlides || d([])).each((e => {
          s.push(e)
        }));
        else
          for (i = 0; i < Math.ceil(t.params.slidesPerView); i += 1) {
            const e = t.activeIndex + i;
            if (e > t.slides.length && !a) break;
            s.push(n(e))
          } else s.push(n(t.activeIndex));
      for (i = 0; i < s.length; i += 1)
        if (void 0 !== s[i]) {
          const e = s[i].offsetHeight;
          r = e > r ? e : r
        }(r || 0 === r) && t.$wrapperEl.css("height", `${r}px`)
    },
    updateSlidesOffset: function () {
      const e = this,
        t = e.slides;
      for (let s = 0; s < t.length; s += 1) t[s].swiperSlideOffset = e.isHorizontal() ? t[s].offsetLeft : t[s].offsetTop
    },
    updateSlidesProgress: function (e) {
      void 0 === e && (e = this && this.translate || 0);
      const t = this,
        s = t.params,
        {
          slides: a,
          rtlTranslate: i,
          snapGrid: r
        } = t;
      if (0 === a.length) return;
      void 0 === a[0].swiperSlideOffset && t.updateSlidesOffset();
      let n = -e;
      i && (n = e), a.removeClass(s.slideVisibleClass), t.visibleSlidesIndexes = [], t.visibleSlides = [];
      for (let e = 0; e < a.length; e += 1) {
        const l = a[e];
        let o = l.swiperSlideOffset;
        s.cssMode && s.centeredSlides && (o -= a[0].swiperSlideOffset);
        const d = (n + (s.centeredSlides ? t.minTranslate() : 0) - o) / (l.swiperSlideSize + s.spaceBetween),
          c = (n - r[0] + (s.centeredSlides ? t.minTranslate() : 0) - o) / (l.swiperSlideSize + s.spaceBetween),
          p = -(n - o),
          u = p + t.slidesSizesGrid[e];
        (p >= 0 && p < t.size - 1 || u > 1 && u <= t.size || p <= 0 && u >= t.size) && (t.visibleSlides.push(l), t.visibleSlidesIndexes.push(e), a.eq(e).addClass(s.slideVisibleClass)), l.progress = i ? -d : d, l.originalProgress = i ? -c : c
      }
      t.visibleSlides = d(t.visibleSlides)
    },
    updateProgress: function (e) {
      const t = this;
      if (void 0 === e) {
        const s = t.rtlTranslate ? -1 : 1;
        e = t && t.translate && t.translate * s || 0
      }
      const s = t.params,
        a = t.maxTranslate() - t.minTranslate();
      let {
        progress: i,
        isBeginning: r,
        isEnd: n
      } = t;
      const l = r,
        o = n;
      0 === a ? (i = 0, r = !0, n = !0) : (i = (e - t.minTranslate()) / a, r = i <= 0, n = i >= 1), Object.assign(t, {
        progress: i,
        isBeginning: r,
        isEnd: n
      }), (s.watchSlidesProgress || s.centeredSlides && s.autoHeight) && t.updateSlidesProgress(e), r && !l && t.emit("reachBeginning toEdge"), n && !o && t.emit("reachEnd toEdge"), (l && !r || o && !n) && t.emit("fromEdge"), t.emit("progress", i)
    },
    updateSlidesClasses: function () {
      const e = this,
        {
          slides: t,
          params: s,
          $wrapperEl: a,
          activeIndex: i,
          realIndex: r
        } = e,
        n = e.virtual && s.virtual.enabled;
      let l;
      t.removeClass(`${s.slideActiveClass} ${s.slideNextClass} ${s.slidePrevClass} ${s.slideDuplicateActiveClass} ${s.slideDuplicateNextClass} ${s.slideDuplicatePrevClass}`), l = n ? e.$wrapperEl.find(`.${s.slideClass}[data-swiper-slide-index="${i}"]`) : t.eq(i), l.addClass(s.slideActiveClass), s.loop && (l.hasClass(s.slideDuplicateClass) ? a.children(`.${s.slideClass}:not(.${s.slideDuplicateClass})[data-swiper-slide-index="${r}"]`).addClass(s.slideDuplicateActiveClass) : a.children(`.${s.slideClass}.${s.slideDuplicateClass}[data-swiper-slide-index="${r}"]`).addClass(s.slideDuplicateActiveClass));
      let o = l.nextAll(`.${s.slideClass}`).eq(0).addClass(s.slideNextClass);
      s.loop && 0 === o.length && (o = t.eq(0), o.addClass(s.slideNextClass));
      let d = l.prevAll(`.${s.slideClass}`).eq(0).addClass(s.slidePrevClass);
      s.loop && 0 === d.length && (d = t.eq(-1), d.addClass(s.slidePrevClass)), s.loop && (o.hasClass(s.slideDuplicateClass) ? a.children(`.${s.slideClass}:not(.${s.slideDuplicateClass})[data-swiper-slide-index="${o.attr("data-swiper-slide-index")}"]`).addClass(s.slideDuplicateNextClass) : a.children(`.${s.slideClass}.${s.slideDuplicateClass}[data-swiper-slide-index="${o.attr("data-swiper-slide-index")}"]`).addClass(s.slideDuplicateNextClass), d.hasClass(s.slideDuplicateClass) ? a.children(`.${s.slideClass}:not(.${s.slideDuplicateClass})[data-swiper-slide-index="${d.attr("data-swiper-slide-index")}"]`).addClass(s.slideDuplicatePrevClass) : a.children(`.${s.slideClass}.${s.slideDuplicateClass}[data-swiper-slide-index="${d.attr("data-swiper-slide-index")}"]`).addClass(s.slideDuplicatePrevClass)), e.emitSlidesClasses()
    },
    updateActiveIndex: function (e) {
      const t = this,
        s = t.rtlTranslate ? t.translate : -t.translate,
        {
          slidesGrid: a,
          snapGrid: i,
          params: r,
          activeIndex: n,
          realIndex: l,
          snapIndex: o
        } = t;
      let d, c = e;
      if (void 0 === c) {
        for (let e = 0; e < a.length; e += 1) void 0 !== a[e + 1] ? s >= a[e] && s < a[e + 1] - (a[e + 1] - a[e]) / 2 ? c = e : s >= a[e] && s < a[e + 1] && (c = e + 1) : s >= a[e] && (c = e);
        r.normalizeSlideIndex && (c < 0 || void 0 === c) && (c = 0)
      }
      if (i.indexOf(s) >= 0) d = i.indexOf(s);
      else {
        const e = Math.min(r.slidesPerGroupSkip, c);
        d = e + Math.floor((c - e) / r.slidesPerGroup)
      }
      if (d >= i.length && (d = i.length - 1), c === n) return void(d !== o && (t.snapIndex = d, t.emit("snapIndexChange")));
      const p = parseInt(t.slides.eq(c).attr("data-swiper-slide-index") || c, 10);
      Object.assign(t, {
        snapIndex: d,
        realIndex: p,
        previousIndex: n,
        activeIndex: c
      }), t.emit("activeIndexChange"), t.emit("snapIndexChange"), l !== p && t.emit("realIndexChange"), (t.initialized || t.params.runCallbacksOnInit) && t.emit("slideChange")
    },
    updateClickedSlide: function (e) {
      const t = this,
        s = t.params,
        a = d(e).closest(`.${s.slideClass}`)[0];
      let i, r = !1;
      if (a)
        for (let e = 0; e < t.slides.length; e += 1)
          if (t.slides[e] === a) {
            r = !0, i = e;
            break
          } if (!a || !r) return t.clickedSlide = void 0, void(t.clickedIndex = void 0);
      t.clickedSlide = a, t.virtual && t.params.virtual.enabled ? t.clickedIndex = parseInt(d(a).attr("data-swiper-slide-index"), 10) : t.clickedIndex = i, s.slideToClickedSlide && void 0 !== t.clickedIndex && t.clickedIndex !== t.activeIndex && t.slideToClickedSlide()
    }
  };
  var M = {
    getTranslate: function (e) {
      void 0 === e && (e = this.isHorizontal() ? "x" : "y");
      const {
        params: t,
        rtlTranslate: s,
        translate: a,
        $wrapperEl: i
      } = this;
      if (t.virtualTranslate) return s ? -a : a;
      if (t.cssMode) return a;
      let r = h(i[0], e);
      return s && (r = -r), r || 0
    },
    setTranslate: function (e, t) {
      const s = this,
        {
          rtlTranslate: a,
          params: i,
          $wrapperEl: r,
          wrapperEl: n,
          progress: l
        } = s;
      let o, d = 0,
        c = 0;
      s.isHorizontal() ? d = a ? -e : e : c = e, i.roundLengths && (d = Math.floor(d), c = Math.floor(c)), i.cssMode ? n[s.isHorizontal() ? "scrollLeft" : "scrollTop"] = s.isHorizontal() ? -d : -c : i.virtualTranslate || r.transform(`translate3d(${d}px, ${c}px, 0px)`), s.previousTranslate = s.translate, s.translate = s.isHorizontal() ? d : c;
      const p = s.maxTranslate() - s.minTranslate();
      o = 0 === p ? 0 : (e - s.minTranslate()) / p, o !== l && s.updateProgress(e), s.emit("setTranslate", s.translate, t)
    },
    minTranslate: function () {
      return -this.snapGrid[0]
    },
    maxTranslate: function () {
      return -this.snapGrid[this.snapGrid.length - 1]
    },
    translateTo: function (e, t, s, a, i) {
      void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === s && (s = !0), void 0 === a && (a = !0);
      const r = this,
        {
          params: n,
          wrapperEl: l
        } = r;
      if (r.animating && n.preventInteractionOnTransition) return !1;
      const o = r.minTranslate(),
        d = r.maxTranslate();
      let c;
      if (c = a && e > o ? o : a && e < d ? d : e, r.updateProgress(c), n.cssMode) {
        const e = r.isHorizontal();
        if (0 === t) l[e ? "scrollLeft" : "scrollTop"] = -c;
        else {
          if (!r.support.smoothScroll) return w({
            swiper: r,
            targetPosition: -c,
            side: e ? "left" : "top"
          }), !0;
          l.scrollTo({
            [e ? "left" : "top"]: -c,
            behavior: "smooth"
          })
        }
        return !0
      }
      return 0 === t ? (r.setTransition(0), r.setTranslate(c), s && (r.emit("beforeTransitionStart", t, i), r.emit("transitionEnd"))) : (r.setTransition(t), r.setTranslate(c), s && (r.emit("beforeTransitionStart", t, i), r.emit("transitionStart")), r.animating || (r.animating = !0, r.onTranslateToWrapperTransitionEnd || (r.onTranslateToWrapperTransitionEnd = function (e) {
        r && !r.destroyed && e.target === this && (r.$wrapperEl[0].removeEventListener("transitionend", r.onTranslateToWrapperTransitionEnd), r.$wrapperEl[0].removeEventListener("webkitTransitionEnd", r.onTranslateToWrapperTransitionEnd), r.onTranslateToWrapperTransitionEnd = null, delete r.onTranslateToWrapperTransitionEnd, s && r.emit("transitionEnd"))
      }), r.$wrapperEl[0].addEventListener("transitionend", r.onTranslateToWrapperTransitionEnd), r.$wrapperEl[0].addEventListener("webkitTransitionEnd", r.onTranslateToWrapperTransitionEnd))), !0
    }
  };

  function P(e) {
    let {
      swiper: t,
      runCallbacks: s,
      direction: a,
      step: i
    } = e;
    const {
      activeIndex: r,
      previousIndex: n
    } = t;
    let l = a;
    if (l || (l = r > n ? "next" : r < n ? "prev" : "reset"), t.emit(`transition${i}`), s && r !== n) {
      if ("reset" === l) return void t.emit(`slideResetTransition${i}`);
      t.emit(`slideChangeTransition${i}`), "next" === l ? t.emit(`slideNextTransition${i}`) : t.emit(`slidePrevTransition${i}`)
    }
  }
  var k = {
    slideTo: function (e, t, s, a, i) {
      if (void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === s && (s = !0), "number" != typeof e && "string" != typeof e) throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof e}] given.`);
      if ("string" == typeof e) {
        const t = parseInt(e, 10);
        if (!isFinite(t)) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${e}] given.`);
        e = t
      }
      const r = this;
      let n = e;
      n < 0 && (n = 0);
      const {
        params: l,
        snapGrid: o,
        slidesGrid: d,
        previousIndex: c,
        activeIndex: p,
        rtlTranslate: u,
        wrapperEl: h,
        enabled: m
      } = r;
      if (r.animating && l.preventInteractionOnTransition || !m && !a && !i) return !1;
      const f = Math.min(r.params.slidesPerGroupSkip, n);
      let g = f + Math.floor((n - f) / r.params.slidesPerGroup);
      g >= o.length && (g = o.length - 1), (p || l.initialSlide || 0) === (c || 0) && s && r.emit("beforeSlideChangeStart");
      const v = -o[g];
      if (r.updateProgress(v), l.normalizeSlideIndex)
        for (let e = 0; e < d.length; e += 1) {
          const t = -Math.floor(100 * v),
            s = Math.floor(100 * d[e]),
            a = Math.floor(100 * d[e + 1]);
          void 0 !== d[e + 1] ? t >= s && t < a - (a - s) / 2 ? n = e : t >= s && t < a && (n = e + 1) : t >= s && (n = e)
        }
      if (r.initialized && n !== p) {
        if (!r.allowSlideNext && v < r.translate && v < r.minTranslate()) return !1;
        if (!r.allowSlidePrev && v > r.translate && v > r.maxTranslate() && (p || 0) !== n) return !1
      }
      let b;
      if (b = n > p ? "next" : n < p ? "prev" : "reset", u && -v === r.translate || !u && v === r.translate) return r.updateActiveIndex(n), l.autoHeight && r.updateAutoHeight(), r.updateSlidesClasses(), "slide" !== l.effect && r.setTranslate(v), "reset" !== b && (r.transitionStart(s, b), r.transitionEnd(s, b)), !1;
      if (l.cssMode) {
        const e = r.isHorizontal(),
          s = u ? v : -v;
        if (0 === t) {
          const t = r.virtual && r.params.virtual.enabled;
          t && (r.wrapperEl.style.scrollSnapType = "none", r._immediateVirtual = !0), h[e ? "scrollLeft" : "scrollTop"] = s, t && requestAnimationFrame((() => {
            r.wrapperEl.style.scrollSnapType = "", r._swiperImmediateVirtual = !1
          }))
        } else {
          if (!r.support.smoothScroll) return w({
            swiper: r,
            targetPosition: s,
            side: e ? "left" : "top"
          }), !0;
          h.scrollTo({
            [e ? "left" : "top"]: s,
            behavior: "smooth"
          })
        }
        return !0
      }
      return r.setTransition(t), r.setTranslate(v), r.updateActiveIndex(n), r.updateSlidesClasses(), r.emit("beforeTransitionStart", t, a), r.transitionStart(s, b), 0 === t ? r.transitionEnd(s, b) : r.animating || (r.animating = !0, r.onSlideToWrapperTransitionEnd || (r.onSlideToWrapperTransitionEnd = function (e) {
        r && !r.destroyed && e.target === this && (r.$wrapperEl[0].removeEventListener("transitionend", r.onSlideToWrapperTransitionEnd), r.$wrapperEl[0].removeEventListener("webkitTransitionEnd", r.onSlideToWrapperTransitionEnd), r.onSlideToWrapperTransitionEnd = null, delete r.onSlideToWrapperTransitionEnd, r.transitionEnd(s, b))
      }), r.$wrapperEl[0].addEventListener("transitionend", r.onSlideToWrapperTransitionEnd), r.$wrapperEl[0].addEventListener("webkitTransitionEnd", r.onSlideToWrapperTransitionEnd)), !0
    },
    slideToLoop: function (e, t, s, a) {
      if (void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === s && (s = !0), "string" == typeof e) {
        const t = parseInt(e, 10);
        if (!isFinite(t)) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${e}] given.`);
        e = t
      }
      const i = this;
      let r = e;
      return i.params.loop && (r += i.loopedSlides), i.slideTo(r, t, s, a)
    },
    slideNext: function (e, t, s) {
      void 0 === e && (e = this.params.speed), void 0 === t && (t = !0);
      const a = this,
        {
          animating: i,
          enabled: r,
          params: n
        } = a;
      if (!r) return a;
      let l = n.slidesPerGroup;
      "auto" === n.slidesPerView && 1 === n.slidesPerGroup && n.slidesPerGroupAuto && (l = Math.max(a.slidesPerViewDynamic("current", !0), 1));
      const o = a.activeIndex < n.slidesPerGroupSkip ? 1 : l;
      if (n.loop) {
        if (i && n.loopPreventsSlide) return !1;
        a.loopFix(), a._clientLeft = a.$wrapperEl[0].clientLeft
      }
      return n.rewind && a.isEnd ? a.slideTo(0, e, t, s) : a.slideTo(a.activeIndex + o, e, t, s)
    },
    slidePrev: function (e, t, s) {
      void 0 === e && (e = this.params.speed), void 0 === t && (t = !0);
      const a = this,
        {
          params: i,
          animating: r,
          snapGrid: n,
          slidesGrid: l,
          rtlTranslate: o,
          enabled: d
        } = a;
      if (!d) return a;
      if (i.loop) {
        if (r && i.loopPreventsSlide) return !1;
        a.loopFix(), a._clientLeft = a.$wrapperEl[0].clientLeft
      }

      function c(e) {
        return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e)
      }
      const p = c(o ? a.translate : -a.translate),
        u = n.map((e => c(e)));
      let h = n[u.indexOf(p) - 1];
      if (void 0 === h && i.cssMode) {
        let e;
        n.forEach(((t, s) => {
          p >= t && (e = s)
        })), void 0 !== e && (h = n[e > 0 ? e - 1 : e])
      }
      let m = 0;
      if (void 0 !== h && (m = l.indexOf(h), m < 0 && (m = a.activeIndex - 1), "auto" === i.slidesPerView && 1 === i.slidesPerGroup && i.slidesPerGroupAuto && (m = m - a.slidesPerViewDynamic("previous", !0) + 1, m = Math.max(m, 0))), i.rewind && a.isBeginning) {
        const i = a.params.virtual && a.params.virtual.enabled && a.virtual ? a.virtual.slides.length - 1 : a.slides.length - 1;
        return a.slideTo(i, e, t, s)
      }
      return a.slideTo(m, e, t, s)
    },
    slideReset: function (e, t, s) {
      return void 0 === e && (e = this.params.speed), void 0 === t && (t = !0), this.slideTo(this.activeIndex, e, t, s)
    },
    slideToClosest: function (e, t, s, a) {
      void 0 === e && (e = this.params.speed), void 0 === t && (t = !0), void 0 === a && (a = .5);
      const i = this;
      let r = i.activeIndex;
      const n = Math.min(i.params.slidesPerGroupSkip, r),
        l = n + Math.floor((r - n) / i.params.slidesPerGroup),
        o = i.rtlTranslate ? i.translate : -i.translate;
      if (o >= i.snapGrid[l]) {
        const e = i.snapGrid[l];
        o - e > (i.snapGrid[l + 1] - e) * a && (r += i.params.slidesPerGroup)
      } else {
        const e = i.snapGrid[l - 1];
        o - e <= (i.snapGrid[l] - e) * a && (r -= i.params.slidesPerGroup)
      }
      return r = Math.max(r, 0), r = Math.min(r, i.slidesGrid.length - 1), i.slideTo(r, e, t, s)
    },
    slideToClickedSlide: function () {
      const e = this,
        {
          params: t,
          $wrapperEl: s
        } = e,
        a = "auto" === t.slidesPerView ? e.slidesPerViewDynamic() : t.slidesPerView;
      let i, r = e.clickedIndex;
      if (t.loop) {
        if (e.animating) return;
        i = parseInt(d(e.clickedSlide).attr("data-swiper-slide-index"), 10), t.centeredSlides ? r < e.loopedSlides - a / 2 || r > e.slides.length - e.loopedSlides + a / 2 ? (e.loopFix(), r = s.children(`.${t.slideClass}[data-swiper-slide-index="${i}"]:not(.${t.slideDuplicateClass})`).eq(0).index(), p((() => {
          e.slideTo(r)
        }))) : e.slideTo(r) : r > e.slides.length - a ? (e.loopFix(), r = s.children(`.${t.slideClass}[data-swiper-slide-index="${i}"]:not(.${t.slideDuplicateClass})`).eq(0).index(), p((() => {
          e.slideTo(r)
        }))) : e.slideTo(r)
      } else e.slideTo(r)
    }
  };
  var z = {
    loopCreate: function () {
      const e = this,
        t = a(),
        {
          params: s,
          $wrapperEl: i
        } = e,
        r = i.children().length > 0 ? d(i.children()[0].parentNode) : i;
      r.children(`.${s.slideClass}.${s.slideDuplicateClass}`).remove();
      let n = r.children(`.${s.slideClass}`);
      if (s.loopFillGroupWithBlank) {
        const e = s.slidesPerGroup - n.length % s.slidesPerGroup;
        if (e !== s.slidesPerGroup) {
          for (let a = 0; a < e; a += 1) {
            const e = d(t.createElement("div")).addClass(`${s.slideClass} ${s.slideBlankClass}`);
            r.append(e)
          }
          n = r.children(`.${s.slideClass}`)
        }
      }
      "auto" !== s.slidesPerView || s.loopedSlides || (s.loopedSlides = n.length), e.loopedSlides = Math.ceil(parseFloat(s.loopedSlides || s.slidesPerView, 10)), e.loopedSlides += s.loopAdditionalSlides, e.loopedSlides > n.length && e.params.loopedSlidesLimit && (e.loopedSlides = n.length);
      const l = [],
        o = [];
      n.each(((e, t) => {
        d(e).attr("data-swiper-slide-index", t)
      }));
      for (let t = 0; t < e.loopedSlides; t += 1) {
        const e = t - Math.floor(t / n.length) * n.length;
        o.push(n.eq(e)[0]), l.unshift(n.eq(n.length - e - 1)[0])
      }
      for (let e = 0; e < o.length; e += 1) r.append(d(o[e].cloneNode(!0)).addClass(s.slideDuplicateClass));
      for (let e = l.length - 1; e >= 0; e -= 1) r.prepend(d(l[e].cloneNode(!0)).addClass(s.slideDuplicateClass))
    },
    loopFix: function () {
      const e = this;
      e.emit("beforeLoopFix");
      const {
        activeIndex: t,
        slides: s,
        loopedSlides: a,
        allowSlidePrev: i,
        allowSlideNext: r,
        snapGrid: n,
        rtlTranslate: l
      } = e;
      let o;
      e.allowSlidePrev = !0, e.allowSlideNext = !0;
      const d = -n[t] - e.getTranslate();
      if (t < a) {
        o = s.length - 3 * a + t, o += a;
        e.slideTo(o, 0, !1, !0) && 0 !== d && e.setTranslate((l ? -e.translate : e.translate) - d)
      } else if (t >= s.length - a) {
        o = -s.length + t + a, o += a;
        e.slideTo(o, 0, !1, !0) && 0 !== d && e.setTranslate((l ? -e.translate : e.translate) - d)
      }
      e.allowSlidePrev = i, e.allowSlideNext = r, e.emit("loopFix")
    },
    loopDestroy: function () {
      const {
        $wrapperEl: e,
        params: t,
        slides: s
      } = this;
      e.children(`.${t.slideClass}.${t.slideDuplicateClass},.${t.slideClass}.${t.slideBlankClass}`).remove(), s.removeAttr("data-swiper-slide-index")
    }
  };

  function L(e) {
    const t = this,
      s = a(),
      i = r(),
      n = t.touchEventsData,
      {
        params: l,
        touches: o,
        enabled: c
      } = t;
    if (!c) return;
    if (t.animating && l.preventInteractionOnTransition) return;
    !t.animating && l.cssMode && l.loop && t.loopFix();
    let p = e;
    p.originalEvent && (p = p.originalEvent);
    let h = d(p.target);
    if ("wrapper" === l.touchEventsTarget && !h.closest(t.wrapperEl).length) return;
    if (n.isTouchEvent = "touchstart" === p.type, !n.isTouchEvent && "which" in p && 3 === p.which) return;
    if (!n.isTouchEvent && "button" in p && p.button > 0) return;
    if (n.isTouched && n.isMoved) return;
    !!l.noSwipingClass && "" !== l.noSwipingClass && p.target && p.target.shadowRoot && e.path && e.path[0] && (h = d(e.path[0]));
    const m = l.noSwipingSelector ? l.noSwipingSelector : `.${l.noSwipingClass}`,
      f = !(!p.target || !p.target.shadowRoot);
    if (l.noSwiping && (f ? function (e, t) {
        return void 0 === t && (t = this),
          function t(s) {
            if (!s || s === a() || s === r()) return null;
            s.assignedSlot && (s = s.assignedSlot);
            const i = s.closest(e);
            return i || s.getRootNode ? i || t(s.getRootNode().host) : null
          }(t)
      }(m, h[0]) : h.closest(m)[0])) return void(t.allowClick = !0);
    if (l.swipeHandler && !h.closest(l.swipeHandler)[0]) return;
    o.currentX = "touchstart" === p.type ? p.targetTouches[0].pageX : p.pageX, o.currentY = "touchstart" === p.type ? p.targetTouches[0].pageY : p.pageY;
    const g = o.currentX,
      v = o.currentY,
      w = l.edgeSwipeDetection || l.iOSEdgeSwipeDetection,
      b = l.edgeSwipeThreshold || l.iOSEdgeSwipeThreshold;
    if (w && (g <= b || g >= i.innerWidth - b)) {
      if ("prevent" !== w) return;
      e.preventDefault()
    }
    if (Object.assign(n, {
        isTouched: !0,
        isMoved: !1,
        allowTouchCallbacks: !0,
        isScrolling: void 0,
        startMoving: void 0
      }), o.startX = g, o.startY = v, n.touchStartTime = u(), t.allowClick = !0, t.updateSize(), t.swipeDirection = void 0, l.threshold > 0 && (n.allowThresholdMove = !1), "touchstart" !== p.type) {
      let e = !0;
      h.is(n.focusableElements) && (e = !1, "SELECT" === h[0].nodeName && (n.isTouched = !1)), s.activeElement && d(s.activeElement).is(n.focusableElements) && s.activeElement !== h[0] && s.activeElement.blur();
      const a = e && t.allowTouchMove && l.touchStartPreventDefault;
      !l.touchStartForcePreventDefault && !a || h[0].isContentEditable || p.preventDefault()
    }
    t.params.freeMode && t.params.freeMode.enabled && t.freeMode && t.animating && !l.cssMode && t.freeMode.onTouchStart(), t.emit("touchStart", p)
  }

  function O(e) {
    const t = a(),
      s = this,
      i = s.touchEventsData,
      {
        params: r,
        touches: n,
        rtlTranslate: l,
        enabled: o
      } = s;
    if (!o) return;
    let c = e;
    if (c.originalEvent && (c = c.originalEvent), !i.isTouched) return void(i.startMoving && i.isScrolling && s.emit("touchMoveOpposite", c));
    if (i.isTouchEvent && "touchmove" !== c.type) return;
    const p = "touchmove" === c.type && c.targetTouches && (c.targetTouches[0] || c.changedTouches[0]),
      h = "touchmove" === c.type ? p.pageX : c.pageX,
      m = "touchmove" === c.type ? p.pageY : c.pageY;
    if (c.preventedByNestedSwiper) return n.startX = h, void(n.startY = m);
    if (!s.allowTouchMove) return d(c.target).is(i.focusableElements) || (s.allowClick = !1), void(i.isTouched && (Object.assign(n, {
      startX: h,
      startY: m,
      currentX: h,
      currentY: m
    }), i.touchStartTime = u()));
    if (i.isTouchEvent && r.touchReleaseOnEdges && !r.loop)
      if (s.isVertical()) {
        if (m < n.startY && s.translate <= s.maxTranslate() || m > n.startY && s.translate >= s.minTranslate()) return i.isTouched = !1, void(i.isMoved = !1)
      } else if (h < n.startX && s.translate <= s.maxTranslate() || h > n.startX && s.translate >= s.minTranslate()) return;
    if (i.isTouchEvent && t.activeElement && c.target === t.activeElement && d(c.target).is(i.focusableElements)) return i.isMoved = !0, void(s.allowClick = !1);
    if (i.allowTouchCallbacks && s.emit("touchMove", c), c.targetTouches && c.targetTouches.length > 1) return;
    n.currentX = h, n.currentY = m;
    const f = n.currentX - n.startX,
      g = n.currentY - n.startY;
    if (s.params.threshold && Math.sqrt(f ** 2 + g ** 2) < s.params.threshold) return;
    if (void 0 === i.isScrolling) {
      let e;
      s.isHorizontal() && n.currentY === n.startY || s.isVertical() && n.currentX === n.startX ? i.isScrolling = !1 : f * f + g * g >= 25 && (e = 180 * Math.atan2(Math.abs(g), Math.abs(f)) / Math.PI, i.isScrolling = s.isHorizontal() ? e > r.touchAngle : 90 - e > r.touchAngle)
    }
    if (i.isScrolling && s.emit("touchMoveOpposite", c), void 0 === i.startMoving && (n.currentX === n.startX && n.currentY === n.startY || (i.startMoving = !0)), i.isScrolling) return void(i.isTouched = !1);
    if (!i.startMoving) return;
    s.allowClick = !1, !r.cssMode && c.cancelable && c.preventDefault(), r.touchMoveStopPropagation && !r.nested && c.stopPropagation(), i.isMoved || (r.loop && !r.cssMode && s.loopFix(), i.startTranslate = s.getTranslate(), s.setTransition(0), s.animating && s.$wrapperEl.trigger("webkitTransitionEnd transitionend"), i.allowMomentumBounce = !1, !r.grabCursor || !0 !== s.allowSlideNext && !0 !== s.allowSlidePrev || s.setGrabCursor(!0), s.emit("sliderFirstMove", c)), s.emit("sliderMove", c), i.isMoved = !0;
    let v = s.isHorizontal() ? f : g;
    n.diff = v, v *= r.touchRatio, l && (v = -v), s.swipeDirection = v > 0 ? "prev" : "next", i.currentTranslate = v + i.startTranslate;
    let w = !0,
      b = r.resistanceRatio;
    if (r.touchReleaseOnEdges && (b = 0), v > 0 && i.currentTranslate > s.minTranslate() ? (w = !1, r.resistance && (i.currentTranslate = s.minTranslate() - 1 + (-s.minTranslate() + i.startTranslate + v) ** b)) : v < 0 && i.currentTranslate < s.maxTranslate() && (w = !1, r.resistance && (i.currentTranslate = s.maxTranslate() + 1 - (s.maxTranslate() - i.startTranslate - v) ** b)), w && (c.preventedByNestedSwiper = !0), !s.allowSlideNext && "next" === s.swipeDirection && i.currentTranslate < i.startTranslate && (i.currentTranslate = i.startTranslate), !s.allowSlidePrev && "prev" === s.swipeDirection && i.currentTranslate > i.startTranslate && (i.currentTranslate = i.startTranslate), s.allowSlidePrev || s.allowSlideNext || (i.currentTranslate = i.startTranslate), r.threshold > 0) {
      if (!(Math.abs(v) > r.threshold || i.allowThresholdMove)) return void(i.currentTranslate = i.startTranslate);
      if (!i.allowThresholdMove) return i.allowThresholdMove = !0, n.startX = n.currentX, n.startY = n.currentY, i.currentTranslate = i.startTranslate, void(n.diff = s.isHorizontal() ? n.currentX - n.startX : n.currentY - n.startY)
    }
    r.followFinger && !r.cssMode && ((r.freeMode && r.freeMode.enabled && s.freeMode || r.watchSlidesProgress) && (s.updateActiveIndex(), s.updateSlidesClasses()), s.params.freeMode && r.freeMode.enabled && s.freeMode && s.freeMode.onTouchMove(), s.updateProgress(i.currentTranslate), s.setTranslate(i.currentTranslate))
  }

  function I(e) {
    const t = this,
      s = t.touchEventsData,
      {
        params: a,
        touches: i,
        rtlTranslate: r,
        slidesGrid: n,
        enabled: l
      } = t;
    if (!l) return;
    let o = e;
    if (o.originalEvent && (o = o.originalEvent), s.allowTouchCallbacks && t.emit("touchEnd", o), s.allowTouchCallbacks = !1, !s.isTouched) return s.isMoved && a.grabCursor && t.setGrabCursor(!1), s.isMoved = !1, void(s.startMoving = !1);
    a.grabCursor && s.isMoved && s.isTouched && (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) && t.setGrabCursor(!1);
    const d = u(),
      c = d - s.touchStartTime;
    if (t.allowClick) {
      const e = o.path || o.composedPath && o.composedPath();
      t.updateClickedSlide(e && e[0] || o.target), t.emit("tap click", o), c < 300 && d - s.lastClickTime < 300 && t.emit("doubleTap doubleClick", o)
    }
    if (s.lastClickTime = u(), p((() => {
        t.destroyed || (t.allowClick = !0)
      })), !s.isTouched || !s.isMoved || !t.swipeDirection || 0 === i.diff || s.currentTranslate === s.startTranslate) return s.isTouched = !1, s.isMoved = !1, void(s.startMoving = !1);
    let h;
    if (s.isTouched = !1, s.isMoved = !1, s.startMoving = !1, h = a.followFinger ? r ? t.translate : -t.translate : -s.currentTranslate, a.cssMode) return;
    if (t.params.freeMode && a.freeMode.enabled) return void t.freeMode.onTouchEnd({
      currentPos: h
    });
    let m = 0,
      f = t.slidesSizesGrid[0];
    for (let e = 0; e < n.length; e += e < a.slidesPerGroupSkip ? 1 : a.slidesPerGroup) {
      const t = e < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup;
      void 0 !== n[e + t] ? h >= n[e] && h < n[e + t] && (m = e, f = n[e + t] - n[e]) : h >= n[e] && (m = e, f = n[n.length - 1] - n[n.length - 2])
    }
    let g = null,
      v = null;
    a.rewind && (t.isBeginning ? v = t.params.virtual && t.params.virtual.enabled && t.virtual ? t.virtual.slides.length - 1 : t.slides.length - 1 : t.isEnd && (g = 0));
    const w = (h - n[m]) / f,
      b = m < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup;
    if (c > a.longSwipesMs) {
      if (!a.longSwipes) return void t.slideTo(t.activeIndex);
      "next" === t.swipeDirection && (w >= a.longSwipesRatio ? t.slideTo(a.rewind && t.isEnd ? g : m + b) : t.slideTo(m)), "prev" === t.swipeDirection && (w > 1 - a.longSwipesRatio ? t.slideTo(m + b) : null !== v && w < 0 && Math.abs(w) > a.longSwipesRatio ? t.slideTo(v) : t.slideTo(m))
    } else {
      if (!a.shortSwipes) return void t.slideTo(t.activeIndex);
      t.navigation && (o.target === t.navigation.nextEl || o.target === t.navigation.prevEl) ? o.target === t.navigation.nextEl ? t.slideTo(m + b) : t.slideTo(m) : ("next" === t.swipeDirection && t.slideTo(null !== g ? g : m + b), "prev" === t.swipeDirection && t.slideTo(null !== v ? v : m))
    }
  }

  function A() {
    const e = this,
      {
        params: t,
        el: s
      } = e;
    if (s && 0 === s.offsetWidth) return;
    t.breakpoints && e.setBreakpoint();
    const {
      allowSlideNext: a,
      allowSlidePrev: i,
      snapGrid: r
    } = e;
    e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses(), ("auto" === t.slidesPerView || t.slidesPerView > 1) && e.isEnd && !e.isBeginning && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.run(), e.allowSlidePrev = i, e.allowSlideNext = a, e.params.watchOverflow && r !== e.snapGrid && e.checkOverflow()
  }

  function D(e) {
    const t = this;
    t.enabled && (t.allowClick || (t.params.preventClicks && e.preventDefault(), t.params.preventClicksPropagation && t.animating && (e.stopPropagation(), e.stopImmediatePropagation())))
  }

  function G() {
    const e = this,
      {
        wrapperEl: t,
        rtlTranslate: s,
        enabled: a
      } = e;
    if (!a) return;
    let i;
    e.previousTranslate = e.translate, e.isHorizontal() ? e.translate = -t.scrollLeft : e.translate = -t.scrollTop, 0 === e.translate && (e.translate = 0), e.updateActiveIndex(), e.updateSlidesClasses();
    const r = e.maxTranslate() - e.minTranslate();
    i = 0 === r ? 0 : (e.translate - e.minTranslate()) / r, i !== e.progress && e.updateProgress(s ? -e.translate : e.translate), e.emit("setTranslate", e.translate, !1)
  }
  let N = !1;

  function B() {}
  const H = (e, t) => {
    const s = a(),
      {
        params: i,
        touchEvents: r,
        el: n,
        wrapperEl: l,
        device: o,
        support: d
      } = e,
      c = !!i.nested,
      p = "on" === t ? "addEventListener" : "removeEventListener",
      u = t;
    if (d.touch) {
      const t = !("touchstart" !== r.start || !d.passiveListener || !i.passiveListeners) && {
        passive: !0,
        capture: !1
      };
      n[p](r.start, e.onTouchStart, t), n[p](r.move, e.onTouchMove, d.passiveListener ? {
        passive: !1,
        capture: c
      } : c), n[p](r.end, e.onTouchEnd, t), r.cancel && n[p](r.cancel, e.onTouchEnd, t)
    } else n[p](r.start, e.onTouchStart, !1), s[p](r.move, e.onTouchMove, c), s[p](r.end, e.onTouchEnd, !1);
    (i.preventClicks || i.preventClicksPropagation) && n[p]("click", e.onClick, !0), i.cssMode && l[p]("scroll", e.onScroll), i.updateOnWindowResize ? e[u](o.ios || o.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", A, !0) : e[u]("observerUpdate", A, !0)
  };
  var X = {
    attachEvents: function () {
      const e = this,
        t = a(),
        {
          params: s,
          support: i
        } = e;
      e.onTouchStart = L.bind(e), e.onTouchMove = O.bind(e), e.onTouchEnd = I.bind(e), s.cssMode && (e.onScroll = G.bind(e)), e.onClick = D.bind(e), i.touch && !N && (t.addEventListener("touchstart", B), N = !0), H(e, "on")
    },
    detachEvents: function () {
      H(this, "off")
    }
  };
  const Y = (e, t) => e.grid && t.grid && t.grid.rows > 1;
  var R = {
    addClasses: function () {
      const e = this,
        {
          classNames: t,
          params: s,
          rtl: a,
          $el: i,
          device: r,
          support: n
        } = e,
        l = function (e, t) {
          const s = [];
          return e.forEach((e => {
            "object" == typeof e ? Object.keys(e).forEach((a => {
              e[a] && s.push(t + a)
            })) : "string" == typeof e && s.push(t + e)
          })), s
        }(["initialized", s.direction, {
          "pointer-events": !n.touch
        }, {
          "free-mode": e.params.freeMode && s.freeMode.enabled
        }, {
          autoheight: s.autoHeight
        }, {
          rtl: a
        }, {
          grid: s.grid && s.grid.rows > 1
        }, {
          "grid-column": s.grid && s.grid.rows > 1 && "column" === s.grid.fill
        }, {
          android: r.android
        }, {
          ios: r.ios
        }, {
          "css-mode": s.cssMode
        }, {
          centered: s.cssMode && s.centeredSlides
        }, {
          "watch-progress": s.watchSlidesProgress
        }], s.containerModifierClass);
      t.push(...l), i.addClass([...t].join(" ")), e.emitContainerClasses()
    },
    removeClasses: function () {
      const {
        $el: e,
        classNames: t
      } = this;
      e.removeClass(t.join(" ")), this.emitContainerClasses()
    }
  };
  var W = {
    init: !0,
    direction: "horizontal",
    touchEventsTarget: "wrapper",
    initialSlide: 0,
    speed: 300,
    cssMode: !1,
    updateOnWindowResize: !0,
    resizeObserver: !0,
    nested: !1,
    createElements: !1,
    enabled: !0,
    focusableElements: "input, select, option, textarea, button, video, label",
    width: null,
    height: null,
    preventInteractionOnTransition: !1,
    userAgent: null,
    url: null,
    edgeSwipeDetection: !1,
    edgeSwipeThreshold: 20,
    autoHeight: !1,
    setWrapperSize: !1,
    virtualTranslate: !1,
    effect: "slide",
    breakpoints: void 0,
    breakpointsBase: "window",
    spaceBetween: 0,
    slidesPerView: 1,
    slidesPerGroup: 1,
    slidesPerGroupSkip: 0,
    slidesPerGroupAuto: !1,
    centeredSlides: !1,
    centeredSlidesBounds: !1,
    slidesOffsetBefore: 0,
    slidesOffsetAfter: 0,
    normalizeSlideIndex: !0,
    centerInsufficientSlides: !1,
    watchOverflow: !0,
    roundLengths: !1,
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: !0,
    shortSwipes: !0,
    longSwipes: !0,
    longSwipesRatio: .5,
    longSwipesMs: 300,
    followFinger: !0,
    allowTouchMove: !0,
    threshold: 0,
    touchMoveStopPropagation: !1,
    touchStartPreventDefault: !0,
    touchStartForcePreventDefault: !1,
    touchReleaseOnEdges: !1,
    uniqueNavElements: !0,
    resistance: !0,
    resistanceRatio: .85,
    watchSlidesProgress: !1,
    grabCursor: !1,
    preventClicks: !0,
    preventClicksPropagation: !0,
    slideToClickedSlide: !1,
    preloadImages: !0,
    updateOnImagesReady: !0,
    loop: !1,
    loopAdditionalSlides: 0,
    loopedSlides: null,
    loopedSlidesLimit: !0,
    loopFillGroupWithBlank: !1,
    loopPreventsSlide: !0,
    rewind: !1,
    allowSlidePrev: !0,
    allowSlideNext: !0,
    swipeHandler: null,
    noSwiping: !0,
    noSwipingClass: "swiper-no-swiping",
    noSwipingSelector: null,
    passiveListeners: !0,
    maxBackfaceHiddenSlides: 10,
    containerModifierClass: "swiper-",
    slideClass: "swiper-slide",
    slideBlankClass: "swiper-slide-invisible-blank",
    slideActiveClass: "swiper-slide-active",
    slideDuplicateActiveClass: "swiper-slide-duplicate-active",
    slideVisibleClass: "swiper-slide-visible",
    slideDuplicateClass: "swiper-slide-duplicate",
    slideNextClass: "swiper-slide-next",
    slideDuplicateNextClass: "swiper-slide-duplicate-next",
    slidePrevClass: "swiper-slide-prev",
    slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
    wrapperClass: "swiper-wrapper",
    runCallbacksOnInit: !0,
    _emitClasses: !1
  };

  function j(e, t) {
    return function (s) {
      void 0 === s && (s = {});
      const a = Object.keys(s)[0],
        i = s[a];
      "object" == typeof i && null !== i ? (["navigation", "pagination", "scrollbar"].indexOf(a) >= 0 && !0 === e[a] && (e[a] = {
        auto: !0
      }), a in e && "enabled" in i ? (!0 === e[a] && (e[a] = {
        enabled: !0
      }), "object" != typeof e[a] || "enabled" in e[a] || (e[a].enabled = !0), e[a] || (e[a] = {
        enabled: !1
      }), g(t, s)) : g(t, s)) : g(t, s)
    }
  }
  const q = {
      eventsEmitter: $,
      update: S,
      translate: M,
      transition: {
        setTransition: function (e, t) {
          const s = this;
          s.params.cssMode || s.$wrapperEl.transition(e), s.emit("setTransition", e, t)
        },
        transitionStart: function (e, t) {
          void 0 === e && (e = !0);
          const s = this,
            {
              params: a
            } = s;
          a.cssMode || (a.autoHeight && s.updateAutoHeight(), P({
            swiper: s,
            runCallbacks: e,
            direction: t,
            step: "Start"
          }))
        },
        transitionEnd: function (e, t) {
          void 0 === e && (e = !0);
          const s = this,
            {
              params: a
            } = s;
          s.animating = !1, a.cssMode || (s.setTransition(0), P({
            swiper: s,
            runCallbacks: e,
            direction: t,
            step: "End"
          }))
        }
      },
      slide: k,
      loop: z,
      grabCursor: {
        setGrabCursor: function (e) {
          const t = this;
          if (t.support.touch || !t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode) return;
          const s = "container" === t.params.touchEventsTarget ? t.el : t.wrapperEl;
          s.style.cursor = "move", s.style.cursor = e ? "grabbing" : "grab"
        },
        unsetGrabCursor: function () {
          const e = this;
          e.support.touch || e.params.watchOverflow && e.isLocked || e.params.cssMode || (e["container" === e.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "")
        }
      },
      events: X,
      breakpoints: {
        setBreakpoint: function () {
          const e = this,
            {
              activeIndex: t,
              initialized: s,
              loopedSlides: a = 0,
              params: i,
              $el: r
            } = e,
            n = i.breakpoints;
          if (!n || n && 0 === Object.keys(n).length) return;
          const l = e.getBreakpoint(n, e.params.breakpointsBase, e.el);
          if (!l || e.currentBreakpoint === l) return;
          const o = (l in n ? n[l] : void 0) || e.originalParams,
            d = Y(e, i),
            c = Y(e, o),
            p = i.enabled;
          d && !c ? (r.removeClass(`${i.containerModifierClass}grid ${i.containerModifierClass}grid-column`), e.emitContainerClasses()) : !d && c && (r.addClass(`${i.containerModifierClass}grid`), (o.grid.fill && "column" === o.grid.fill || !o.grid.fill && "column" === i.grid.fill) && r.addClass(`${i.containerModifierClass}grid-column`), e.emitContainerClasses()), ["navigation", "pagination", "scrollbar"].forEach((t => {
            const s = i[t] && i[t].enabled,
              a = o[t] && o[t].enabled;
            s && !a && e[t].disable(), !s && a && e[t].enable()
          }));
          const u = o.direction && o.direction !== i.direction,
            h = i.loop && (o.slidesPerView !== i.slidesPerView || u);
          u && s && e.changeDirection(), g(e.params, o);
          const m = e.params.enabled;
          Object.assign(e, {
            allowTouchMove: e.params.allowTouchMove,
            allowSlideNext: e.params.allowSlideNext,
            allowSlidePrev: e.params.allowSlidePrev
          }), p && !m ? e.disable() : !p && m && e.enable(), e.currentBreakpoint = l, e.emit("_beforeBreakpoint", o), h && s && (e.loopDestroy(), e.loopCreate(), e.updateSlides(), e.slideTo(t - a + e.loopedSlides, 0, !1)), e.emit("breakpoint", o)
        },
        getBreakpoint: function (e, t, s) {
          if (void 0 === t && (t = "window"), !e || "container" === t && !s) return;
          let a = !1;
          const i = r(),
            n = "window" === t ? i.innerHeight : s.clientHeight,
            l = Object.keys(e).map((e => {
              if ("string" == typeof e && 0 === e.indexOf("@")) {
                const t = parseFloat(e.substr(1));
                return {
                  value: n * t,
                  point: e
                }
              }
              return {
                value: e,
                point: e
              }
            }));
          l.sort(((e, t) => parseInt(e.value, 10) - parseInt(t.value, 10)));
          for (let e = 0; e < l.length; e += 1) {
            const {
              point: r,
              value: n
            } = l[e];
            "window" === t ? i.matchMedia(`(min-width: ${n}px)`).matches && (a = r) : n <= s.clientWidth && (a = r)
          }
          return a || "max"
        }
      },
      checkOverflow: {
        checkOverflow: function () {
          const e = this,
            {
              isLocked: t,
              params: s
            } = e,
            {
              slidesOffsetBefore: a
            } = s;
          if (a) {
            const t = e.slides.length - 1,
              s = e.slidesGrid[t] + e.slidesSizesGrid[t] + 2 * a;
            e.isLocked = e.size > s
          } else e.isLocked = 1 === e.snapGrid.length;
          !0 === s.allowSlideNext && (e.allowSlideNext = !e.isLocked), !0 === s.allowSlidePrev && (e.allowSlidePrev = !e.isLocked), t && t !== e.isLocked && (e.isEnd = !1), t !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock")
        }
      },
      classes: R,
      images: {
        loadImage: function (e, t, s, a, i, n) {
          const l = r();
          let o;

          function c() {
            n && n()
          }
          d(e).parent("picture")[0] || e.complete && i ? c() : t ? (o = new l.Image, o.onload = c, o.onerror = c, a && (o.sizes = a), s && (o.srcset = s), t && (o.src = t)) : c()
        },
        preloadImages: function () {
          const e = this;

          function t() {
            null != e && e && !e.destroyed && (void 0 !== e.imagesLoaded && (e.imagesLoaded += 1), e.imagesLoaded === e.imagesToLoad.length && (e.params.updateOnImagesReady && e.update(), e.emit("imagesReady")))
          }
          e.imagesToLoad = e.$el.find("img");
          for (let s = 0; s < e.imagesToLoad.length; s += 1) {
            const a = e.imagesToLoad[s];
            e.loadImage(a, a.currentSrc || a.getAttribute("src"), a.srcset || a.getAttribute("srcset"), a.sizes || a.getAttribute("sizes"), !0, t)
          }
        }
      }
    },
    _ = {};
  class V {
    constructor() {
      let e, t;
      for (var s = arguments.length, a = new Array(s), i = 0; i < s; i++) a[i] = arguments[i];
      if (1 === a.length && a[0].constructor && "Object" === Object.prototype.toString.call(a[0]).slice(8, -1) ? t = a[0] : [e, t] = a, t || (t = {}), t = g({}, t), e && !t.el && (t.el = e), t.el && d(t.el).length > 1) {
        const e = [];
        return d(t.el).each((s => {
          const a = g({}, t, {
            el: s
          });
          e.push(new V(a))
        })), e
      }
      const r = this;
      r.__swiper__ = !0, r.support = E(), r.device = C({
        userAgent: t.userAgent
      }), r.browser = T(), r.eventsListeners = {}, r.eventsAnyListeners = [], r.modules = [...r.__modules__], t.modules && Array.isArray(t.modules) && r.modules.push(...t.modules);
      const n = {};
      r.modules.forEach((e => {
        e({
          swiper: r,
          extendParams: j(t, n),
          on: r.on.bind(r),
          once: r.once.bind(r),
          off: r.off.bind(r),
          emit: r.emit.bind(r)
        })
      }));
      const l = g({}, W, n);
      return r.params = g({}, l, _, t), r.originalParams = g({}, r.params), r.passedParams = g({}, t), r.params && r.params.on && Object.keys(r.params.on).forEach((e => {
        r.on(e, r.params.on[e])
      })), r.params && r.params.onAny && r.onAny(r.params.onAny), r.$ = d, Object.assign(r, {
        enabled: r.params.enabled,
        el: e,
        classNames: [],
        slides: d(),
        slidesGrid: [],
        snapGrid: [],
        slidesSizesGrid: [],
        isHorizontal: () => "horizontal" === r.params.direction,
        isVertical: () => "vertical" === r.params.direction,
        activeIndex: 0,
        realIndex: 0,
        isBeginning: !0,
        isEnd: !1,
        translate: 0,
        previousTranslate: 0,
        progress: 0,
        velocity: 0,
        animating: !1,
        allowSlideNext: r.params.allowSlideNext,
        allowSlidePrev: r.params.allowSlidePrev,
        touchEvents: function () {
          const e = ["touchstart", "touchmove", "touchend", "touchcancel"],
            t = ["pointerdown", "pointermove", "pointerup"];
          return r.touchEventsTouch = {
            start: e[0],
            move: e[1],
            end: e[2],
            cancel: e[3]
          }, r.touchEventsDesktop = {
            start: t[0],
            move: t[1],
            end: t[2]
          }, r.support.touch || !r.params.simulateTouch ? r.touchEventsTouch : r.touchEventsDesktop
        }(),
        touchEventsData: {
          isTouched: void 0,
          isMoved: void 0,
          allowTouchCallbacks: void 0,
          touchStartTime: void 0,
          isScrolling: void 0,
          currentTranslate: void 0,
          startTranslate: void 0,
          allowThresholdMove: void 0,
          focusableElements: r.params.focusableElements,
          lastClickTime: u(),
          clickTimeout: void 0,
          velocities: [],
          allowMomentumBounce: void 0,
          isTouchEvent: void 0,
          startMoving: void 0
        },
        allowClick: !0,
        allowTouchMove: r.params.allowTouchMove,
        touches: {
          startX: 0,
          startY: 0,
          currentX: 0,
          currentY: 0,
          diff: 0
        },
        imagesToLoad: [],
        imagesLoaded: 0
      }), r.emit("_swiper"), r.params.init && r.init(), r
    }
    enable() {
      const e = this;
      e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit("enable"))
    }
    disable() {
      const e = this;
      e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit("disable"))
    }
    setProgress(e, t) {
      const s = this;
      e = Math.min(Math.max(e, 0), 1);
      const a = s.minTranslate(),
        i = (s.maxTranslate() - a) * e + a;
      s.translateTo(i, void 0 === t ? 0 : t), s.updateActiveIndex(), s.updateSlidesClasses()
    }
    emitContainerClasses() {
      const e = this;
      if (!e.params._emitClasses || !e.el) return;
      const t = e.el.className.split(" ").filter((t => 0 === t.indexOf("swiper") || 0 === t.indexOf(e.params.containerModifierClass)));
      e.emit("_containerClasses", t.join(" "))
    }
    getSlideClasses(e) {
      const t = this;
      return t.destroyed ? "" : e.className.split(" ").filter((e => 0 === e.indexOf("swiper-slide") || 0 === e.indexOf(t.params.slideClass))).join(" ")
    }
    emitSlidesClasses() {
      const e = this;
      if (!e.params._emitClasses || !e.el) return;
      const t = [];
      e.slides.each((s => {
        const a = e.getSlideClasses(s);
        t.push({
          slideEl: s,
          classNames: a
        }), e.emit("_slideClass", s, a)
      })), e.emit("_slideClasses", t)
    }
    slidesPerViewDynamic(e, t) {
      void 0 === e && (e = "current"), void 0 === t && (t = !1);
      const {
        params: s,
        slides: a,
        slidesGrid: i,
        slidesSizesGrid: r,
        size: n,
        activeIndex: l
      } = this;
      let o = 1;
      if (s.centeredSlides) {
        let e, t = a[l].swiperSlideSize;
        for (let s = l + 1; s < a.length; s += 1) a[s] && !e && (t += a[s].swiperSlideSize, o += 1, t > n && (e = !0));
        for (let s = l - 1; s >= 0; s -= 1) a[s] && !e && (t += a[s].swiperSlideSize, o += 1, t > n && (e = !0))
      } else if ("current" === e)
        for (let e = l + 1; e < a.length; e += 1) {
          (t ? i[e] + r[e] - i[l] < n : i[e] - i[l] < n) && (o += 1)
        } else
          for (let e = l - 1; e >= 0; e -= 1) {
            i[l] - i[e] < n && (o += 1)
          }
      return o
    }
    update() {
      const e = this;
      if (!e || e.destroyed) return;
      const {
        snapGrid: t,
        params: s
      } = e;

      function a() {
        const t = e.rtlTranslate ? -1 * e.translate : e.translate,
          s = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate());
        e.setTranslate(s), e.updateActiveIndex(), e.updateSlidesClasses()
      }
      let i;
      s.breakpoints && e.setBreakpoint(), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), e.params.freeMode && e.params.freeMode.enabled ? (a(), e.params.autoHeight && e.updateAutoHeight()) : (i = ("auto" === e.params.slidesPerView || e.params.slidesPerView > 1) && e.isEnd && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), i || a()), s.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit("update")
    }
    changeDirection(e, t) {
      void 0 === t && (t = !0);
      const s = this,
        a = s.params.direction;
      return e || (e = "horizontal" === a ? "vertical" : "horizontal"), e === a || "horizontal" !== e && "vertical" !== e || (s.$el.removeClass(`${s.params.containerModifierClass}${a}`).addClass(`${s.params.containerModifierClass}${e}`), s.emitContainerClasses(), s.params.direction = e, s.slides.each((t => {
        "vertical" === e ? t.style.width = "" : t.style.height = ""
      })), s.emit("changeDirection"), t && s.update()), s
    }
    changeLanguageDirection(e) {
      const t = this;
      t.rtl && "rtl" === e || !t.rtl && "ltr" === e || (t.rtl = "rtl" === e, t.rtlTranslate = "horizontal" === t.params.direction && t.rtl, t.rtl ? (t.$el.addClass(`${t.params.containerModifierClass}rtl`), t.el.dir = "rtl") : (t.$el.removeClass(`${t.params.containerModifierClass}rtl`), t.el.dir = "ltr"), t.update())
    }
    mount(e) {
      const t = this;
      if (t.mounted) return !0;
      const s = d(e || t.params.el);
      if (!(e = s[0])) return !1;
      e.swiper = t;
      const i = () => `.${(t.params.wrapperClass||"").trim().split(" ").join(".")}`;
      let r = (() => {
        if (e && e.shadowRoot && e.shadowRoot.querySelector) {
          const t = d(e.shadowRoot.querySelector(i()));
          return t.children = e => s.children(e), t
        }
        return s.children ? s.children(i()) : d(s).children(i())
      })();
      if (0 === r.length && t.params.createElements) {
        const e = a().createElement("div");
        r = d(e), e.className = t.params.wrapperClass, s.append(e), s.children(`.${t.params.slideClass}`).each((e => {
          r.append(e)
        }))
      }
      return Object.assign(t, {
        $el: s,
        el: e,
        $wrapperEl: r,
        wrapperEl: r[0],
        mounted: !0,
        rtl: "rtl" === e.dir.toLowerCase() || "rtl" === s.css("direction"),
        rtlTranslate: "horizontal" === t.params.direction && ("rtl" === e.dir.toLowerCase() || "rtl" === s.css("direction")),
        wrongRTL: "-webkit-box" === r.css("display")
      }), !0
    }
    init(e) {
      const t = this;
      if (t.initialized) return t;
      return !1 === t.mount(e) || (t.emit("beforeInit"), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.params.loop && t.loopCreate(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.preloadImages && t.preloadImages(), t.params.loop ? t.slideTo(t.params.initialSlide + t.loopedSlides, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.attachEvents(), t.initialized = !0, t.emit("init"), t.emit("afterInit")), t
    }
    destroy(e, t) {
      void 0 === e && (e = !0), void 0 === t && (t = !0);
      const s = this,
        {
          params: a,
          $el: i,
          $wrapperEl: r,
          slides: n
        } = s;
      return void 0 === s.params || s.destroyed || (s.emit("beforeDestroy"), s.initialized = !1, s.detachEvents(), a.loop && s.loopDestroy(), t && (s.removeClasses(), i.removeAttr("style"), r.removeAttr("style"), n && n.length && n.removeClass([a.slideVisibleClass, a.slideActiveClass, a.slideNextClass, a.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index")), s.emit("destroy"), Object.keys(s.eventsListeners).forEach((e => {
        s.off(e)
      })), !1 !== e && (s.$el[0].swiper = null, function (e) {
        const t = e;
        Object.keys(t).forEach((e => {
          try {
            t[e] = null
          } catch (e) {}
          try {
            delete t[e]
          } catch (e) {}
        }))
      }(s)), s.destroyed = !0), null
    }
    static extendDefaults(e) {
      g(_, e)
    }
    static get extendedDefaults() {
      return _
    }
    static get defaults() {
      return W
    }
    static installModule(e) {
      V.prototype.__modules__ || (V.prototype.__modules__ = []);
      const t = V.prototype.__modules__;
      "function" == typeof e && t.indexOf(e) < 0 && t.push(e)
    }
    static use(e) {
      return Array.isArray(e) ? (e.forEach((e => V.installModule(e))), V) : (V.installModule(e), V)
    }
  }

  function F(e, t, s, i) {
    const r = a();
    return e.params.createElements && Object.keys(i).forEach((a => {
      if (!s[a] && !0 === s.auto) {
        let n = e.$el.children(`.${i[a]}`)[0];
        n || (n = r.createElement("div"), n.className = i[a], e.$el.append(n)), s[a] = n, t[a] = n
      }
    })), s
  }

  function U(e) {
    return void 0 === e && (e = ""), `.${e.trim().replace(/([\.:!\/])/g,"\\$1").replace(/ /g,".")}`
  }

  function K(e) {
    const t = this,
      {
        $wrapperEl: s,
        params: a
      } = t;
    if (a.loop && t.loopDestroy(), "object" == typeof e && "length" in e)
      for (let t = 0; t < e.length; t += 1) e[t] && s.append(e[t]);
    else s.append(e);
    a.loop && t.loopCreate(), a.observer || t.update()
  }

  function Z(e) {
    const t = this,
      {
        params: s,
        $wrapperEl: a,
        activeIndex: i
      } = t;
    s.loop && t.loopDestroy();
    let r = i + 1;
    if ("object" == typeof e && "length" in e) {
      for (let t = 0; t < e.length; t += 1) e[t] && a.prepend(e[t]);
      r = i + e.length
    } else a.prepend(e);
    s.loop && t.loopCreate(), s.observer || t.update(), t.slideTo(r, 0, !1)
  }

  function Q(e, t) {
    const s = this,
      {
        $wrapperEl: a,
        params: i,
        activeIndex: r
      } = s;
    let n = r;
    i.loop && (n -= s.loopedSlides, s.loopDestroy(), s.slides = a.children(`.${i.slideClass}`));
    const l = s.slides.length;
    if (e <= 0) return void s.prependSlide(t);
    if (e >= l) return void s.appendSlide(t);
    let o = n > e ? n + 1 : n;
    const d = [];
    for (let t = l - 1; t >= e; t -= 1) {
      const e = s.slides.eq(t);
      e.remove(), d.unshift(e)
    }
    if ("object" == typeof t && "length" in t) {
      for (let e = 0; e < t.length; e += 1) t[e] && a.append(t[e]);
      o = n > e ? n + t.length : n
    } else a.append(t);
    for (let e = 0; e < d.length; e += 1) a.append(d[e]);
    i.loop && s.loopCreate(), i.observer || s.update(), i.loop ? s.slideTo(o + s.loopedSlides, 0, !1) : s.slideTo(o, 0, !1)
  }

  function J(e) {
    const t = this,
      {
        params: s,
        $wrapperEl: a,
        activeIndex: i
      } = t;
    let r = i;
    s.loop && (r -= t.loopedSlides, t.loopDestroy(), t.slides = a.children(`.${s.slideClass}`));
    let n, l = r;
    if ("object" == typeof e && "length" in e) {
      for (let s = 0; s < e.length; s += 1) n = e[s], t.slides[n] && t.slides.eq(n).remove(), n < l && (l -= 1);
      l = Math.max(l, 0)
    } else n = e, t.slides[n] && t.slides.eq(n).remove(), n < l && (l -= 1), l = Math.max(l, 0);
    s.loop && t.loopCreate(), s.observer || t.update(), s.loop ? t.slideTo(l + t.loopedSlides, 0, !1) : t.slideTo(l, 0, !1)
  }

  function ee() {
    const e = this,
      t = [];
    for (let s = 0; s < e.slides.length; s += 1) t.push(s);
    e.removeSlide(t)
  }

  function te(e) {
    const {
      effect: t,
      swiper: s,
      on: a,
      setTranslate: i,
      setTransition: r,
      overwriteParams: n,
      perspective: l,
      recreateShadows: o,
      getEffectParams: d
    } = e;
    let c;
    a("beforeInit", (() => {
      if (s.params.effect !== t) return;
      s.classNames.push(`${s.params.containerModifierClass}${t}`), l && l() && s.classNames.push(`${s.params.containerModifierClass}3d`);
      const e = n ? n() : {};
      Object.assign(s.params, e), Object.assign(s.originalParams, e)
    })), a("setTranslate", (() => {
      s.params.effect === t && i()
    })), a("setTransition", ((e, a) => {
      s.params.effect === t && r(a)
    })), a("transitionEnd", (() => {
      if (s.params.effect === t && o) {
        if (!d || !d().slideShadows) return;
        s.slides.each((e => {
          s.$(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").remove()
        })), o()
      }
    })), a("virtualUpdate", (() => {
      s.params.effect === t && (s.slides.length || (c = !0), requestAnimationFrame((() => {
        c && s.slides && s.slides.length && (i(), c = !1)
      })))
    }))
  }

  function se(e, t) {
    return e.transformEl ? t.find(e.transformEl).css({
      "backface-visibility": "hidden",
      "-webkit-backface-visibility": "hidden"
    }) : t
  }

  function ae(e) {
    let {
      swiper: t,
      duration: s,
      transformEl: a,
      allSlides: i
    } = e;
    const {
      slides: r,
      activeIndex: n,
      $wrapperEl: l
    } = t;
    if (t.params.virtualTranslate && 0 !== s) {
      let e, s = !1;
      e = i ? a ? r.find(a) : r : a ? r.eq(n).find(a) : r.eq(n), e.transitionEnd((() => {
        if (s) return;
        if (!t || t.destroyed) return;
        s = !0, t.animating = !1;
        const e = ["webkitTransitionEnd", "transitionend"];
        for (let t = 0; t < e.length; t += 1) l.trigger(e[t])
      }))
    }
  }

  function ie(e, t, s) {
    const a = "swiper-slide-shadow" + (s ? `-${s}` : ""),
      i = e.transformEl ? t.find(e.transformEl) : t;
    let r = i.children(`.${a}`);
    return r.length || (r = d(`<div class="swiper-slide-shadow${s?`-${s}`:""}"></div>`), i.append(r)), r
  }
  Object.keys(q).forEach((e => {
    Object.keys(q[e]).forEach((t => {
      V.prototype[t] = q[e][t]
    }))
  })), V.use([function (e) {
    let {
      swiper: t,
      on: s,
      emit: a
    } = e;
    const i = r();
    let n = null,
      l = null;
    const o = () => {
        t && !t.destroyed && t.initialized && (a("beforeResize"), a("resize"))
      },
      d = () => {
        t && !t.destroyed && t.initialized && a("orientationchange")
      };
    s("init", (() => {
      t.params.resizeObserver && void 0 !== i.ResizeObserver ? t && !t.destroyed && t.initialized && (n = new ResizeObserver((e => {
        l = i.requestAnimationFrame((() => {
          const {
            width: s,
            height: a
          } = t;
          let i = s,
            r = a;
          e.forEach((e => {
            let {
              contentBoxSize: s,
              contentRect: a,
              target: n
            } = e;
            n && n !== t.el || (i = a ? a.width : (s[0] || s).inlineSize, r = a ? a.height : (s[0] || s).blockSize)
          })), i === s && r === a || o()
        }))
      })), n.observe(t.el)) : (i.addEventListener("resize", o), i.addEventListener("orientationchange", d))
    })), s("destroy", (() => {
      l && i.cancelAnimationFrame(l), n && n.unobserve && t.el && (n.unobserve(t.el), n = null), i.removeEventListener("resize", o), i.removeEventListener("orientationchange", d)
    }))
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      on: a,
      emit: i
    } = e;
    const n = [],
      l = r(),
      o = function (e, t) {
        void 0 === t && (t = {});
        const s = new(l.MutationObserver || l.WebkitMutationObserver)((e => {
          if (1 === e.length) return void i("observerUpdate", e[0]);
          const t = function () {
            i("observerUpdate", e[0])
          };
          l.requestAnimationFrame ? l.requestAnimationFrame(t) : l.setTimeout(t, 0)
        }));
        s.observe(e, {
          attributes: void 0 === t.attributes || t.attributes,
          childList: void 0 === t.childList || t.childList,
          characterData: void 0 === t.characterData || t.characterData
        }), n.push(s)
      };
    s({
      observer: !1,
      observeParents: !1,
      observeSlideChildren: !1
    }), a("init", (() => {
      if (t.params.observer) {
        if (t.params.observeParents) {
          const e = t.$el.parents();
          for (let t = 0; t < e.length; t += 1) o(e[t])
        }
        o(t.$el[0], {
          childList: t.params.observeSlideChildren
        }), o(t.$wrapperEl[0], {
          attributes: !1
        })
      }
    })), a("destroy", (() => {
      n.forEach((e => {
        e.disconnect()
      })), n.splice(0, n.length)
    }))
  }]);
  const re = [function (e) {
    let t, {
      swiper: s,
      extendParams: a,
      on: i,
      emit: r
    } = e;

    function n(e, t) {
      const a = s.params.virtual;
      if (a.cache && s.virtual.cache[t]) return s.virtual.cache[t];
      const i = a.renderSlide ? d(a.renderSlide.call(s, e, t)) : d(`<div class="${s.params.slideClass}" data-swiper-slide-index="${t}">${e}</div>`);
      return i.attr("data-swiper-slide-index") || i.attr("data-swiper-slide-index", t), a.cache && (s.virtual.cache[t] = i), i
    }

    function l(e) {
      const {
        slidesPerView: t,
        slidesPerGroup: a,
        centeredSlides: i
      } = s.params, {
        addSlidesBefore: l,
        addSlidesAfter: o
      } = s.params.virtual, {
        from: d,
        to: c,
        slides: p,
        slidesGrid: u,
        offset: h
      } = s.virtual;
      s.params.cssMode || s.updateActiveIndex();
      const m = s.activeIndex || 0;
      let f, g, v;
      f = s.rtlTranslate ? "right" : s.isHorizontal() ? "left" : "top", i ? (g = Math.floor(t / 2) + a + o, v = Math.floor(t / 2) + a + l) : (g = t + (a - 1) + o, v = a + l);
      const w = Math.max((m || 0) - v, 0),
        b = Math.min((m || 0) + g, p.length - 1),
        x = (s.slidesGrid[w] || 0) - (s.slidesGrid[0] || 0);

      function y() {
        s.updateSlides(), s.updateProgress(), s.updateSlidesClasses(), s.lazy && s.params.lazy.enabled && s.lazy.load(), r("virtualUpdate")
      }
      if (Object.assign(s.virtual, {
          from: w,
          to: b,
          offset: x,
          slidesGrid: s.slidesGrid
        }), d === w && c === b && !e) return s.slidesGrid !== u && x !== h && s.slides.css(f, `${x}px`), s.updateProgress(), void r("virtualUpdate");
      if (s.params.virtual.renderExternal) return s.params.virtual.renderExternal.call(s, {
        offset: x,
        from: w,
        to: b,
        slides: function () {
          const e = [];
          for (let t = w; t <= b; t += 1) e.push(p[t]);
          return e
        }()
      }), void(s.params.virtual.renderExternalUpdate ? y() : r("virtualUpdate"));
      const E = [],
        C = [];
      if (e) s.$wrapperEl.find(`.${s.params.slideClass}`).remove();
      else
        for (let e = d; e <= c; e += 1)(e < w || e > b) && s.$wrapperEl.find(`.${s.params.slideClass}[data-swiper-slide-index="${e}"]`).remove();
      for (let t = 0; t < p.length; t += 1) t >= w && t <= b && (void 0 === c || e ? C.push(t) : (t > c && C.push(t), t < d && E.push(t)));
      C.forEach((e => {
        s.$wrapperEl.append(n(p[e], e))
      })), E.sort(((e, t) => t - e)).forEach((e => {
        s.$wrapperEl.prepend(n(p[e], e))
      })), s.$wrapperEl.children(".swiper-slide").css(f, `${x}px`), y()
    }
    a({
      virtual: {
        enabled: !1,
        slides: [],
        cache: !0,
        renderSlide: null,
        renderExternal: null,
        renderExternalUpdate: !0,
        addSlidesBefore: 0,
        addSlidesAfter: 0
      }
    }), s.virtual = {
      cache: {},
      from: void 0,
      to: void 0,
      slides: [],
      offset: 0,
      slidesGrid: []
    }, i("beforeInit", (() => {
      s.params.virtual.enabled && (s.virtual.slides = s.params.virtual.slides, s.classNames.push(`${s.params.containerModifierClass}virtual`), s.params.watchSlidesProgress = !0, s.originalParams.watchSlidesProgress = !0, s.params.initialSlide || l())
    })), i("setTranslate", (() => {
      s.params.virtual.enabled && (s.params.cssMode && !s._immediateVirtual ? (clearTimeout(t), t = setTimeout((() => {
        l()
      }), 100)) : l())
    })), i("init update resize", (() => {
      s.params.virtual.enabled && s.params.cssMode && v(s.wrapperEl, "--swiper-virtual-size", `${s.virtualSize}px`)
    })), Object.assign(s.virtual, {
      appendSlide: function (e) {
        if ("object" == typeof e && "length" in e)
          for (let t = 0; t < e.length; t += 1) e[t] && s.virtual.slides.push(e[t]);
        else s.virtual.slides.push(e);
        l(!0)
      },
      prependSlide: function (e) {
        const t = s.activeIndex;
        let a = t + 1,
          i = 1;
        if (Array.isArray(e)) {
          for (let t = 0; t < e.length; t += 1) e[t] && s.virtual.slides.unshift(e[t]);
          a = t + e.length, i = e.length
        } else s.virtual.slides.unshift(e);
        if (s.params.virtual.cache) {
          const e = s.virtual.cache,
            t = {};
          Object.keys(e).forEach((s => {
            const a = e[s],
              r = a.attr("data-swiper-slide-index");
            r && a.attr("data-swiper-slide-index", parseInt(r, 10) + i), t[parseInt(s, 10) + i] = a
          })), s.virtual.cache = t
        }
        l(!0), s.slideTo(a, 0)
      },
      removeSlide: function (e) {
        if (null == e) return;
        let t = s.activeIndex;
        if (Array.isArray(e))
          for (let a = e.length - 1; a >= 0; a -= 1) s.virtual.slides.splice(e[a], 1), s.params.virtual.cache && delete s.virtual.cache[e[a]], e[a] < t && (t -= 1), t = Math.max(t, 0);
        else s.virtual.slides.splice(e, 1), s.params.virtual.cache && delete s.virtual.cache[e], e < t && (t -= 1), t = Math.max(t, 0);
        l(!0), s.slideTo(t, 0)
      },
      removeAllSlides: function () {
        s.virtual.slides = [], s.params.virtual.cache && (s.virtual.cache = {}), l(!0), s.slideTo(0, 0)
      },
      update: l
    })
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      on: i,
      emit: n
    } = e;
    const l = a(),
      o = r();

    function c(e) {
      if (!t.enabled) return;
      const {
        rtlTranslate: s
      } = t;
      let a = e;
      a.originalEvent && (a = a.originalEvent);
      const i = a.keyCode || a.charCode,
        r = t.params.keyboard.pageUpDown,
        d = r && 33 === i,
        c = r && 34 === i,
        p = 37 === i,
        u = 39 === i,
        h = 38 === i,
        m = 40 === i;
      if (!t.allowSlideNext && (t.isHorizontal() && u || t.isVertical() && m || c)) return !1;
      if (!t.allowSlidePrev && (t.isHorizontal() && p || t.isVertical() && h || d)) return !1;
      if (!(a.shiftKey || a.altKey || a.ctrlKey || a.metaKey || l.activeElement && l.activeElement.nodeName && ("input" === l.activeElement.nodeName.toLowerCase() || "textarea" === l.activeElement.nodeName.toLowerCase()))) {
        if (t.params.keyboard.onlyInViewport && (d || c || p || u || h || m)) {
          let e = !1;
          if (t.$el.parents(`.${t.params.slideClass}`).length > 0 && 0 === t.$el.parents(`.${t.params.slideActiveClass}`).length) return;
          const a = t.$el,
            i = a[0].clientWidth,
            r = a[0].clientHeight,
            n = o.innerWidth,
            l = o.innerHeight,
            d = t.$el.offset();
          s && (d.left -= t.$el[0].scrollLeft);
          const c = [
            [d.left, d.top],
            [d.left + i, d.top],
            [d.left, d.top + r],
            [d.left + i, d.top + r]
          ];
          for (let t = 0; t < c.length; t += 1) {
            const s = c[t];
            if (s[0] >= 0 && s[0] <= n && s[1] >= 0 && s[1] <= l) {
              if (0 === s[0] && 0 === s[1]) continue;
              e = !0
            }
          }
          if (!e) return
        }
        t.isHorizontal() ? ((d || c || p || u) && (a.preventDefault ? a.preventDefault() : a.returnValue = !1), ((c || u) && !s || (d || p) && s) && t.slideNext(), ((d || p) && !s || (c || u) && s) && t.slidePrev()) : ((d || c || h || m) && (a.preventDefault ? a.preventDefault() : a.returnValue = !1), (c || m) && t.slideNext(), (d || h) && t.slidePrev()), n("keyPress", i)
      }
    }

    function p() {
      t.keyboard.enabled || (d(l).on("keydown", c), t.keyboard.enabled = !0)
    }

    function u() {
      t.keyboard.enabled && (d(l).off("keydown", c), t.keyboard.enabled = !1)
    }
    t.keyboard = {
      enabled: !1
    }, s({
      keyboard: {
        enabled: !1,
        onlyInViewport: !0,
        pageUpDown: !0
      }
    }), i("init", (() => {
      t.params.keyboard.enabled && p()
    })), i("destroy", (() => {
      t.keyboard.enabled && u()
    })), Object.assign(t.keyboard, {
      enable: p,
      disable: u
    })
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      on: a,
      emit: i
    } = e;
    const n = r();
    let l;
    s({
      mousewheel: {
        enabled: !1,
        releaseOnEdges: !1,
        invert: !1,
        forceToAxis: !1,
        sensitivity: 1,
        eventsTarget: "container",
        thresholdDelta: null,
        thresholdTime: null
      }
    }), t.mousewheel = {
      enabled: !1
    };
    let o, c = u();
    const h = [];

    function m() {
      t.enabled && (t.mouseEntered = !0)
    }

    function f() {
      t.enabled && (t.mouseEntered = !1)
    }

    function g(e) {
      return !(t.params.mousewheel.thresholdDelta && e.delta < t.params.mousewheel.thresholdDelta) && (!(t.params.mousewheel.thresholdTime && u() - c < t.params.mousewheel.thresholdTime) && (e.delta >= 6 && u() - c < 60 || (e.direction < 0 ? t.isEnd && !t.params.loop || t.animating || (t.slideNext(), i("scroll", e.raw)) : t.isBeginning && !t.params.loop || t.animating || (t.slidePrev(), i("scroll", e.raw)), c = (new n.Date).getTime(), !1)))
    }

    function v(e) {
      let s = e,
        a = !0;
      if (!t.enabled) return;
      const r = t.params.mousewheel;
      t.params.cssMode && s.preventDefault();
      let n = t.$el;
      if ("container" !== t.params.mousewheel.eventsTarget && (n = d(t.params.mousewheel.eventsTarget)), !t.mouseEntered && !n[0].contains(s.target) && !r.releaseOnEdges) return !0;
      s.originalEvent && (s = s.originalEvent);
      let c = 0;
      const m = t.rtlTranslate ? -1 : 1,
        f = function (e) {
          let t = 0,
            s = 0,
            a = 0,
            i = 0;
          return "detail" in e && (s = e.detail), "wheelDelta" in e && (s = -e.wheelDelta / 120), "wheelDeltaY" in e && (s = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (t = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (t = s, s = 0), a = 10 * t, i = 10 * s, "deltaY" in e && (i = e.deltaY), "deltaX" in e && (a = e.deltaX), e.shiftKey && !a && (a = i, i = 0), (a || i) && e.deltaMode && (1 === e.deltaMode ? (a *= 40, i *= 40) : (a *= 800, i *= 800)), a && !t && (t = a < 1 ? -1 : 1), i && !s && (s = i < 1 ? -1 : 1), {
            spinX: t,
            spinY: s,
            pixelX: a,
            pixelY: i
          }
        }(s);
      if (r.forceToAxis)
        if (t.isHorizontal()) {
          if (!(Math.abs(f.pixelX) > Math.abs(f.pixelY))) return !0;
          c = -f.pixelX * m
        } else {
          if (!(Math.abs(f.pixelY) > Math.abs(f.pixelX))) return !0;
          c = -f.pixelY
        }
      else c = Math.abs(f.pixelX) > Math.abs(f.pixelY) ? -f.pixelX * m : -f.pixelY;
      if (0 === c) return !0;
      r.invert && (c = -c);
      let v = t.getTranslate() + c * r.sensitivity;
      if (v >= t.minTranslate() && (v = t.minTranslate()), v <= t.maxTranslate() && (v = t.maxTranslate()), a = !!t.params.loop || !(v === t.minTranslate() || v === t.maxTranslate()), a && t.params.nested && s.stopPropagation(), t.params.freeMode && t.params.freeMode.enabled) {
        const e = {
            time: u(),
            delta: Math.abs(c),
            direction: Math.sign(c)
          },
          a = o && e.time < o.time + 500 && e.delta <= o.delta && e.direction === o.direction;
        if (!a) {
          o = void 0, t.params.loop && t.loopFix();
          let n = t.getTranslate() + c * r.sensitivity;
          const d = t.isBeginning,
            u = t.isEnd;
          if (n >= t.minTranslate() && (n = t.minTranslate()), n <= t.maxTranslate() && (n = t.maxTranslate()), t.setTransition(0), t.setTranslate(n), t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses(), (!d && t.isBeginning || !u && t.isEnd) && t.updateSlidesClasses(), t.params.freeMode.sticky) {
            clearTimeout(l), l = void 0, h.length >= 15 && h.shift();
            const s = h.length ? h[h.length - 1] : void 0,
              a = h[0];
            if (h.push(e), s && (e.delta > s.delta || e.direction !== s.direction)) h.splice(0);
            else if (h.length >= 15 && e.time - a.time < 500 && a.delta - e.delta >= 1 && e.delta <= 6) {
              const s = c > 0 ? .8 : .2;
              o = e, h.splice(0), l = p((() => {
                t.slideToClosest(t.params.speed, !0, void 0, s)
              }), 0)
            }
            l || (l = p((() => {
              o = e, h.splice(0), t.slideToClosest(t.params.speed, !0, void 0, .5)
            }), 500))
          }
          if (a || i("scroll", s), t.params.autoplay && t.params.autoplayDisableOnInteraction && t.autoplay.stop(), n === t.minTranslate() || n === t.maxTranslate()) return !0
        }
      } else {
        const s = {
          time: u(),
          delta: Math.abs(c),
          direction: Math.sign(c),
          raw: e
        };
        h.length >= 2 && h.shift();
        const a = h.length ? h[h.length - 1] : void 0;
        if (h.push(s), a ? (s.direction !== a.direction || s.delta > a.delta || s.time > a.time + 150) && g(s) : g(s), function (e) {
            const s = t.params.mousewheel;
            if (e.direction < 0) {
              if (t.isEnd && !t.params.loop && s.releaseOnEdges) return !0
            } else if (t.isBeginning && !t.params.loop && s.releaseOnEdges) return !0;
            return !1
          }(s)) return !0
      }
      return s.preventDefault ? s.preventDefault() : s.returnValue = !1, !1
    }

    function w(e) {
      let s = t.$el;
      "container" !== t.params.mousewheel.eventsTarget && (s = d(t.params.mousewheel.eventsTarget)), s[e]("mouseenter", m), s[e]("mouseleave", f), s[e]("wheel", v)
    }

    function b() {
      return t.params.cssMode ? (t.wrapperEl.removeEventListener("wheel", v), !0) : !t.mousewheel.enabled && (w("on"), t.mousewheel.enabled = !0, !0)
    }

    function x() {
      return t.params.cssMode ? (t.wrapperEl.addEventListener(event, v), !0) : !!t.mousewheel.enabled && (w("off"), t.mousewheel.enabled = !1, !0)
    }
    a("init", (() => {
      !t.params.mousewheel.enabled && t.params.cssMode && x(), t.params.mousewheel.enabled && b()
    })), a("destroy", (() => {
      t.params.cssMode && b(), t.mousewheel.enabled && x()
    })), Object.assign(t.mousewheel, {
      enable: b,
      disable: x
    })
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      on: a,
      emit: i
    } = e;

    function r(e) {
      let s;
      return e && (s = d(e), t.params.uniqueNavElements && "string" == typeof e && s.length > 1 && 1 === t.$el.find(e).length && (s = t.$el.find(e))), s
    }

    function n(e, s) {
      const a = t.params.navigation;
      e && e.length > 0 && (e[s ? "addClass" : "removeClass"](a.disabledClass), e[0] && "BUTTON" === e[0].tagName && (e[0].disabled = s), t.params.watchOverflow && t.enabled && e[t.isLocked ? "addClass" : "removeClass"](a.lockClass))
    }

    function l() {
      if (t.params.loop) return;
      const {
        $nextEl: e,
        $prevEl: s
      } = t.navigation;
      n(s, t.isBeginning && !t.params.rewind), n(e, t.isEnd && !t.params.rewind)
    }

    function o(e) {
      e.preventDefault(), (!t.isBeginning || t.params.loop || t.params.rewind) && (t.slidePrev(), i("navigationPrev"))
    }

    function c(e) {
      e.preventDefault(), (!t.isEnd || t.params.loop || t.params.rewind) && (t.slideNext(), i("navigationNext"))
    }

    function p() {
      const e = t.params.navigation;
      if (t.params.navigation = F(t, t.originalParams.navigation, t.params.navigation, {
          nextEl: "swiper-button-next",
          prevEl: "swiper-button-prev"
        }), !e.nextEl && !e.prevEl) return;
      const s = r(e.nextEl),
        a = r(e.prevEl);
      s && s.length > 0 && s.on("click", c), a && a.length > 0 && a.on("click", o), Object.assign(t.navigation, {
        $nextEl: s,
        nextEl: s && s[0],
        $prevEl: a,
        prevEl: a && a[0]
      }), t.enabled || (s && s.addClass(e.lockClass), a && a.addClass(e.lockClass))
    }

    function u() {
      const {
        $nextEl: e,
        $prevEl: s
      } = t.navigation;
      e && e.length && (e.off("click", c), e.removeClass(t.params.navigation.disabledClass)), s && s.length && (s.off("click", o), s.removeClass(t.params.navigation.disabledClass))
    }
    s({
      navigation: {
        nextEl: null,
        prevEl: null,
        hideOnClick: !1,
        disabledClass: "swiper-button-disabled",
        hiddenClass: "swiper-button-hidden",
        lockClass: "swiper-button-lock",
        navigationDisabledClass: "swiper-navigation-disabled"
      }
    }), t.navigation = {
      nextEl: null,
      $nextEl: null,
      prevEl: null,
      $prevEl: null
    }, a("init", (() => {
      !1 === t.params.navigation.enabled ? h() : (p(), l())
    })), a("toEdge fromEdge lock unlock", (() => {
      l()
    })), a("destroy", (() => {
      u()
    })), a("enable disable", (() => {
      const {
        $nextEl: e,
        $prevEl: s
      } = t.navigation;
      e && e[t.enabled ? "removeClass" : "addClass"](t.params.navigation.lockClass), s && s[t.enabled ? "removeClass" : "addClass"](t.params.navigation.lockClass)
    })), a("click", ((e, s) => {
      const {
        $nextEl: a,
        $prevEl: r
      } = t.navigation, n = s.target;
      if (t.params.navigation.hideOnClick && !d(n).is(r) && !d(n).is(a)) {
        if (t.pagination && t.params.pagination && t.params.pagination.clickable && (t.pagination.el === n || t.pagination.el.contains(n))) return;
        let e;
        a ? e = a.hasClass(t.params.navigation.hiddenClass) : r && (e = r.hasClass(t.params.navigation.hiddenClass)), i(!0 === e ? "navigationShow" : "navigationHide"), a && a.toggleClass(t.params.navigation.hiddenClass), r && r.toggleClass(t.params.navigation.hiddenClass)
      }
    }));
    const h = () => {
      t.$el.addClass(t.params.navigation.navigationDisabledClass), u()
    };
    Object.assign(t.navigation, {
      enable: () => {
        t.$el.removeClass(t.params.navigation.navigationDisabledClass), p(), l()
      },
      disable: h,
      update: l,
      init: p,
      destroy: u
    })
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      on: a,
      emit: i
    } = e;
    const r = "swiper-pagination";
    let n;
    s({
      pagination: {
        el: null,
        bulletElement: "span",
        clickable: !1,
        hideOnClick: !1,
        renderBullet: null,
        renderProgressbar: null,
        renderFraction: null,
        renderCustom: null,
        progressbarOpposite: !1,
        type: "bullets",
        dynamicBullets: !1,
        dynamicMainBullets: 1,
        formatFractionCurrent: e => e,
        formatFractionTotal: e => e,
        bulletClass: `${r}-bullet`,
        bulletActiveClass: `${r}-bullet-active`,
        modifierClass: `${r}-`,
        currentClass: `${r}-current`,
        totalClass: `${r}-total`,
        hiddenClass: `${r}-hidden`,
        progressbarFillClass: `${r}-progressbar-fill`,
        progressbarOppositeClass: `${r}-progressbar-opposite`,
        clickableClass: `${r}-clickable`,
        lockClass: `${r}-lock`,
        horizontalClass: `${r}-horizontal`,
        verticalClass: `${r}-vertical`,
        paginationDisabledClass: `${r}-disabled`
      }
    }), t.pagination = {
      el: null,
      $el: null,
      bullets: []
    };
    let l = 0;

    function o() {
      return !t.params.pagination.el || !t.pagination.el || !t.pagination.$el || 0 === t.pagination.$el.length
    }

    function c(e, s) {
      const {
        bulletActiveClass: a
      } = t.params.pagination;
      e[s]().addClass(`${a}-${s}`)[s]().addClass(`${a}-${s}-${s}`)
    }

    function p() {
      const e = t.rtl,
        s = t.params.pagination;
      if (o()) return;
      const a = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.slides.length,
        r = t.pagination.$el;
      let p;
      const u = t.params.loop ? Math.ceil((a - 2 * t.loopedSlides) / t.params.slidesPerGroup) : t.snapGrid.length;
      if (t.params.loop ? (p = Math.ceil((t.activeIndex - t.loopedSlides) / t.params.slidesPerGroup), p > a - 1 - 2 * t.loopedSlides && (p -= a - 2 * t.loopedSlides), p > u - 1 && (p -= u), p < 0 && "bullets" !== t.params.paginationType && (p = u + p)) : p = void 0 !== t.snapIndex ? t.snapIndex : t.activeIndex || 0, "bullets" === s.type && t.pagination.bullets && t.pagination.bullets.length > 0) {
        const a = t.pagination.bullets;
        let i, o, u;
        if (s.dynamicBullets && (n = a.eq(0)[t.isHorizontal() ? "outerWidth" : "outerHeight"](!0), r.css(t.isHorizontal() ? "width" : "height", n * (s.dynamicMainBullets + 4) + "px"), s.dynamicMainBullets > 1 && void 0 !== t.previousIndex && (l += p - (t.previousIndex - t.loopedSlides || 0), l > s.dynamicMainBullets - 1 ? l = s.dynamicMainBullets - 1 : l < 0 && (l = 0)), i = Math.max(p - l, 0), o = i + (Math.min(a.length, s.dynamicMainBullets) - 1), u = (o + i) / 2), a.removeClass(["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map((e => `${s.bulletActiveClass}${e}`)).join(" ")), r.length > 1) a.each((e => {
          const t = d(e),
            a = t.index();
          a === p && t.addClass(s.bulletActiveClass), s.dynamicBullets && (a >= i && a <= o && t.addClass(`${s.bulletActiveClass}-main`), a === i && c(t, "prev"), a === o && c(t, "next"))
        }));
        else {
          const e = a.eq(p),
            r = e.index();
          if (e.addClass(s.bulletActiveClass), s.dynamicBullets) {
            const e = a.eq(i),
              n = a.eq(o);
            for (let e = i; e <= o; e += 1) a.eq(e).addClass(`${s.bulletActiveClass}-main`);
            if (t.params.loop)
              if (r >= a.length) {
                for (let e = s.dynamicMainBullets; e >= 0; e -= 1) a.eq(a.length - e).addClass(`${s.bulletActiveClass}-main`);
                a.eq(a.length - s.dynamicMainBullets - 1).addClass(`${s.bulletActiveClass}-prev`)
              } else c(e, "prev"), c(n, "next");
            else c(e, "prev"), c(n, "next")
          }
        }
        if (s.dynamicBullets) {
          const i = Math.min(a.length, s.dynamicMainBullets + 4),
            r = (n * i - n) / 2 - u * n,
            l = e ? "right" : "left";
          a.css(t.isHorizontal() ? l : "top", `${r}px`)
        }
      }
      if ("fraction" === s.type && (r.find(U(s.currentClass)).text(s.formatFractionCurrent(p + 1)), r.find(U(s.totalClass)).text(s.formatFractionTotal(u))), "progressbar" === s.type) {
        let e;
        e = s.progressbarOpposite ? t.isHorizontal() ? "vertical" : "horizontal" : t.isHorizontal() ? "horizontal" : "vertical";
        const a = (p + 1) / u;
        let i = 1,
          n = 1;
        "horizontal" === e ? i = a : n = a, r.find(U(s.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${i}) scaleY(${n})`).transition(t.params.speed)
      }
      "custom" === s.type && s.renderCustom ? (r.html(s.renderCustom(t, p + 1, u)), i("paginationRender", r[0])) : i("paginationUpdate", r[0]), t.params.watchOverflow && t.enabled && r[t.isLocked ? "addClass" : "removeClass"](s.lockClass)
    }

    function u() {
      const e = t.params.pagination;
      if (o()) return;
      const s = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.slides.length,
        a = t.pagination.$el;
      let r = "";
      if ("bullets" === e.type) {
        let i = t.params.loop ? Math.ceil((s - 2 * t.loopedSlides) / t.params.slidesPerGroup) : t.snapGrid.length;
        t.params.freeMode && t.params.freeMode.enabled && !t.params.loop && i > s && (i = s);
        for (let s = 0; s < i; s += 1) e.renderBullet ? r += e.renderBullet.call(t, s, e.bulletClass) : r += `<${e.bulletElement} class="${e.bulletClass}"></${e.bulletElement}>`;
        a.html(r), t.pagination.bullets = a.find(U(e.bulletClass))
      }
      "fraction" === e.type && (r = e.renderFraction ? e.renderFraction.call(t, e.currentClass, e.totalClass) : `<span class="${e.currentClass}"></span> / <span class="${e.totalClass}"></span>`, a.html(r)), "progressbar" === e.type && (r = e.renderProgressbar ? e.renderProgressbar.call(t, e.progressbarFillClass) : `<span class="${e.progressbarFillClass}"></span>`, a.html(r)), "custom" !== e.type && i("paginationRender", t.pagination.$el[0])
    }

    function h() {
      t.params.pagination = F(t, t.originalParams.pagination, t.params.pagination, {
        el: "swiper-pagination"
      });
      const e = t.params.pagination;
      if (!e.el) return;
      let s = d(e.el);
      0 !== s.length && (t.params.uniqueNavElements && "string" == typeof e.el && s.length > 1 && (s = t.$el.find(e.el), s.length > 1 && (s = s.filter((e => d(e).parents(".swiper")[0] === t.el)))), "bullets" === e.type && e.clickable && s.addClass(e.clickableClass), s.addClass(e.modifierClass + e.type), s.addClass(t.isHorizontal() ? e.horizontalClass : e.verticalClass), "bullets" === e.type && e.dynamicBullets && (s.addClass(`${e.modifierClass}${e.type}-dynamic`), l = 0, e.dynamicMainBullets < 1 && (e.dynamicMainBullets = 1)), "progressbar" === e.type && e.progressbarOpposite && s.addClass(e.progressbarOppositeClass), e.clickable && s.on("click", U(e.bulletClass), (function (e) {
        e.preventDefault();
        let s = d(this).index() * t.params.slidesPerGroup;
        t.params.loop && (s += t.loopedSlides), t.slideTo(s)
      })), Object.assign(t.pagination, {
        $el: s,
        el: s[0]
      }), t.enabled || s.addClass(e.lockClass))
    }

    function m() {
      const e = t.params.pagination;
      if (o()) return;
      const s = t.pagination.$el;
      s.removeClass(e.hiddenClass), s.removeClass(e.modifierClass + e.type), s.removeClass(t.isHorizontal() ? e.horizontalClass : e.verticalClass), t.pagination.bullets && t.pagination.bullets.removeClass && t.pagination.bullets.removeClass(e.bulletActiveClass), e.clickable && s.off("click", U(e.bulletClass))
    }
    a("init", (() => {
      !1 === t.params.pagination.enabled ? f() : (h(), u(), p())
    })), a("activeIndexChange", (() => {
      (t.params.loop || void 0 === t.snapIndex) && p()
    })), a("snapIndexChange", (() => {
      t.params.loop || p()
    })), a("slidesLengthChange", (() => {
      t.params.loop && (u(), p())
    })), a("snapGridLengthChange", (() => {
      t.params.loop || (u(), p())
    })), a("destroy", (() => {
      m()
    })), a("enable disable", (() => {
      const {
        $el: e
      } = t.pagination;
      e && e[t.enabled ? "removeClass" : "addClass"](t.params.pagination.lockClass)
    })), a("lock unlock", (() => {
      p()
    })), a("click", ((e, s) => {
      const a = s.target,
        {
          $el: r
        } = t.pagination;
      if (t.params.pagination.el && t.params.pagination.hideOnClick && r && r.length > 0 && !d(a).hasClass(t.params.pagination.bulletClass)) {
        if (t.navigation && (t.navigation.nextEl && a === t.navigation.nextEl || t.navigation.prevEl && a === t.navigation.prevEl)) return;
        const e = r.hasClass(t.params.pagination.hiddenClass);
        i(!0 === e ? "paginationShow" : "paginationHide"), r.toggleClass(t.params.pagination.hiddenClass)
      }
    }));
    const f = () => {
      t.$el.addClass(t.params.pagination.paginationDisabledClass), t.pagination.$el && t.pagination.$el.addClass(t.params.pagination.paginationDisabledClass), m()
    };
    Object.assign(t.pagination, {
      enable: () => {
        t.$el.removeClass(t.params.pagination.paginationDisabledClass), t.pagination.$el && t.pagination.$el.removeClass(t.params.pagination.paginationDisabledClass), h(), u(), p()
      },
      disable: f,
      render: u,
      update: p,
      init: h,
      destroy: m
    })
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      on: i,
      emit: r
    } = e;
    const n = a();
    let l, o, c, u, h = !1,
      m = null,
      f = null;

    function g() {
      if (!t.params.scrollbar.el || !t.scrollbar.el) return;
      const {
        scrollbar: e,
        rtlTranslate: s,
        progress: a
      } = t, {
        $dragEl: i,
        $el: r
      } = e, n = t.params.scrollbar;
      let l = o,
        d = (c - o) * a;
      s ? (d = -d, d > 0 ? (l = o - d, d = 0) : -d + o > c && (l = c + d)) : d < 0 ? (l = o + d, d = 0) : d + o > c && (l = c - d), t.isHorizontal() ? (i.transform(`translate3d(${d}px, 0, 0)`), i[0].style.width = `${l}px`) : (i.transform(`translate3d(0px, ${d}px, 0)`), i[0].style.height = `${l}px`), n.hide && (clearTimeout(m), r[0].style.opacity = 1, m = setTimeout((() => {
        r[0].style.opacity = 0, r.transition(400)
      }), 1e3))
    }

    function v() {
      if (!t.params.scrollbar.el || !t.scrollbar.el) return;
      const {
        scrollbar: e
      } = t, {
        $dragEl: s,
        $el: a
      } = e;
      s[0].style.width = "", s[0].style.height = "", c = t.isHorizontal() ? a[0].offsetWidth : a[0].offsetHeight, u = t.size / (t.virtualSize + t.params.slidesOffsetBefore - (t.params.centeredSlides ? t.snapGrid[0] : 0)), o = "auto" === t.params.scrollbar.dragSize ? c * u : parseInt(t.params.scrollbar.dragSize, 10), t.isHorizontal() ? s[0].style.width = `${o}px` : s[0].style.height = `${o}px`, a[0].style.display = u >= 1 ? "none" : "", t.params.scrollbar.hide && (a[0].style.opacity = 0), t.params.watchOverflow && t.enabled && e.$el[t.isLocked ? "addClass" : "removeClass"](t.params.scrollbar.lockClass)
    }

    function w(e) {
      return t.isHorizontal() ? "touchstart" === e.type || "touchmove" === e.type ? e.targetTouches[0].clientX : e.clientX : "touchstart" === e.type || "touchmove" === e.type ? e.targetTouches[0].clientY : e.clientY
    }

    function b(e) {
      const {
        scrollbar: s,
        rtlTranslate: a
      } = t, {
        $el: i
      } = s;
      let r;
      r = (w(e) - i.offset()[t.isHorizontal() ? "left" : "top"] - (null !== l ? l : o / 2)) / (c - o), r = Math.max(Math.min(r, 1), 0), a && (r = 1 - r);
      const n = t.minTranslate() + (t.maxTranslate() - t.minTranslate()) * r;
      t.updateProgress(n), t.setTranslate(n), t.updateActiveIndex(), t.updateSlidesClasses()
    }

    function x(e) {
      const s = t.params.scrollbar,
        {
          scrollbar: a,
          $wrapperEl: i
        } = t,
        {
          $el: n,
          $dragEl: o
        } = a;
      h = !0, l = e.target === o[0] || e.target === o ? w(e) - e.target.getBoundingClientRect()[t.isHorizontal() ? "left" : "top"] : null, e.preventDefault(), e.stopPropagation(), i.transition(100), o.transition(100), b(e), clearTimeout(f), n.transition(0), s.hide && n.css("opacity", 1), t.params.cssMode && t.$wrapperEl.css("scroll-snap-type", "none"), r("scrollbarDragStart", e)
    }

    function y(e) {
      const {
        scrollbar: s,
        $wrapperEl: a
      } = t, {
        $el: i,
        $dragEl: n
      } = s;
      h && (e.preventDefault ? e.preventDefault() : e.returnValue = !1, b(e), a.transition(0), i.transition(0), n.transition(0), r("scrollbarDragMove", e))
    }

    function E(e) {
      const s = t.params.scrollbar,
        {
          scrollbar: a,
          $wrapperEl: i
        } = t,
        {
          $el: n
        } = a;
      h && (h = !1, t.params.cssMode && (t.$wrapperEl.css("scroll-snap-type", ""), i.transition("")), s.hide && (clearTimeout(f), f = p((() => {
        n.css("opacity", 0), n.transition(400)
      }), 1e3)), r("scrollbarDragEnd", e), s.snapOnRelease && t.slideToClosest())
    }

    function C(e) {
      const {
        scrollbar: s,
        touchEventsTouch: a,
        touchEventsDesktop: i,
        params: r,
        support: l
      } = t, o = s.$el;
      if (!o) return;
      const d = o[0],
        c = !(!l.passiveListener || !r.passiveListeners) && {
          passive: !1,
          capture: !1
        },
        p = !(!l.passiveListener || !r.passiveListeners) && {
          passive: !0,
          capture: !1
        };
      if (!d) return;
      const u = "on" === e ? "addEventListener" : "removeEventListener";
      l.touch ? (d[u](a.start, x, c), d[u](a.move, y, c), d[u](a.end, E, p)) : (d[u](i.start, x, c), n[u](i.move, y, c), n[u](i.end, E, p))
    }

    function T() {
      const {
        scrollbar: e,
        $el: s
      } = t;
      t.params.scrollbar = F(t, t.originalParams.scrollbar, t.params.scrollbar, {
        el: "swiper-scrollbar"
      });
      const a = t.params.scrollbar;
      if (!a.el) return;
      let i = d(a.el);
      t.params.uniqueNavElements && "string" == typeof a.el && i.length > 1 && 1 === s.find(a.el).length && (i = s.find(a.el)), i.addClass(t.isHorizontal() ? a.horizontalClass : a.verticalClass);
      let r = i.find(`.${t.params.scrollbar.dragClass}`);
      0 === r.length && (r = d(`<div class="${t.params.scrollbar.dragClass}"></div>`), i.append(r)), Object.assign(e, {
        $el: i,
        el: i[0],
        $dragEl: r,
        dragEl: r[0]
      }), a.draggable && t.params.scrollbar.el && t.scrollbar.el && C("on"), i && i[t.enabled ? "removeClass" : "addClass"](t.params.scrollbar.lockClass)
    }

    function $() {
      const e = t.params.scrollbar,
        s = t.scrollbar.$el;
      s && s.removeClass(t.isHorizontal() ? e.horizontalClass : e.verticalClass), t.params.scrollbar.el && t.scrollbar.el && C("off")
    }
    s({
      scrollbar: {
        el: null,
        dragSize: "auto",
        hide: !1,
        draggable: !1,
        snapOnRelease: !0,
        lockClass: "swiper-scrollbar-lock",
        dragClass: "swiper-scrollbar-drag",
        scrollbarDisabledClass: "swiper-scrollbar-disabled",
        horizontalClass: "swiper-scrollbar-horizontal",
        verticalClass: "swiper-scrollbar-vertical"
      }
    }), t.scrollbar = {
      el: null,
      dragEl: null,
      $el: null,
      $dragEl: null
    }, i("init", (() => {
      !1 === t.params.scrollbar.enabled ? S() : (T(), v(), g())
    })), i("update resize observerUpdate lock unlock", (() => {
      v()
    })), i("setTranslate", (() => {
      g()
    })), i("setTransition", ((e, s) => {
      ! function (e) {
        t.params.scrollbar.el && t.scrollbar.el && t.scrollbar.$dragEl.transition(e)
      }(s)
    })), i("enable disable", (() => {
      const {
        $el: e
      } = t.scrollbar;
      e && e[t.enabled ? "removeClass" : "addClass"](t.params.scrollbar.lockClass)
    })), i("destroy", (() => {
      $()
    }));
    const S = () => {
      t.$el.addClass(t.params.scrollbar.scrollbarDisabledClass), t.scrollbar.$el && t.scrollbar.$el.addClass(t.params.scrollbar.scrollbarDisabledClass), $()
    };
    Object.assign(t.scrollbar, {
      enable: () => {
        t.$el.removeClass(t.params.scrollbar.scrollbarDisabledClass), t.scrollbar.$el && t.scrollbar.$el.removeClass(t.params.scrollbar.scrollbarDisabledClass), T(), v(), g()
      },
      disable: S,
      updateSize: v,
      setTranslate: g,
      init: T,
      destroy: $
    })
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      on: a
    } = e;
    s({
      parallax: {
        enabled: !1
      }
    });
    const i = (e, s) => {
        const {
          rtl: a
        } = t, i = d(e), r = a ? -1 : 1, n = i.attr("data-swiper-parallax") || "0";
        let l = i.attr("data-swiper-parallax-x"),
          o = i.attr("data-swiper-parallax-y");
        const c = i.attr("data-swiper-parallax-scale"),
          p = i.attr("data-swiper-parallax-opacity");
        if (l || o ? (l = l || "0", o = o || "0") : t.isHorizontal() ? (l = n, o = "0") : (o = n, l = "0"), l = l.indexOf("%") >= 0 ? parseInt(l, 10) * s * r + "%" : l * s * r + "px", o = o.indexOf("%") >= 0 ? parseInt(o, 10) * s + "%" : o * s + "px", null != p) {
          const e = p - (p - 1) * (1 - Math.abs(s));
          i[0].style.opacity = e
        }
        if (null == c) i.transform(`translate3d(${l}, ${o}, 0px)`);
        else {
          const e = c - (c - 1) * (1 - Math.abs(s));
          i.transform(`translate3d(${l}, ${o}, 0px) scale(${e})`)
        }
      },
      r = () => {
        const {
          $el: e,
          slides: s,
          progress: a,
          snapGrid: r
        } = t;
        e.children("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((e => {
          i(e, a)
        })), s.each(((e, s) => {
          let n = e.progress;
          t.params.slidesPerGroup > 1 && "auto" !== t.params.slidesPerView && (n += Math.ceil(s / 2) - a * (r.length - 1)), n = Math.min(Math.max(n, -1), 1), d(e).find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((e => {
            i(e, n)
          }))
        }))
      };
    a("beforeInit", (() => {
      t.params.parallax.enabled && (t.params.watchSlidesProgress = !0, t.originalParams.watchSlidesProgress = !0)
    })), a("init", (() => {
      t.params.parallax.enabled && r()
    })), a("setTranslate", (() => {
      t.params.parallax.enabled && r()
    })), a("setTransition", ((e, s) => {
      t.params.parallax.enabled && function (e) {
        void 0 === e && (e = t.params.speed);
        const {
          $el: s
        } = t;
        s.find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((t => {
          const s = d(t);
          let a = parseInt(s.attr("data-swiper-parallax-duration"), 10) || e;
          0 === e && (a = 0), s.transition(a)
        }))
      }(s)
    }))
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      on: a,
      emit: i
    } = e;
    const n = r();
    s({
      zoom: {
        enabled: !1,
        maxRatio: 3,
        minRatio: 1,
        toggle: !0,
        containerClass: "swiper-zoom-container",
        zoomedSlideClass: "swiper-slide-zoomed"
      }
    }), t.zoom = {
      enabled: !1
    };
    let l, o, c, p = 1,
      u = !1;
    const m = {
        $slideEl: void 0,
        slideWidth: void 0,
        slideHeight: void 0,
        $imageEl: void 0,
        $imageWrapEl: void 0,
        maxRatio: 3
      },
      f = {
        isTouched: void 0,
        isMoved: void 0,
        currentX: void 0,
        currentY: void 0,
        minX: void 0,
        minY: void 0,
        maxX: void 0,
        maxY: void 0,
        width: void 0,
        height: void 0,
        startX: void 0,
        startY: void 0,
        touchesStart: {},
        touchesCurrent: {}
      },
      g = {
        x: void 0,
        y: void 0,
        prevPositionX: void 0,
        prevPositionY: void 0,
        prevTime: void 0
      };
    let v = 1;

    function w(e) {
      if (e.targetTouches.length < 2) return 1;
      const t = e.targetTouches[0].pageX,
        s = e.targetTouches[0].pageY,
        a = e.targetTouches[1].pageX,
        i = e.targetTouches[1].pageY;
      return Math.sqrt((a - t) ** 2 + (i - s) ** 2)
    }

    function b(e) {
      const s = t.support,
        a = t.params.zoom;
      if (o = !1, c = !1, !s.gestures) {
        if ("touchstart" !== e.type || "touchstart" === e.type && e.targetTouches.length < 2) return;
        o = !0, m.scaleStart = w(e)
      }
      m.$slideEl && m.$slideEl.length || (m.$slideEl = d(e.target).closest(`.${t.params.slideClass}`), 0 === m.$slideEl.length && (m.$slideEl = t.slides.eq(t.activeIndex)), m.$imageEl = m.$slideEl.find(`.${a.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0), m.$imageWrapEl = m.$imageEl.parent(`.${a.containerClass}`), m.maxRatio = m.$imageWrapEl.attr("data-swiper-zoom") || a.maxRatio, 0 !== m.$imageWrapEl.length) ? (m.$imageEl && m.$imageEl.transition(0), u = !0) : m.$imageEl = void 0
    }

    function x(e) {
      const s = t.support,
        a = t.params.zoom,
        i = t.zoom;
      if (!s.gestures) {
        if ("touchmove" !== e.type || "touchmove" === e.type && e.targetTouches.length < 2) return;
        c = !0, m.scaleMove = w(e)
      }
      m.$imageEl && 0 !== m.$imageEl.length ? (s.gestures ? i.scale = e.scale * p : i.scale = m.scaleMove / m.scaleStart * p, i.scale > m.maxRatio && (i.scale = m.maxRatio - 1 + (i.scale - m.maxRatio + 1) ** .5), i.scale < a.minRatio && (i.scale = a.minRatio + 1 - (a.minRatio - i.scale + 1) ** .5), m.$imageEl.transform(`translate3d(0,0,0) scale(${i.scale})`)) : "gesturechange" === e.type && b(e)
    }

    function y(e) {
      const s = t.device,
        a = t.support,
        i = t.params.zoom,
        r = t.zoom;
      if (!a.gestures) {
        if (!o || !c) return;
        if ("touchend" !== e.type || "touchend" === e.type && e.changedTouches.length < 2 && !s.android) return;
        o = !1, c = !1
      }
      m.$imageEl && 0 !== m.$imageEl.length && (r.scale = Math.max(Math.min(r.scale, m.maxRatio), i.minRatio), m.$imageEl.transition(t.params.speed).transform(`translate3d(0,0,0) scale(${r.scale})`), p = r.scale, u = !1, 1 === r.scale && (m.$slideEl = void 0))
    }

    function E(e) {
      const s = t.zoom;
      if (!m.$imageEl || 0 === m.$imageEl.length) return;
      if (t.allowClick = !1, !f.isTouched || !m.$slideEl) return;
      f.isMoved || (f.width = m.$imageEl[0].offsetWidth, f.height = m.$imageEl[0].offsetHeight, f.startX = h(m.$imageWrapEl[0], "x") || 0, f.startY = h(m.$imageWrapEl[0], "y") || 0, m.slideWidth = m.$slideEl[0].offsetWidth, m.slideHeight = m.$slideEl[0].offsetHeight, m.$imageWrapEl.transition(0));
      const a = f.width * s.scale,
        i = f.height * s.scale;
      if (!(a < m.slideWidth && i < m.slideHeight)) {
        if (f.minX = Math.min(m.slideWidth / 2 - a / 2, 0), f.maxX = -f.minX, f.minY = Math.min(m.slideHeight / 2 - i / 2, 0), f.maxY = -f.minY, f.touchesCurrent.x = "touchmove" === e.type ? e.targetTouches[0].pageX : e.pageX, f.touchesCurrent.y = "touchmove" === e.type ? e.targetTouches[0].pageY : e.pageY, !f.isMoved && !u) {
          if (t.isHorizontal() && (Math.floor(f.minX) === Math.floor(f.startX) && f.touchesCurrent.x < f.touchesStart.x || Math.floor(f.maxX) === Math.floor(f.startX) && f.touchesCurrent.x > f.touchesStart.x)) return void(f.isTouched = !1);
          if (!t.isHorizontal() && (Math.floor(f.minY) === Math.floor(f.startY) && f.touchesCurrent.y < f.touchesStart.y || Math.floor(f.maxY) === Math.floor(f.startY) && f.touchesCurrent.y > f.touchesStart.y)) return void(f.isTouched = !1)
        }
        e.cancelable && e.preventDefault(), e.stopPropagation(), f.isMoved = !0, f.currentX = f.touchesCurrent.x - f.touchesStart.x + f.startX, f.currentY = f.touchesCurrent.y - f.touchesStart.y + f.startY, f.currentX < f.minX && (f.currentX = f.minX + 1 - (f.minX - f.currentX + 1) ** .8), f.currentX > f.maxX && (f.currentX = f.maxX - 1 + (f.currentX - f.maxX + 1) ** .8), f.currentY < f.minY && (f.currentY = f.minY + 1 - (f.minY - f.currentY + 1) ** .8), f.currentY > f.maxY && (f.currentY = f.maxY - 1 + (f.currentY - f.maxY + 1) ** .8), g.prevPositionX || (g.prevPositionX = f.touchesCurrent.x), g.prevPositionY || (g.prevPositionY = f.touchesCurrent.y), g.prevTime || (g.prevTime = Date.now()), g.x = (f.touchesCurrent.x - g.prevPositionX) / (Date.now() - g.prevTime) / 2, g.y = (f.touchesCurrent.y - g.prevPositionY) / (Date.now() - g.prevTime) / 2, Math.abs(f.touchesCurrent.x - g.prevPositionX) < 2 && (g.x = 0), Math.abs(f.touchesCurrent.y - g.prevPositionY) < 2 && (g.y = 0), g.prevPositionX = f.touchesCurrent.x, g.prevPositionY = f.touchesCurrent.y, g.prevTime = Date.now(), m.$imageWrapEl.transform(`translate3d(${f.currentX}px, ${f.currentY}px,0)`)
      }
    }

    function C() {
      const e = t.zoom;
      m.$slideEl && t.previousIndex !== t.activeIndex && (m.$imageEl && m.$imageEl.transform("translate3d(0,0,0) scale(1)"), m.$imageWrapEl && m.$imageWrapEl.transform("translate3d(0,0,0)"), e.scale = 1, p = 1, m.$slideEl = void 0, m.$imageEl = void 0, m.$imageWrapEl = void 0)
    }

    function T(e) {
      const s = t.zoom,
        a = t.params.zoom;
      if (m.$slideEl || (e && e.target && (m.$slideEl = d(e.target).closest(`.${t.params.slideClass}`)), m.$slideEl || (t.params.virtual && t.params.virtual.enabled && t.virtual ? m.$slideEl = t.$wrapperEl.children(`.${t.params.slideActiveClass}`) : m.$slideEl = t.slides.eq(t.activeIndex)), m.$imageEl = m.$slideEl.find(`.${a.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0), m.$imageWrapEl = m.$imageEl.parent(`.${a.containerClass}`)), !m.$imageEl || 0 === m.$imageEl.length || !m.$imageWrapEl || 0 === m.$imageWrapEl.length) return;
      let i, r, l, o, c, u, h, g, v, w, b, x, y, E, C, T, $, S;
      t.params.cssMode && (t.wrapperEl.style.overflow = "hidden", t.wrapperEl.style.touchAction = "none"), m.$slideEl.addClass(`${a.zoomedSlideClass}`), void 0 === f.touchesStart.x && e ? (i = "touchend" === e.type ? e.changedTouches[0].pageX : e.pageX, r = "touchend" === e.type ? e.changedTouches[0].pageY : e.pageY) : (i = f.touchesStart.x, r = f.touchesStart.y), s.scale = m.$imageWrapEl.attr("data-swiper-zoom") || a.maxRatio, p = m.$imageWrapEl.attr("data-swiper-zoom") || a.maxRatio, e ? ($ = m.$slideEl[0].offsetWidth, S = m.$slideEl[0].offsetHeight, l = m.$slideEl.offset().left + n.scrollX, o = m.$slideEl.offset().top + n.scrollY, c = l + $ / 2 - i, u = o + S / 2 - r, v = m.$imageEl[0].offsetWidth, w = m.$imageEl[0].offsetHeight, b = v * s.scale, x = w * s.scale, y = Math.min($ / 2 - b / 2, 0), E = Math.min(S / 2 - x / 2, 0), C = -y, T = -E, h = c * s.scale, g = u * s.scale, h < y && (h = y), h > C && (h = C), g < E && (g = E), g > T && (g = T)) : (h = 0, g = 0), m.$imageWrapEl.transition(300).transform(`translate3d(${h}px, ${g}px,0)`), m.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${s.scale})`)
    }

    function $() {
      const e = t.zoom,
        s = t.params.zoom;
      m.$slideEl || (t.params.virtual && t.params.virtual.enabled && t.virtual ? m.$slideEl = t.$wrapperEl.children(`.${t.params.slideActiveClass}`) : m.$slideEl = t.slides.eq(t.activeIndex), m.$imageEl = m.$slideEl.find(`.${s.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0), m.$imageWrapEl = m.$imageEl.parent(`.${s.containerClass}`)), m.$imageEl && 0 !== m.$imageEl.length && m.$imageWrapEl && 0 !== m.$imageWrapEl.length && (t.params.cssMode && (t.wrapperEl.style.overflow = "", t.wrapperEl.style.touchAction = ""), e.scale = 1, p = 1, m.$imageWrapEl.transition(300).transform("translate3d(0,0,0)"), m.$imageEl.transition(300).transform("translate3d(0,0,0) scale(1)"), m.$slideEl.removeClass(`${s.zoomedSlideClass}`), m.$slideEl = void 0)
    }

    function S(e) {
      const s = t.zoom;
      s.scale && 1 !== s.scale ? $() : T(e)
    }

    function M() {
      const e = t.support;
      return {
        passiveListener: !("touchstart" !== t.touchEvents.start || !e.passiveListener || !t.params.passiveListeners) && {
          passive: !0,
          capture: !1
        },
        activeListenerWithCapture: !e.passiveListener || {
          passive: !1,
          capture: !0
        }
      }
    }

    function P() {
      return `.${t.params.slideClass}`
    }

    function k(e) {
      const {
        passiveListener: s
      } = M(), a = P();
      t.$wrapperEl[e]("gesturestart", a, b, s), t.$wrapperEl[e]("gesturechange", a, x, s), t.$wrapperEl[e]("gestureend", a, y, s)
    }

    function z() {
      l || (l = !0, k("on"))
    }

    function L() {
      l && (l = !1, k("off"))
    }

    function O() {
      const e = t.zoom;
      if (e.enabled) return;
      e.enabled = !0;
      const s = t.support,
        {
          passiveListener: a,
          activeListenerWithCapture: i
        } = M(),
        r = P();
      s.gestures ? (t.$wrapperEl.on(t.touchEvents.start, z, a), t.$wrapperEl.on(t.touchEvents.end, L, a)) : "touchstart" === t.touchEvents.start && (t.$wrapperEl.on(t.touchEvents.start, r, b, a), t.$wrapperEl.on(t.touchEvents.move, r, x, i), t.$wrapperEl.on(t.touchEvents.end, r, y, a), t.touchEvents.cancel && t.$wrapperEl.on(t.touchEvents.cancel, r, y, a)), t.$wrapperEl.on(t.touchEvents.move, `.${t.params.zoom.containerClass}`, E, i)
    }

    function I() {
      const e = t.zoom;
      if (!e.enabled) return;
      const s = t.support;
      e.enabled = !1;
      const {
        passiveListener: a,
        activeListenerWithCapture: i
      } = M(), r = P();
      s.gestures ? (t.$wrapperEl.off(t.touchEvents.start, z, a), t.$wrapperEl.off(t.touchEvents.end, L, a)) : "touchstart" === t.touchEvents.start && (t.$wrapperEl.off(t.touchEvents.start, r, b, a), t.$wrapperEl.off(t.touchEvents.move, r, x, i), t.$wrapperEl.off(t.touchEvents.end, r, y, a), t.touchEvents.cancel && t.$wrapperEl.off(t.touchEvents.cancel, r, y, a)), t.$wrapperEl.off(t.touchEvents.move, `.${t.params.zoom.containerClass}`, E, i)
    }
    Object.defineProperty(t.zoom, "scale", {
      get: () => v,
      set(e) {
        if (v !== e) {
          const t = m.$imageEl ? m.$imageEl[0] : void 0,
            s = m.$slideEl ? m.$slideEl[0] : void 0;
          i("zoomChange", e, t, s)
        }
        v = e
      }
    }), a("init", (() => {
      t.params.zoom.enabled && O()
    })), a("destroy", (() => {
      I()
    })), a("touchStart", ((e, s) => {
      t.zoom.enabled && function (e) {
        const s = t.device;
        m.$imageEl && 0 !== m.$imageEl.length && (f.isTouched || (s.android && e.cancelable && e.preventDefault(), f.isTouched = !0, f.touchesStart.x = "touchstart" === e.type ? e.targetTouches[0].pageX : e.pageX, f.touchesStart.y = "touchstart" === e.type ? e.targetTouches[0].pageY : e.pageY))
      }(s)
    })), a("touchEnd", ((e, s) => {
      t.zoom.enabled && function () {
        const e = t.zoom;
        if (!m.$imageEl || 0 === m.$imageEl.length) return;
        if (!f.isTouched || !f.isMoved) return f.isTouched = !1, void(f.isMoved = !1);
        f.isTouched = !1, f.isMoved = !1;
        let s = 300,
          a = 300;
        const i = g.x * s,
          r = f.currentX + i,
          n = g.y * a,
          l = f.currentY + n;
        0 !== g.x && (s = Math.abs((r - f.currentX) / g.x)), 0 !== g.y && (a = Math.abs((l - f.currentY) / g.y));
        const o = Math.max(s, a);
        f.currentX = r, f.currentY = l;
        const d = f.width * e.scale,
          c = f.height * e.scale;
        f.minX = Math.min(m.slideWidth / 2 - d / 2, 0), f.maxX = -f.minX, f.minY = Math.min(m.slideHeight / 2 - c / 2, 0), f.maxY = -f.minY, f.currentX = Math.max(Math.min(f.currentX, f.maxX), f.minX), f.currentY = Math.max(Math.min(f.currentY, f.maxY), f.minY), m.$imageWrapEl.transition(o).transform(`translate3d(${f.currentX}px, ${f.currentY}px,0)`)
      }()
    })), a("doubleTap", ((e, s) => {
      !t.animating && t.params.zoom.enabled && t.zoom.enabled && t.params.zoom.toggle && S(s)
    })), a("transitionEnd", (() => {
      t.zoom.enabled && t.params.zoom.enabled && C()
    })), a("slideChange", (() => {
      t.zoom.enabled && t.params.zoom.enabled && t.params.cssMode && C()
    })), Object.assign(t.zoom, {
      enable: O,
      disable: I,
      in: T,
      out: $,
      toggle: S
    })
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      on: a,
      emit: i
    } = e;
    s({
      lazy: {
        checkInView: !1,
        enabled: !1,
        loadPrevNext: !1,
        loadPrevNextAmount: 1,
        loadOnTransitionStart: !1,
        scrollingElement: "",
        elementClass: "swiper-lazy",
        loadingClass: "swiper-lazy-loading",
        loadedClass: "swiper-lazy-loaded",
        preloaderClass: "swiper-lazy-preloader"
      }
    }), t.lazy = {};
    let n = !1,
      l = !1;

    function o(e, s) {
      void 0 === s && (s = !0);
      const a = t.params.lazy;
      if (void 0 === e) return;
      if (0 === t.slides.length) return;
      const r = t.virtual && t.params.virtual.enabled ? t.$wrapperEl.children(`.${t.params.slideClass}[data-swiper-slide-index="${e}"]`) : t.slides.eq(e),
        n = r.find(`.${a.elementClass}:not(.${a.loadedClass}):not(.${a.loadingClass})`);
      !r.hasClass(a.elementClass) || r.hasClass(a.loadedClass) || r.hasClass(a.loadingClass) || n.push(r[0]), 0 !== n.length && n.each((e => {
        const n = d(e);
        n.addClass(a.loadingClass);
        const l = n.attr("data-background"),
          c = n.attr("data-src"),
          p = n.attr("data-srcset"),
          u = n.attr("data-sizes"),
          h = n.parent("picture");
        t.loadImage(n[0], c || l, p, u, !1, (() => {
          if (null != t && t && (!t || t.params) && !t.destroyed) {
            if (l ? (n.css("background-image", `url("${l}")`), n.removeAttr("data-background")) : (p && (n.attr("srcset", p), n.removeAttr("data-srcset")), u && (n.attr("sizes", u), n.removeAttr("data-sizes")), h.length && h.children("source").each((e => {
                const t = d(e);
                t.attr("data-srcset") && (t.attr("srcset", t.attr("data-srcset")), t.removeAttr("data-srcset"))
              })), c && (n.attr("src", c), n.removeAttr("data-src"))), n.addClass(a.loadedClass).removeClass(a.loadingClass), r.find(`.${a.preloaderClass}`).remove(), t.params.loop && s) {
              const e = r.attr("data-swiper-slide-index");
              if (r.hasClass(t.params.slideDuplicateClass)) {
                o(t.$wrapperEl.children(`[data-swiper-slide-index="${e}"]:not(.${t.params.slideDuplicateClass})`).index(), !1)
              } else {
                o(t.$wrapperEl.children(`.${t.params.slideDuplicateClass}[data-swiper-slide-index="${e}"]`).index(), !1)
              }
            }
            i("lazyImageReady", r[0], n[0]), t.params.autoHeight && t.updateAutoHeight()
          }
        })), i("lazyImageLoad", r[0], n[0])
      }))
    }

    function c() {
      const {
        $wrapperEl: e,
        params: s,
        slides: a,
        activeIndex: i
      } = t, r = t.virtual && s.virtual.enabled, n = s.lazy;
      let c = s.slidesPerView;

      function p(t) {
        if (r) {
          if (e.children(`.${s.slideClass}[data-swiper-slide-index="${t}"]`).length) return !0
        } else if (a[t]) return !0;
        return !1
      }

      function u(e) {
        return r ? d(e).attr("data-swiper-slide-index") : d(e).index()
      }
      if ("auto" === c && (c = 0), l || (l = !0), t.params.watchSlidesProgress) e.children(`.${s.slideVisibleClass}`).each((e => {
        o(r ? d(e).attr("data-swiper-slide-index") : d(e).index())
      }));
      else if (c > 1)
        for (let e = i; e < i + c; e += 1) p(e) && o(e);
      else o(i);
      if (n.loadPrevNext)
        if (c > 1 || n.loadPrevNextAmount && n.loadPrevNextAmount > 1) {
          const e = n.loadPrevNextAmount,
            t = Math.ceil(c),
            s = Math.min(i + t + Math.max(e, t), a.length),
            r = Math.max(i - Math.max(t, e), 0);
          for (let e = i + t; e < s; e += 1) p(e) && o(e);
          for (let e = r; e < i; e += 1) p(e) && o(e)
        } else {
          const t = e.children(`.${s.slideNextClass}`);
          t.length > 0 && o(u(t));
          const a = e.children(`.${s.slidePrevClass}`);
          a.length > 0 && o(u(a))
        }
    }

    function p() {
      const e = r();
      if (!t || t.destroyed) return;
      const s = t.params.lazy.scrollingElement ? d(t.params.lazy.scrollingElement) : d(e),
        a = s[0] === e,
        i = a ? e.innerWidth : s[0].offsetWidth,
        l = a ? e.innerHeight : s[0].offsetHeight,
        o = t.$el.offset(),
        {
          rtlTranslate: u
        } = t;
      let h = !1;
      u && (o.left -= t.$el[0].scrollLeft);
      const m = [
        [o.left, o.top],
        [o.left + t.width, o.top],
        [o.left, o.top + t.height],
        [o.left + t.width, o.top + t.height]
      ];
      for (let e = 0; e < m.length; e += 1) {
        const t = m[e];
        if (t[0] >= 0 && t[0] <= i && t[1] >= 0 && t[1] <= l) {
          if (0 === t[0] && 0 === t[1]) continue;
          h = !0
        }
      }
      const f = !("touchstart" !== t.touchEvents.start || !t.support.passiveListener || !t.params.passiveListeners) && {
        passive: !0,
        capture: !1
      };
      h ? (c(), s.off("scroll", p, f)) : n || (n = !0, s.on("scroll", p, f))
    }
    a("beforeInit", (() => {
      t.params.lazy.enabled && t.params.preloadImages && (t.params.preloadImages = !1)
    })), a("init", (() => {
      t.params.lazy.enabled && (t.params.lazy.checkInView ? p() : c())
    })), a("scroll", (() => {
      t.params.freeMode && t.params.freeMode.enabled && !t.params.freeMode.sticky && c()
    })), a("scrollbarDragMove resize _freeModeNoMomentumRelease", (() => {
      t.params.lazy.enabled && (t.params.lazy.checkInView ? p() : c())
    })), a("transitionStart", (() => {
      t.params.lazy.enabled && (t.params.lazy.loadOnTransitionStart || !t.params.lazy.loadOnTransitionStart && !l) && (t.params.lazy.checkInView ? p() : c())
    })), a("transitionEnd", (() => {
      t.params.lazy.enabled && !t.params.lazy.loadOnTransitionStart && (t.params.lazy.checkInView ? p() : c())
    })), a("slideChange", (() => {
      const {
        lazy: e,
        cssMode: s,
        watchSlidesProgress: a,
        touchReleaseOnEdges: i,
        resistanceRatio: r
      } = t.params;
      e.enabled && (s || a && (i || 0 === r)) && c()
    })), a("destroy", (() => {
      t.$el && t.$el.find(`.${t.params.lazy.loadingClass}`).removeClass(t.params.lazy.loadingClass)
    })), Object.assign(t.lazy, {
      load: c,
      loadInSlide: o
    })
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      on: a
    } = e;

    function i(e, t) {
      const s = function () {
        let e, t, s;
        return (a, i) => {
          for (t = -1, e = a.length; e - t > 1;) s = e + t >> 1, a[s] <= i ? t = s : e = s;
          return e
        }
      }();
      let a, i;
      return this.x = e, this.y = t, this.lastIndex = e.length - 1, this.interpolate = function (e) {
        return e ? (i = s(this.x, e), a = i - 1, (e - this.x[a]) * (this.y[i] - this.y[a]) / (this.x[i] - this.x[a]) + this.y[a]) : 0
      }, this
    }

    function r() {
      t.controller.control && t.controller.spline && (t.controller.spline = void 0, delete t.controller.spline)
    }
    s({
      controller: {
        control: void 0,
        inverse: !1,
        by: "slide"
      }
    }), t.controller = {
      control: void 0
    }, a("beforeInit", (() => {
      t.controller.control = t.params.controller.control
    })), a("update", (() => {
      r()
    })), a("resize", (() => {
      r()
    })), a("observerUpdate", (() => {
      r()
    })), a("setTranslate", ((e, s, a) => {
      t.controller.control && t.controller.setTranslate(s, a)
    })), a("setTransition", ((e, s, a) => {
      t.controller.control && t.controller.setTransition(s, a)
    })), Object.assign(t.controller, {
      setTranslate: function (e, s) {
        const a = t.controller.control;
        let r, n;
        const l = t.constructor;

        function o(e) {
          const s = t.rtlTranslate ? -t.translate : t.translate;
          "slide" === t.params.controller.by && (! function (e) {
            t.controller.spline || (t.controller.spline = t.params.loop ? new i(t.slidesGrid, e.slidesGrid) : new i(t.snapGrid, e.snapGrid))
          }(e), n = -t.controller.spline.interpolate(-s)), n && "container" !== t.params.controller.by || (r = (e.maxTranslate() - e.minTranslate()) / (t.maxTranslate() - t.minTranslate()), n = (s - t.minTranslate()) * r + e.minTranslate()), t.params.controller.inverse && (n = e.maxTranslate() - n), e.updateProgress(n), e.setTranslate(n, t), e.updateActiveIndex(), e.updateSlidesClasses()
        }
        if (Array.isArray(a))
          for (let e = 0; e < a.length; e += 1) a[e] !== s && a[e] instanceof l && o(a[e]);
        else a instanceof l && s !== a && o(a)
      },
      setTransition: function (e, s) {
        const a = t.constructor,
          i = t.controller.control;
        let r;

        function n(s) {
          s.setTransition(e, t), 0 !== e && (s.transitionStart(), s.params.autoHeight && p((() => {
            s.updateAutoHeight()
          })), s.$wrapperEl.transitionEnd((() => {
            i && (s.params.loop && "slide" === t.params.controller.by && s.loopFix(), s.transitionEnd())
          })))
        }
        if (Array.isArray(i))
          for (r = 0; r < i.length; r += 1) i[r] !== s && i[r] instanceof a && n(i[r]);
        else i instanceof a && s !== i && n(i)
      }
    })
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      on: a
    } = e;
    s({
      a11y: {
        enabled: !0,
        notificationClass: "swiper-notification",
        prevSlideMessage: "Previous slide",
        nextSlideMessage: "Next slide",
        firstSlideMessage: "This is the first slide",
        lastSlideMessage: "This is the last slide",
        paginationBulletMessage: "Go to slide {{index}}",
        slideLabelMessage: "{{index}} / {{slidesLength}}",
        containerMessage: null,
        containerRoleDescriptionMessage: null,
        itemRoleDescriptionMessage: null,
        slideRole: "group",
        id: null
      }
    });
    let i = null;

    function r(e) {
      const t = i;
      0 !== t.length && (t.html(""), t.html(e))
    }

    function n(e) {
      e.attr("tabIndex", "0")
    }

    function l(e) {
      e.attr("tabIndex", "-1")
    }

    function o(e, t) {
      e.attr("role", t)
    }

    function c(e, t) {
      e.attr("aria-roledescription", t)
    }

    function p(e, t) {
      e.attr("aria-label", t)
    }

    function u(e) {
      e.attr("aria-disabled", !0)
    }

    function h(e) {
      e.attr("aria-disabled", !1)
    }

    function m(e) {
      if (13 !== e.keyCode && 32 !== e.keyCode) return;
      const s = t.params.a11y,
        a = d(e.target);
      t.navigation && t.navigation.$nextEl && a.is(t.navigation.$nextEl) && (t.isEnd && !t.params.loop || t.slideNext(), t.isEnd ? r(s.lastSlideMessage) : r(s.nextSlideMessage)), t.navigation && t.navigation.$prevEl && a.is(t.navigation.$prevEl) && (t.isBeginning && !t.params.loop || t.slidePrev(), t.isBeginning ? r(s.firstSlideMessage) : r(s.prevSlideMessage)), t.pagination && a.is(U(t.params.pagination.bulletClass)) && a[0].click()
    }

    function f() {
      return t.pagination && t.pagination.bullets && t.pagination.bullets.length
    }

    function g() {
      return f() && t.params.pagination.clickable
    }
    const v = (e, t, s) => {
        n(e), "BUTTON" !== e[0].tagName && (o(e, "button"), e.on("keydown", m)), p(e, s),
          function (e, t) {
            e.attr("aria-controls", t)
          }(e, t)
      },
      w = e => {
        const s = e.target.closest(`.${t.params.slideClass}`);
        if (!s || !t.slides.includes(s)) return;
        const a = t.slides.indexOf(s) === t.activeIndex,
          i = t.params.watchSlidesProgress && t.visibleSlides && t.visibleSlides.includes(s);
        a || i || (t.isHorizontal() ? t.el.scrollLeft = 0 : t.el.scrollTop = 0, t.slideTo(t.slides.indexOf(s), 0))
      },
      b = () => {
        const e = t.params.a11y;
        e.itemRoleDescriptionMessage && c(d(t.slides), e.itemRoleDescriptionMessage), e.slideRole && o(d(t.slides), e.slideRole);
        const s = t.params.loop ? t.slides.filter((e => !e.classList.contains(t.params.slideDuplicateClass))).length : t.slides.length;
        e.slideLabelMessage && t.slides.each(((a, i) => {
          const r = d(a),
            n = t.params.loop ? parseInt(r.attr("data-swiper-slide-index"), 10) : i;
          p(r, e.slideLabelMessage.replace(/\{\{index\}\}/, n + 1).replace(/\{\{slidesLength\}\}/, s))
        }))
      },
      x = () => {
        const e = t.params.a11y;
        t.$el.append(i);
        const s = t.$el;
        e.containerRoleDescriptionMessage && c(s, e.containerRoleDescriptionMessage), e.containerMessage && p(s, e.containerMessage);
        const a = t.$wrapperEl,
          r = e.id || a.attr("id") || `swiper-wrapper-${n=16,void 0===n&&(n=16),"x".repeat(n).replace(/x/g,(()=>Math.round(16*Math.random()).toString(16)))}`;
        var n;
        const l = t.params.autoplay && t.params.autoplay.enabled ? "off" : "polite";
        var o;
        let d, u;
        o = r, a.attr("id", o),
          function (e, t) {
            e.attr("aria-live", t)
          }(a, l), b(), t.navigation && t.navigation.$nextEl && (d = t.navigation.$nextEl), t.navigation && t.navigation.$prevEl && (u = t.navigation.$prevEl), d && d.length && v(d, r, e.nextSlideMessage), u && u.length && v(u, r, e.prevSlideMessage), g() && t.pagination.$el.on("keydown", U(t.params.pagination.bulletClass), m), t.$el.on("focus", w, !0)
      };
    a("beforeInit", (() => {
      i = d(`<span class="${t.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`)
    })), a("afterInit", (() => {
      t.params.a11y.enabled && x()
    })), a("slidesLengthChange snapGridLengthChange slidesGridLengthChange", (() => {
      t.params.a11y.enabled && b()
    })), a("fromEdge toEdge afterInit lock unlock", (() => {
      t.params.a11y.enabled && function () {
        if (t.params.loop || t.params.rewind || !t.navigation) return;
        const {
          $nextEl: e,
          $prevEl: s
        } = t.navigation;
        s && s.length > 0 && (t.isBeginning ? (u(s), l(s)) : (h(s), n(s))), e && e.length > 0 && (t.isEnd ? (u(e), l(e)) : (h(e), n(e)))
      }()
    })), a("paginationUpdate", (() => {
      t.params.a11y.enabled && function () {
        const e = t.params.a11y;
        f() && t.pagination.bullets.each((s => {
          const a = d(s);
          t.params.pagination.clickable && (n(a), t.params.pagination.renderBullet || (o(a, "button"), p(a, e.paginationBulletMessage.replace(/\{\{index\}\}/, a.index() + 1)))), a.is(`.${t.params.pagination.bulletActiveClass}`) ? a.attr("aria-current", "true") : a.removeAttr("aria-current")
        }))
      }()
    })), a("destroy", (() => {
      t.params.a11y.enabled && function () {
        let e, s;
        i && i.length > 0 && i.remove(), t.navigation && t.navigation.$nextEl && (e = t.navigation.$nextEl), t.navigation && t.navigation.$prevEl && (s = t.navigation.$prevEl), e && e.off("keydown", m), s && s.off("keydown", m), g() && t.pagination.$el.off("keydown", U(t.params.pagination.bulletClass), m), t.$el.off("focus", w, !0)
      }()
    }))
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      on: a
    } = e;
    s({
      history: {
        enabled: !1,
        root: "",
        replaceState: !1,
        key: "slides",
        keepQuery: !1
      }
    });
    let i = !1,
      n = {};
    const l = e => e.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, ""),
      o = e => {
        const t = r();
        let s;
        s = e ? new URL(e) : t.location;
        const a = s.pathname.slice(1).split("/").filter((e => "" !== e)),
          i = a.length;
        return {
          key: a[i - 2],
          value: a[i - 1]
        }
      },
      d = (e, s) => {
        const a = r();
        if (!i || !t.params.history.enabled) return;
        let n;
        n = t.params.url ? new URL(t.params.url) : a.location;
        const o = t.slides.eq(s);
        let d = l(o.attr("data-history"));
        if (t.params.history.root.length > 0) {
          let s = t.params.history.root;
          "/" === s[s.length - 1] && (s = s.slice(0, s.length - 1)), d = `${s}/${e}/${d}`
        } else n.pathname.includes(e) || (d = `${e}/${d}`);
        t.params.history.keepQuery && (d += n.search);
        const c = a.history.state;
        c && c.value === d || (t.params.history.replaceState ? a.history.replaceState({
          value: d
        }, null, d) : a.history.pushState({
          value: d
        }, null, d))
      },
      c = (e, s, a) => {
        if (s)
          for (let i = 0, r = t.slides.length; i < r; i += 1) {
            const r = t.slides.eq(i);
            if (l(r.attr("data-history")) === s && !r.hasClass(t.params.slideDuplicateClass)) {
              const s = r.index();
              t.slideTo(s, e, a)
            }
          } else t.slideTo(0, e, a)
      },
      p = () => {
        n = o(t.params.url), c(t.params.speed, n.value, !1)
      };
    a("init", (() => {
      t.params.history.enabled && (() => {
        const e = r();
        if (t.params.history) {
          if (!e.history || !e.history.pushState) return t.params.history.enabled = !1, void(t.params.hashNavigation.enabled = !0);
          i = !0, n = o(t.params.url), (n.key || n.value) && (c(0, n.value, t.params.runCallbacksOnInit), t.params.history.replaceState || e.addEventListener("popstate", p))
        }
      })()
    })), a("destroy", (() => {
      t.params.history.enabled && (() => {
        const e = r();
        t.params.history.replaceState || e.removeEventListener("popstate", p)
      })()
    })), a("transitionEnd _freeModeNoMomentumRelease", (() => {
      i && d(t.params.history.key, t.activeIndex)
    })), a("slideChange", (() => {
      i && t.params.cssMode && d(t.params.history.key, t.activeIndex)
    }))
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      emit: i,
      on: n
    } = e, l = !1;
    const o = a(),
      c = r();
    s({
      hashNavigation: {
        enabled: !1,
        replaceState: !1,
        watchState: !1
      }
    });
    const p = () => {
        i("hashChange");
        const e = o.location.hash.replace("#", "");
        if (e !== t.slides.eq(t.activeIndex).attr("data-hash")) {
          const s = t.$wrapperEl.children(`.${t.params.slideClass}[data-hash="${e}"]`).index();
          if (void 0 === s) return;
          t.slideTo(s)
        }
      },
      u = () => {
        if (l && t.params.hashNavigation.enabled)
          if (t.params.hashNavigation.replaceState && c.history && c.history.replaceState) c.history.replaceState(null, null, `#${t.slides.eq(t.activeIndex).attr("data-hash")}` || ""), i("hashSet");
          else {
            const e = t.slides.eq(t.activeIndex),
              s = e.attr("data-hash") || e.attr("data-history");
            o.location.hash = s || "", i("hashSet")
          }
      };
    n("init", (() => {
      t.params.hashNavigation.enabled && (() => {
        if (!t.params.hashNavigation.enabled || t.params.history && t.params.history.enabled) return;
        l = !0;
        const e = o.location.hash.replace("#", "");
        if (e) {
          const s = 0;
          for (let a = 0, i = t.slides.length; a < i; a += 1) {
            const i = t.slides.eq(a);
            if ((i.attr("data-hash") || i.attr("data-history")) === e && !i.hasClass(t.params.slideDuplicateClass)) {
              const e = i.index();
              t.slideTo(e, s, t.params.runCallbacksOnInit, !0)
            }
          }
        }
        t.params.hashNavigation.watchState && d(c).on("hashchange", p)
      })()
    })), n("destroy", (() => {
      t.params.hashNavigation.enabled && t.params.hashNavigation.watchState && d(c).off("hashchange", p)
    })), n("transitionEnd _freeModeNoMomentumRelease", (() => {
      l && u()
    })), n("slideChange", (() => {
      l && t.params.cssMode && u()
    }))
  }, function (e) {
    let t, {
      swiper: s,
      extendParams: i,
      on: r,
      emit: n
    } = e;

    function l() {
      if (!s.size) return s.autoplay.running = !1, void(s.autoplay.paused = !1);
      const e = s.slides.eq(s.activeIndex);
      let a = s.params.autoplay.delay;
      e.attr("data-swiper-autoplay") && (a = e.attr("data-swiper-autoplay") || s.params.autoplay.delay), clearTimeout(t), t = p((() => {
        let e;
        s.params.autoplay.reverseDirection ? s.params.loop ? (s.loopFix(), e = s.slidePrev(s.params.speed, !0, !0), n("autoplay")) : s.isBeginning ? s.params.autoplay.stopOnLastSlide ? d() : (e = s.slideTo(s.slides.length - 1, s.params.speed, !0, !0), n("autoplay")) : (e = s.slidePrev(s.params.speed, !0, !0), n("autoplay")) : s.params.loop ? (s.loopFix(), e = s.slideNext(s.params.speed, !0, !0), n("autoplay")) : s.isEnd ? s.params.autoplay.stopOnLastSlide ? d() : (e = s.slideTo(0, s.params.speed, !0, !0), n("autoplay")) : (e = s.slideNext(s.params.speed, !0, !0), n("autoplay")), (s.params.cssMode && s.autoplay.running || !1 === e) && l()
      }), a)
    }

    function o() {
      return void 0 === t && (!s.autoplay.running && (s.autoplay.running = !0, n("autoplayStart"), l(), !0))
    }

    function d() {
      return !!s.autoplay.running && (void 0 !== t && (t && (clearTimeout(t), t = void 0), s.autoplay.running = !1, n("autoplayStop"), !0))
    }

    function c(e) {
      s.autoplay.running && (s.autoplay.paused || (t && clearTimeout(t), s.autoplay.paused = !0, 0 !== e && s.params.autoplay.waitForTransition ? ["transitionend", "webkitTransitionEnd"].forEach((e => {
        s.$wrapperEl[0].addEventListener(e, h)
      })) : (s.autoplay.paused = !1, l())))
    }

    function u() {
      const e = a();
      "hidden" === e.visibilityState && s.autoplay.running && c(), "visible" === e.visibilityState && s.autoplay.paused && (l(), s.autoplay.paused = !1)
    }

    function h(e) {
      s && !s.destroyed && s.$wrapperEl && e.target === s.$wrapperEl[0] && (["transitionend", "webkitTransitionEnd"].forEach((e => {
        s.$wrapperEl[0].removeEventListener(e, h)
      })), s.autoplay.paused = !1, s.autoplay.running ? l() : d())
    }

    function m() {
      s.params.autoplay.disableOnInteraction ? d() : (n("autoplayPause"), c()), ["transitionend", "webkitTransitionEnd"].forEach((e => {
        s.$wrapperEl[0].removeEventListener(e, h)
      }))
    }

    function f() {
      s.params.autoplay.disableOnInteraction || (s.autoplay.paused = !1, n("autoplayResume"), l())
    }
    s.autoplay = {
      running: !1,
      paused: !1
    }, i({
      autoplay: {
        enabled: !1,
        delay: 3e3,
        waitForTransition: !0,
        disableOnInteraction: !0,
        stopOnLastSlide: !1,
        reverseDirection: !1,
        pauseOnMouseEnter: !1
      }
    }), r("init", (() => {
      if (s.params.autoplay.enabled) {
        o();
        a().addEventListener("visibilitychange", u), s.params.autoplay.pauseOnMouseEnter && (s.$el.on("mouseenter", m), s.$el.on("mouseleave", f))
      }
    })), r("beforeTransitionStart", ((e, t, a) => {
      s.autoplay.running && (a || !s.params.autoplay.disableOnInteraction ? s.autoplay.pause(t) : d())
    })), r("sliderFirstMove", (() => {
      s.autoplay.running && (s.params.autoplay.disableOnInteraction ? d() : c())
    })), r("touchEnd", (() => {
      s.params.cssMode && s.autoplay.paused && !s.params.autoplay.disableOnInteraction && l()
    })), r("destroy", (() => {
      s.$el.off("mouseenter", m), s.$el.off("mouseleave", f), s.autoplay.running && d();
      a().removeEventListener("visibilitychange", u)
    })), Object.assign(s.autoplay, {
      pause: c,
      run: l,
      start: o,
      stop: d
    })
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      on: a
    } = e;
    s({
      thumbs: {
        swiper: null,
        multipleActiveThumbs: !0,
        autoScrollOffset: 0,
        slideThumbActiveClass: "swiper-slide-thumb-active",
        thumbsContainerClass: "swiper-thumbs"
      }
    });
    let i = !1,
      r = !1;

    function n() {
      const e = t.thumbs.swiper;
      if (!e || e.destroyed) return;
      const s = e.clickedIndex,
        a = e.clickedSlide;
      if (a && d(a).hasClass(t.params.thumbs.slideThumbActiveClass)) return;
      if (null == s) return;
      let i;
      if (i = e.params.loop ? parseInt(d(e.clickedSlide).attr("data-swiper-slide-index"), 10) : s, t.params.loop) {
        let e = t.activeIndex;
        t.slides.eq(e).hasClass(t.params.slideDuplicateClass) && (t.loopFix(), t._clientLeft = t.$wrapperEl[0].clientLeft, e = t.activeIndex);
        const s = t.slides.eq(e).prevAll(`[data-swiper-slide-index="${i}"]`).eq(0).index(),
          a = t.slides.eq(e).nextAll(`[data-swiper-slide-index="${i}"]`).eq(0).index();
        i = void 0 === s ? a : void 0 === a ? s : a - e < e - s ? a : s
      }
      t.slideTo(i)
    }

    function l() {
      const {
        thumbs: e
      } = t.params;
      if (i) return !1;
      i = !0;
      const s = t.constructor;
      if (e.swiper instanceof s) t.thumbs.swiper = e.swiper, Object.assign(t.thumbs.swiper.originalParams, {
        watchSlidesProgress: !0,
        slideToClickedSlide: !1
      }), Object.assign(t.thumbs.swiper.params, {
        watchSlidesProgress: !0,
        slideToClickedSlide: !1
      });
      else if (m(e.swiper)) {
        const a = Object.assign({}, e.swiper);
        Object.assign(a, {
          watchSlidesProgress: !0,
          slideToClickedSlide: !1
        }), t.thumbs.swiper = new s(a), r = !0
      }
      return t.thumbs.swiper.$el.addClass(t.params.thumbs.thumbsContainerClass), t.thumbs.swiper.on("tap", n), !0
    }

    function o(e) {
      const s = t.thumbs.swiper;
      if (!s || s.destroyed) return;
      const a = "auto" === s.params.slidesPerView ? s.slidesPerViewDynamic() : s.params.slidesPerView;
      let i = 1;
      const r = t.params.thumbs.slideThumbActiveClass;
      if (t.params.slidesPerView > 1 && !t.params.centeredSlides && (i = t.params.slidesPerView), t.params.thumbs.multipleActiveThumbs || (i = 1), i = Math.floor(i), s.slides.removeClass(r), s.params.loop || s.params.virtual && s.params.virtual.enabled)
        for (let e = 0; e < i; e += 1) s.$wrapperEl.children(`[data-swiper-slide-index="${t.realIndex+e}"]`).addClass(r);
      else
        for (let e = 0; e < i; e += 1) s.slides.eq(t.realIndex + e).addClass(r);
      const n = t.params.thumbs.autoScrollOffset,
        l = n && !s.params.loop;
      if (t.realIndex !== s.realIndex || l) {
        let i, r, o = s.activeIndex;
        if (s.params.loop) {
          s.slides.eq(o).hasClass(s.params.slideDuplicateClass) && (s.loopFix(), s._clientLeft = s.$wrapperEl[0].clientLeft, o = s.activeIndex);
          const e = s.slides.eq(o).prevAll(`[data-swiper-slide-index="${t.realIndex}"]`).eq(0).index(),
            a = s.slides.eq(o).nextAll(`[data-swiper-slide-index="${t.realIndex}"]`).eq(0).index();
          i = void 0 === e ? a : void 0 === a ? e : a - o == o - e ? s.params.slidesPerGroup > 1 ? a : o : a - o < o - e ? a : e, r = t.activeIndex > t.previousIndex ? "next" : "prev"
        } else i = t.realIndex, r = i > t.previousIndex ? "next" : "prev";
        l && (i += "next" === r ? n : -1 * n), s.visibleSlidesIndexes && s.visibleSlidesIndexes.indexOf(i) < 0 && (s.params.centeredSlides ? i = i > o ? i - Math.floor(a / 2) + 1 : i + Math.floor(a / 2) - 1 : i > o && s.params.slidesPerGroup, s.slideTo(i, e ? 0 : void 0))
      }
    }
    t.thumbs = {
      swiper: null
    }, a("beforeInit", (() => {
      const {
        thumbs: e
      } = t.params;
      e && e.swiper && (l(), o(!0))
    })), a("slideChange update resize observerUpdate", (() => {
      o()
    })), a("setTransition", ((e, s) => {
      const a = t.thumbs.swiper;
      a && !a.destroyed && a.setTransition(s)
    })), a("beforeDestroy", (() => {
      const e = t.thumbs.swiper;
      e && !e.destroyed && r && e.destroy()
    })), Object.assign(t.thumbs, {
      init: l,
      update: o
    })
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      emit: a,
      once: i
    } = e;
    s({
      freeMode: {
        enabled: !1,
        momentum: !0,
        momentumRatio: 1,
        momentumBounce: !0,
        momentumBounceRatio: 1,
        momentumVelocityRatio: 1,
        sticky: !1,
        minimumVelocity: .02
      }
    }), Object.assign(t, {
      freeMode: {
        onTouchStart: function () {
          const e = t.getTranslate();
          t.setTranslate(e), t.setTransition(0), t.touchEventsData.velocities.length = 0, t.freeMode.onTouchEnd({
            currentPos: t.rtl ? t.translate : -t.translate
          })
        },
        onTouchMove: function () {
          const {
            touchEventsData: e,
            touches: s
          } = t;
          0 === e.velocities.length && e.velocities.push({
            position: s[t.isHorizontal() ? "startX" : "startY"],
            time: e.touchStartTime
          }), e.velocities.push({
            position: s[t.isHorizontal() ? "currentX" : "currentY"],
            time: u()
          })
        },
        onTouchEnd: function (e) {
          let {
            currentPos: s
          } = e;
          const {
            params: r,
            $wrapperEl: n,
            rtlTranslate: l,
            snapGrid: o,
            touchEventsData: d
          } = t, c = u() - d.touchStartTime;
          if (s < -t.minTranslate()) t.slideTo(t.activeIndex);
          else if (s > -t.maxTranslate()) t.slides.length < o.length ? t.slideTo(o.length - 1) : t.slideTo(t.slides.length - 1);
          else {
            if (r.freeMode.momentum) {
              if (d.velocities.length > 1) {
                const e = d.velocities.pop(),
                  s = d.velocities.pop(),
                  a = e.position - s.position,
                  i = e.time - s.time;
                t.velocity = a / i, t.velocity /= 2, Math.abs(t.velocity) < r.freeMode.minimumVelocity && (t.velocity = 0), (i > 150 || u() - e.time > 300) && (t.velocity = 0)
              } else t.velocity = 0;
              t.velocity *= r.freeMode.momentumVelocityRatio, d.velocities.length = 0;
              let e = 1e3 * r.freeMode.momentumRatio;
              const s = t.velocity * e;
              let c = t.translate + s;
              l && (c = -c);
              let p, h = !1;
              const m = 20 * Math.abs(t.velocity) * r.freeMode.momentumBounceRatio;
              let f;
              if (c < t.maxTranslate()) r.freeMode.momentumBounce ? (c + t.maxTranslate() < -m && (c = t.maxTranslate() - m), p = t.maxTranslate(), h = !0, d.allowMomentumBounce = !0) : c = t.maxTranslate(), r.loop && r.centeredSlides && (f = !0);
              else if (c > t.minTranslate()) r.freeMode.momentumBounce ? (c - t.minTranslate() > m && (c = t.minTranslate() + m), p = t.minTranslate(), h = !0, d.allowMomentumBounce = !0) : c = t.minTranslate(), r.loop && r.centeredSlides && (f = !0);
              else if (r.freeMode.sticky) {
                let e;
                for (let t = 0; t < o.length; t += 1)
                  if (o[t] > -c) {
                    e = t;
                    break
                  } c = Math.abs(o[e] - c) < Math.abs(o[e - 1] - c) || "next" === t.swipeDirection ? o[e] : o[e - 1], c = -c
              }
              if (f && i("transitionEnd", (() => {
                  t.loopFix()
                })), 0 !== t.velocity) {
                if (e = l ? Math.abs((-c - t.translate) / t.velocity) : Math.abs((c - t.translate) / t.velocity), r.freeMode.sticky) {
                  const s = Math.abs((l ? -c : c) - t.translate),
                    a = t.slidesSizesGrid[t.activeIndex];
                  e = s < a ? r.speed : s < 2 * a ? 1.5 * r.speed : 2.5 * r.speed
                }
              } else if (r.freeMode.sticky) return void t.slideToClosest();
              r.freeMode.momentumBounce && h ? (t.updateProgress(p), t.setTransition(e), t.setTranslate(c), t.transitionStart(!0, t.swipeDirection), t.animating = !0, n.transitionEnd((() => {
                t && !t.destroyed && d.allowMomentumBounce && (a("momentumBounce"), t.setTransition(r.speed), setTimeout((() => {
                  t.setTranslate(p), n.transitionEnd((() => {
                    t && !t.destroyed && t.transitionEnd()
                  }))
                }), 0))
              }))) : t.velocity ? (a("_freeModeNoMomentumRelease"), t.updateProgress(c), t.setTransition(e), t.setTranslate(c), t.transitionStart(!0, t.swipeDirection), t.animating || (t.animating = !0, n.transitionEnd((() => {
                t && !t.destroyed && t.transitionEnd()
              })))) : t.updateProgress(c), t.updateActiveIndex(), t.updateSlidesClasses()
            } else {
              if (r.freeMode.sticky) return void t.slideToClosest();
              r.freeMode && a("_freeModeNoMomentumRelease")
            }(!r.freeMode.momentum || c >= r.longSwipesMs) && (t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses())
          }
        }
      }
    })
  }, function (e) {
    let t, s, a, {
      swiper: i,
      extendParams: r
    } = e;
    r({
      grid: {
        rows: 1,
        fill: "column"
      }
    }), i.grid = {
      initSlides: e => {
        const {
          slidesPerView: r
        } = i.params, {
          rows: n,
          fill: l
        } = i.params.grid;
        s = t / n, a = Math.floor(e / n), t = Math.floor(e / n) === e / n ? e : Math.ceil(e / n) * n, "auto" !== r && "row" === l && (t = Math.max(t, r * n))
      },
      updateSlide: (e, r, n, l) => {
        const {
          slidesPerGroup: o,
          spaceBetween: d
        } = i.params, {
          rows: c,
          fill: p
        } = i.params.grid;
        let u, h, m;
        if ("row" === p && o > 1) {
          const s = Math.floor(e / (o * c)),
            a = e - c * o * s,
            i = 0 === s ? o : Math.min(Math.ceil((n - s * c * o) / c), o);
          m = Math.floor(a / i), h = a - m * i + s * o, u = h + m * t / c, r.css({
            "-webkit-order": u,
            order: u
          })
        } else "column" === p ? (h = Math.floor(e / c), m = e - h * c, (h > a || h === a && m === c - 1) && (m += 1, m >= c && (m = 0, h += 1))) : (m = Math.floor(e / s), h = e - m * s);
        r.css(l("margin-top"), 0 !== m ? d && `${d}px` : "")
      },
      updateWrapperSize: (e, s, a) => {
        const {
          spaceBetween: r,
          centeredSlides: n,
          roundLengths: l
        } = i.params, {
          rows: o
        } = i.params.grid;
        if (i.virtualSize = (e + r) * t, i.virtualSize = Math.ceil(i.virtualSize / o) - r, i.$wrapperEl.css({
            [a("width")]: `${i.virtualSize+r}px`
          }), n) {
          s.splice(0, s.length);
          const e = [];
          for (let t = 0; t < s.length; t += 1) {
            let a = s[t];
            l && (a = Math.floor(a)), s[t] < i.virtualSize + s[0] && e.push(a)
          }
          s.push(...e)
        }
      }
    }
  }, function (e) {
    let {
      swiper: t
    } = e;
    Object.assign(t, {
      appendSlide: K.bind(t),
      prependSlide: Z.bind(t),
      addSlide: Q.bind(t),
      removeSlide: J.bind(t),
      removeAllSlides: ee.bind(t)
    })
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      on: a
    } = e;
    s({
      fadeEffect: {
        crossFade: !1,
        transformEl: null
      }
    }), te({
      effect: "fade",
      swiper: t,
      on: a,
      setTranslate: () => {
        const {
          slides: e
        } = t, s = t.params.fadeEffect;
        for (let a = 0; a < e.length; a += 1) {
          const e = t.slides.eq(a);
          let i = -e[0].swiperSlideOffset;
          t.params.virtualTranslate || (i -= t.translate);
          let r = 0;
          t.isHorizontal() || (r = i, i = 0);
          const n = t.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(e[0].progress), 0) : 1 + Math.min(Math.max(e[0].progress, -1), 0);
          se(s, e).css({
            opacity: n
          }).transform(`translate3d(${i}px, ${r}px, 0px)`)
        }
      },
      setTransition: e => {
        const {
          transformEl: s
        } = t.params.fadeEffect;
        (s ? t.slides.find(s) : t.slides).transition(e), ae({
          swiper: t,
          duration: e,
          transformEl: s,
          allSlides: !0
        })
      },
      overwriteParams: () => ({
        slidesPerView: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: !0,
        spaceBetween: 0,
        virtualTranslate: !t.params.cssMode
      })
    })
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      on: a
    } = e;
    s({
      cubeEffect: {
        slideShadows: !0,
        shadow: !0,
        shadowOffset: 20,
        shadowScale: .94
      }
    });
    const i = (e, t, s) => {
      let a = s ? e.find(".swiper-slide-shadow-left") : e.find(".swiper-slide-shadow-top"),
        i = s ? e.find(".swiper-slide-shadow-right") : e.find(".swiper-slide-shadow-bottom");
      0 === a.length && (a = d(`<div class="swiper-slide-shadow-${s?"left":"top"}"></div>`), e.append(a)), 0 === i.length && (i = d(`<div class="swiper-slide-shadow-${s?"right":"bottom"}"></div>`), e.append(i)), a.length && (a[0].style.opacity = Math.max(-t, 0)), i.length && (i[0].style.opacity = Math.max(t, 0))
    };
    te({
      effect: "cube",
      swiper: t,
      on: a,
      setTranslate: () => {
        const {
          $el: e,
          $wrapperEl: s,
          slides: a,
          width: r,
          height: n,
          rtlTranslate: l,
          size: o,
          browser: c
        } = t, p = t.params.cubeEffect, u = t.isHorizontal(), h = t.virtual && t.params.virtual.enabled;
        let m, f = 0;
        p.shadow && (u ? (m = s.find(".swiper-cube-shadow"), 0 === m.length && (m = d('<div class="swiper-cube-shadow"></div>'), s.append(m)), m.css({
          height: `${r}px`
        })) : (m = e.find(".swiper-cube-shadow"), 0 === m.length && (m = d('<div class="swiper-cube-shadow"></div>'), e.append(m))));
        for (let e = 0; e < a.length; e += 1) {
          const t = a.eq(e);
          let s = e;
          h && (s = parseInt(t.attr("data-swiper-slide-index"), 10));
          let r = 90 * s,
            n = Math.floor(r / 360);
          l && (r = -r, n = Math.floor(-r / 360));
          const d = Math.max(Math.min(t[0].progress, 1), -1);
          let c = 0,
            m = 0,
            g = 0;
          s % 4 == 0 ? (c = 4 * -n * o, g = 0) : (s - 1) % 4 == 0 ? (c = 0, g = 4 * -n * o) : (s - 2) % 4 == 0 ? (c = o + 4 * n * o, g = o) : (s - 3) % 4 == 0 && (c = -o, g = 3 * o + 4 * o * n), l && (c = -c), u || (m = c, c = 0);
          const v = `rotateX(${u?0:-r}deg) rotateY(${u?r:0}deg) translate3d(${c}px, ${m}px, ${g}px)`;
          d <= 1 && d > -1 && (f = 90 * s + 90 * d, l && (f = 90 * -s - 90 * d)), t.transform(v), p.slideShadows && i(t, d, u)
        }
        if (s.css({
            "-webkit-transform-origin": `50% 50% -${o/2}px`,
            "transform-origin": `50% 50% -${o/2}px`
          }), p.shadow)
          if (u) m.transform(`translate3d(0px, ${r/2+p.shadowOffset}px, ${-r/2}px) rotateX(90deg) rotateZ(0deg) scale(${p.shadowScale})`);
          else {
            const e = Math.abs(f) - 90 * Math.floor(Math.abs(f) / 90),
              t = 1.5 - (Math.sin(2 * e * Math.PI / 360) / 2 + Math.cos(2 * e * Math.PI / 360) / 2),
              s = p.shadowScale,
              a = p.shadowScale / t,
              i = p.shadowOffset;
            m.transform(`scale3d(${s}, 1, ${a}) translate3d(0px, ${n/2+i}px, ${-n/2/a}px) rotateX(-90deg)`)
          } const g = c.isSafari || c.isWebView ? -o / 2 : 0;
        s.transform(`translate3d(0px,0,${g}px) rotateX(${t.isHorizontal()?0:f}deg) rotateY(${t.isHorizontal()?-f:0}deg)`), s[0].style.setProperty("--swiper-cube-translate-z", `${g}px`)
      },
      setTransition: e => {
        const {
          $el: s,
          slides: a
        } = t;
        a.transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e), t.params.cubeEffect.shadow && !t.isHorizontal() && s.find(".swiper-cube-shadow").transition(e)
      },
      recreateShadows: () => {
        const e = t.isHorizontal();
        t.slides.each((t => {
          const s = Math.max(Math.min(t.progress, 1), -1);
          i(d(t), s, e)
        }))
      },
      getEffectParams: () => t.params.cubeEffect,
      perspective: () => !0,
      overwriteParams: () => ({
        slidesPerView: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: !0,
        resistanceRatio: 0,
        spaceBetween: 0,
        centeredSlides: !1,
        virtualTranslate: !0
      })
    })
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      on: a
    } = e;
    s({
      flipEffect: {
        slideShadows: !0,
        limitRotation: !0,
        transformEl: null
      }
    });
    const i = (e, s, a) => {
      let i = t.isHorizontal() ? e.find(".swiper-slide-shadow-left") : e.find(".swiper-slide-shadow-top"),
        r = t.isHorizontal() ? e.find(".swiper-slide-shadow-right") : e.find(".swiper-slide-shadow-bottom");
      0 === i.length && (i = ie(a, e, t.isHorizontal() ? "left" : "top")), 0 === r.length && (r = ie(a, e, t.isHorizontal() ? "right" : "bottom")), i.length && (i[0].style.opacity = Math.max(-s, 0)), r.length && (r[0].style.opacity = Math.max(s, 0))
    };
    te({
      effect: "flip",
      swiper: t,
      on: a,
      setTranslate: () => {
        const {
          slides: e,
          rtlTranslate: s
        } = t, a = t.params.flipEffect;
        for (let r = 0; r < e.length; r += 1) {
          const n = e.eq(r);
          let l = n[0].progress;
          t.params.flipEffect.limitRotation && (l = Math.max(Math.min(n[0].progress, 1), -1));
          const o = n[0].swiperSlideOffset;
          let d = -180 * l,
            c = 0,
            p = t.params.cssMode ? -o - t.translate : -o,
            u = 0;
          t.isHorizontal() ? s && (d = -d) : (u = p, p = 0, c = -d, d = 0), n[0].style.zIndex = -Math.abs(Math.round(l)) + e.length, a.slideShadows && i(n, l, a);
          const h = `translate3d(${p}px, ${u}px, 0px) rotateX(${c}deg) rotateY(${d}deg)`;
          se(a, n).transform(h)
        }
      },
      setTransition: e => {
        const {
          transformEl: s
        } = t.params.flipEffect;
        (s ? t.slides.find(s) : t.slides).transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e), ae({
          swiper: t,
          duration: e,
          transformEl: s
        })
      },
      recreateShadows: () => {
        const e = t.params.flipEffect;
        t.slides.each((s => {
          const a = d(s);
          let r = a[0].progress;
          t.params.flipEffect.limitRotation && (r = Math.max(Math.min(s.progress, 1), -1)), i(a, r, e)
        }))
      },
      getEffectParams: () => t.params.flipEffect,
      perspective: () => !0,
      overwriteParams: () => ({
        slidesPerView: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: !0,
        spaceBetween: 0,
        virtualTranslate: !t.params.cssMode
      })
    })
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      on: a
    } = e;
    s({
      coverflowEffect: {
        rotate: 50,
        stretch: 0,
        depth: 100,
        scale: 1,
        modifier: 1,
        slideShadows: !0,
        transformEl: null
      }
    }), te({
      effect: "coverflow",
      swiper: t,
      on: a,
      setTranslate: () => {
        const {
          width: e,
          height: s,
          slides: a,
          slidesSizesGrid: i
        } = t, r = t.params.coverflowEffect, n = t.isHorizontal(), l = t.translate, o = n ? e / 2 - l : s / 2 - l, d = n ? r.rotate : -r.rotate, c = r.depth;
        for (let e = 0, t = a.length; e < t; e += 1) {
          const t = a.eq(e),
            s = i[e],
            l = (o - t[0].swiperSlideOffset - s / 2) / s,
            p = "function" == typeof r.modifier ? r.modifier(l) : l * r.modifier;
          let u = n ? d * p : 0,
            h = n ? 0 : d * p,
            m = -c * Math.abs(p),
            f = r.stretch;
          "string" == typeof f && -1 !== f.indexOf("%") && (f = parseFloat(r.stretch) / 100 * s);
          let g = n ? 0 : f * p,
            v = n ? f * p : 0,
            w = 1 - (1 - r.scale) * Math.abs(p);
          Math.abs(v) < .001 && (v = 0), Math.abs(g) < .001 && (g = 0), Math.abs(m) < .001 && (m = 0), Math.abs(u) < .001 && (u = 0), Math.abs(h) < .001 && (h = 0), Math.abs(w) < .001 && (w = 0);
          const b = `translate3d(${v}px,${g}px,${m}px)  rotateX(${h}deg) rotateY(${u}deg) scale(${w})`;
          if (se(r, t).transform(b), t[0].style.zIndex = 1 - Math.abs(Math.round(p)), r.slideShadows) {
            let e = n ? t.find(".swiper-slide-shadow-left") : t.find(".swiper-slide-shadow-top"),
              s = n ? t.find(".swiper-slide-shadow-right") : t.find(".swiper-slide-shadow-bottom");
            0 === e.length && (e = ie(r, t, n ? "left" : "top")), 0 === s.length && (s = ie(r, t, n ? "right" : "bottom")), e.length && (e[0].style.opacity = p > 0 ? p : 0), s.length && (s[0].style.opacity = -p > 0 ? -p : 0)
          }
        }
      },
      setTransition: e => {
        const {
          transformEl: s
        } = t.params.coverflowEffect;
        (s ? t.slides.find(s) : t.slides).transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e)
      },
      perspective: () => !0,
      overwriteParams: () => ({
        watchSlidesProgress: !0
      })
    })
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      on: a
    } = e;
    s({
      creativeEffect: {
        transformEl: null,
        limitProgress: 1,
        shadowPerProgress: !1,
        progressMultiplier: 1,
        perspective: !0,
        prev: {
          translate: [0, 0, 0],
          rotate: [0, 0, 0],
          opacity: 1,
          scale: 1
        },
        next: {
          translate: [0, 0, 0],
          rotate: [0, 0, 0],
          opacity: 1,
          scale: 1
        }
      }
    });
    const i = e => "string" == typeof e ? e : `${e}px`;
    te({
      effect: "creative",
      swiper: t,
      on: a,
      setTranslate: () => {
        const {
          slides: e,
          $wrapperEl: s,
          slidesSizesGrid: a
        } = t, r = t.params.creativeEffect, {
          progressMultiplier: n
        } = r, l = t.params.centeredSlides;
        if (l) {
          const e = a[0] / 2 - t.params.slidesOffsetBefore || 0;
          s.transform(`translateX(calc(50% - ${e}px))`)
        }
        for (let s = 0; s < e.length; s += 1) {
          const a = e.eq(s),
            o = a[0].progress,
            d = Math.min(Math.max(a[0].progress, -r.limitProgress), r.limitProgress);
          let c = d;
          l || (c = Math.min(Math.max(a[0].originalProgress, -r.limitProgress), r.limitProgress));
          const p = a[0].swiperSlideOffset,
            u = [t.params.cssMode ? -p - t.translate : -p, 0, 0],
            h = [0, 0, 0];
          let m = !1;
          t.isHorizontal() || (u[1] = u[0], u[0] = 0);
          let f = {
            translate: [0, 0, 0],
            rotate: [0, 0, 0],
            scale: 1,
            opacity: 1
          };
          d < 0 ? (f = r.next, m = !0) : d > 0 && (f = r.prev, m = !0), u.forEach(((e, t) => {
            u[t] = `calc(${e}px + (${i(f.translate[t])} * ${Math.abs(d*n)}))`
          })), h.forEach(((e, t) => {
            h[t] = f.rotate[t] * Math.abs(d * n)
          })), a[0].style.zIndex = -Math.abs(Math.round(o)) + e.length;
          const g = u.join(", "),
            v = `rotateX(${h[0]}deg) rotateY(${h[1]}deg) rotateZ(${h[2]}deg)`,
            w = c < 0 ? `scale(${1+(1-f.scale)*c*n})` : `scale(${1-(1-f.scale)*c*n})`,
            b = c < 0 ? 1 + (1 - f.opacity) * c * n : 1 - (1 - f.opacity) * c * n,
            x = `translate3d(${g}) ${v} ${w}`;
          if (m && f.shadow || !m) {
            let e = a.children(".swiper-slide-shadow");
            if (0 === e.length && f.shadow && (e = ie(r, a)), e.length) {
              const t = r.shadowPerProgress ? d * (1 / r.limitProgress) : d;
              e[0].style.opacity = Math.min(Math.max(Math.abs(t), 0), 1)
            }
          }
          const y = se(r, a);
          y.transform(x).css({
            opacity: b
          }), f.origin && y.css("transform-origin", f.origin)
        }
      },
      setTransition: e => {
        const {
          transformEl: s
        } = t.params.creativeEffect;
        (s ? t.slides.find(s) : t.slides).transition(e).find(".swiper-slide-shadow").transition(e), ae({
          swiper: t,
          duration: e,
          transformEl: s,
          allSlides: !0
        })
      },
      perspective: () => t.params.creativeEffect.perspective,
      overwriteParams: () => ({
        watchSlidesProgress: !0,
        virtualTranslate: !t.params.cssMode
      })
    })
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      on: a
    } = e;
    s({
      cardsEffect: {
        slideShadows: !0,
        transformEl: null,
        rotate: !0
      }
    }), te({
      effect: "cards",
      swiper: t,
      on: a,
      setTranslate: () => {
        const {
          slides: e,
          activeIndex: s
        } = t, a = t.params.cardsEffect, {
          startTranslate: i,
          isTouched: r
        } = t.touchEventsData, n = t.translate;
        for (let l = 0; l < e.length; l += 1) {
          const o = e.eq(l),
            d = o[0].progress,
            c = Math.min(Math.max(d, -4), 4);
          let p = o[0].swiperSlideOffset;
          t.params.centeredSlides && !t.params.cssMode && t.$wrapperEl.transform(`translateX(${t.minTranslate()}px)`), t.params.centeredSlides && t.params.cssMode && (p -= e[0].swiperSlideOffset);
          let u = t.params.cssMode ? -p - t.translate : -p,
            h = 0;
          const m = -100 * Math.abs(c);
          let f = 1,
            g = -2 * c,
            v = 8 - .75 * Math.abs(c);
          const w = t.virtual && t.params.virtual.enabled ? t.virtual.from + l : l,
            b = (w === s || w === s - 1) && c > 0 && c < 1 && (r || t.params.cssMode) && n < i,
            x = (w === s || w === s + 1) && c < 0 && c > -1 && (r || t.params.cssMode) && n > i;
          if (b || x) {
            const e = (1 - Math.abs((Math.abs(c) - .5) / .5)) ** .5;
            g += -28 * c * e, f += -.5 * e, v += 96 * e, h = -25 * e * Math.abs(c) + "%"
          }
          if (u = c < 0 ? `calc(${u}px + (${v*Math.abs(c)}%))` : c > 0 ? `calc(${u}px + (-${v*Math.abs(c)}%))` : `${u}px`, !t.isHorizontal()) {
            const e = h;
            h = u, u = e
          }
          const y = c < 0 ? "" + (1 + (1 - f) * c) : "" + (1 - (1 - f) * c),
            E = `\n        translate3d(${u}, ${h}, ${m}px)\n        rotateZ(${a.rotate?g:0}deg)\n        scale(${y})\n      `;
          if (a.slideShadows) {
            let e = o.find(".swiper-slide-shadow");
            0 === e.length && (e = ie(a, o)), e.length && (e[0].style.opacity = Math.min(Math.max((Math.abs(c) - .5) / .5, 0), 1))
          }
          o[0].style.zIndex = -Math.abs(Math.round(d)) + e.length;
          se(a, o).transform(E)
        }
      },
      setTransition: e => {
        const {
          transformEl: s
        } = t.params.cardsEffect;
        (s ? t.slides.find(s) : t.slides).transition(e).find(".swiper-slide-shadow").transition(e), ae({
          swiper: t,
          duration: e,
          transformEl: s
        })
      },
      perspective: () => !0,
      overwriteParams: () => ({
        watchSlidesProgress: !0,
        virtualTranslate: !t.params.cssMode
      })
    })
  }];
  return V.use(re), V
}));
//# sourceMappingURL=swiper-bundle.min.js.map
/*!
 * Bootstrap v5.2.0 (https://getbootstrap.com/)
 * Copyright 2011-2022 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 */
! function (t, e) {
  "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).bootstrap = e()
}(this, (function () {
  "use strict";
  const t = "transitionend",
    e = t => {
      let e = t.getAttribute("data-bs-target");
      if (!e || "#" === e) {
        let i = t.getAttribute("href");
        if (!i || !i.includes("#") && !i.startsWith(".")) return null;
        i.includes("#") && !i.startsWith("#") && (i = `#${i.split("#")[1]}`), e = i && "#" !== i ? i.trim() : null
      }
      return e
    },
    i = t => {
      const i = e(t);
      return i && document.querySelector(i) ? i : null
    },
    n = t => {
      const i = e(t);
      return i ? document.querySelector(i) : null
    },
    s = e => {
      e.dispatchEvent(new Event(t))
    },
    o = t => !(!t || "object" != typeof t) && (void 0 !== t.jquery && (t = t[0]), void 0 !== t.nodeType),
    r = t => o(t) ? t.jquery ? t[0] : t : "string" == typeof t && t.length > 0 ? document.querySelector(t) : null,
    a = t => {
      if (!o(t) || 0 === t.getClientRects().length) return !1;
      const e = "visible" === getComputedStyle(t).getPropertyValue("visibility"),
        i = t.closest("details:not([open])");
      if (!i) return e;
      if (i !== t) {
        const e = t.closest("summary");
        if (e && e.parentNode !== i) return !1;
        if (null === e) return !1
      }
      return e
    },
    l = t => !t || t.nodeType !== Node.ELEMENT_NODE || !!t.classList.contains("disabled") || (void 0 !== t.disabled ? t.disabled : t.hasAttribute("disabled") && "false" !== t.getAttribute("disabled")),
    c = t => {
      if (!document.documentElement.attachShadow) return null;
      if ("function" == typeof t.getRootNode) {
        const e = t.getRootNode();
        return e instanceof ShadowRoot ? e : null
      }
      return t instanceof ShadowRoot ? t : t.parentNode ? c(t.parentNode) : null
    },
    h = () => {},
    d = t => {
      t.offsetHeight
    },
    u = () => window.jQuery && !document.body.hasAttribute("data-bs-no-jquery") ? window.jQuery : null,
    f = [],
    p = () => "rtl" === document.documentElement.dir,
    g = t => {
      var e;
      e = () => {
        const e = u();
        if (e) {
          const i = t.NAME,
            n = e.fn[i];
          e.fn[i] = t.jQueryInterface, e.fn[i].Constructor = t, e.fn[i].noConflict = () => (e.fn[i] = n, t.jQueryInterface)
        }
      }, "loading" === document.readyState ? (f.length || document.addEventListener("DOMContentLoaded", (() => {
        for (const t of f) t()
      })), f.push(e)) : e()
    },
    m = t => {
      "function" == typeof t && t()
    },
    _ = (e, i, n = !0) => {
      if (!n) return void m(e);
      const o = (t => {
        if (!t) return 0;
        let {
          transitionDuration: e,
          transitionDelay: i
        } = window.getComputedStyle(t);
        const n = Number.parseFloat(e),
          s = Number.parseFloat(i);
        return n || s ? (e = e.split(",")[0], i = i.split(",")[0], 1e3 * (Number.parseFloat(e) + Number.parseFloat(i))) : 0
      })(i) + 5;
      let r = !1;
      const a = ({
        target: n
      }) => {
        n === i && (r = !0, i.removeEventListener(t, a), m(e))
      };
      i.addEventListener(t, a), setTimeout((() => {
        r || s(i)
      }), o)
    },
    b = (t, e, i, n) => {
      const s = t.length;
      let o = t.indexOf(e);
      return -1 === o ? !i && n ? t[s - 1] : t[0] : (o += i ? 1 : -1, n && (o = (o + s) % s), t[Math.max(0, Math.min(o, s - 1))])
    },
    v = /[^.]*(?=\..*)\.|.*/,
    y = /\..*/,
    w = /::\d+$/,
    A = {};
  let E = 1;
  const T = {
      mouseenter: "mouseover",
      mouseleave: "mouseout"
    },
    C = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);

  function O(t, e) {
    return e && `${e}::${E++}` || t.uidEvent || E++
  }

  function x(t) {
    const e = O(t);
    return t.uidEvent = e, A[e] = A[e] || {}, A[e]
  }

  function k(t, e, i = null) {
    return Object.values(t).find((t => t.callable === e && t.delegationSelector === i))
  }

  function L(t, e, i) {
    const n = "string" == typeof e,
      s = n ? i : e || i;
    let o = N(t);
    return C.has(o) || (o = t), [n, s, o]
  }

  function D(t, e, i, n, s) {
    if ("string" != typeof e || !t) return;
    let [o, r, a] = L(e, i, n);
    if (e in T) {
      const t = t => function (e) {
        if (!e.relatedTarget || e.relatedTarget !== e.delegateTarget && !e.delegateTarget.contains(e.relatedTarget)) return t.call(this, e)
      };
      r = t(r)
    }
    const l = x(t),
      c = l[a] || (l[a] = {}),
      h = k(c, r, o ? i : null);
    if (h) return void(h.oneOff = h.oneOff && s);
    const d = O(r, e.replace(v, "")),
      u = o ? function (t, e, i) {
        return function n(s) {
          const o = t.querySelectorAll(e);
          for (let {
              target: r
            } = s; r && r !== this; r = r.parentNode)
            for (const a of o)
              if (a === r) return j(s, {
                delegateTarget: r
              }), n.oneOff && P.off(t, s.type, e, i), i.apply(r, [s])
        }
      }(t, i, r) : function (t, e) {
        return function i(n) {
          return j(n, {
            delegateTarget: t
          }), i.oneOff && P.off(t, n.type, e), e.apply(t, [n])
        }
      }(t, r);
    u.delegationSelector = o ? i : null, u.callable = r, u.oneOff = s, u.uidEvent = d, c[d] = u, t.addEventListener(a, u, o)
  }

  function S(t, e, i, n, s) {
    const o = k(e[i], n, s);
    o && (t.removeEventListener(i, o, Boolean(s)), delete e[i][o.uidEvent])
  }

  function I(t, e, i, n) {
    const s = e[i] || {};
    for (const o of Object.keys(s))
      if (o.includes(n)) {
        const n = s[o];
        S(t, e, i, n.callable, n.delegationSelector)
      }
  }

  function N(t) {
    return t = t.replace(y, ""), T[t] || t
  }
  const P = {
    on(t, e, i, n) {
      D(t, e, i, n, !1)
    },
    one(t, e, i, n) {
      D(t, e, i, n, !0)
    },
    off(t, e, i, n) {
      if ("string" != typeof e || !t) return;
      const [s, o, r] = L(e, i, n), a = r !== e, l = x(t), c = l[r] || {}, h = e.startsWith(".");
      if (void 0 === o) {
        if (h)
          for (const i of Object.keys(l)) I(t, l, i, e.slice(1));
        for (const i of Object.keys(c)) {
          const n = i.replace(w, "");
          if (!a || e.includes(n)) {
            const e = c[i];
            S(t, l, r, e.callable, e.delegationSelector)
          }
        }
      } else {
        if (!Object.keys(c).length) return;
        S(t, l, r, o, s ? i : null)
      }
    },
    trigger(t, e, i) {
      if ("string" != typeof e || !t) return null;
      const n = u();
      let s = null,
        o = !0,
        r = !0,
        a = !1;
      e !== N(e) && n && (s = n.Event(e, i), n(t).trigger(s), o = !s.isPropagationStopped(), r = !s.isImmediatePropagationStopped(), a = s.isDefaultPrevented());
      let l = new Event(e, {
        bubbles: o,
        cancelable: !0
      });
      return l = j(l, i), a && l.preventDefault(), r && t.dispatchEvent(l), l.defaultPrevented && s && s.preventDefault(), l
    }
  };

  function j(t, e) {
    for (const [i, n] of Object.entries(e || {})) try {
      t[i] = n
    } catch (e) {
      Object.defineProperty(t, i, {
        configurable: !0,
        get: () => n
      })
    }
    return t
  }
  const M = new Map,
    H = {
      set(t, e, i) {
        M.has(t) || M.set(t, new Map);
        const n = M.get(t);
        n.has(e) || 0 === n.size ? n.set(e, i) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(n.keys())[0]}.`)
      },
      get: (t, e) => M.has(t) && M.get(t).get(e) || null,
      remove(t, e) {
        if (!M.has(t)) return;
        const i = M.get(t);
        i.delete(e), 0 === i.size && M.delete(t)
      }
    };

  function $(t) {
    if ("true" === t) return !0;
    if ("false" === t) return !1;
    if (t === Number(t).toString()) return Number(t);
    if ("" === t || "null" === t) return null;
    if ("string" != typeof t) return t;
    try {
      return JSON.parse(decodeURIComponent(t))
    } catch (e) {
      return t
    }
  }

  function W(t) {
    return t.replace(/[A-Z]/g, (t => `-${t.toLowerCase()}`))
  }
  const B = {
    setDataAttribute(t, e, i) {
      t.setAttribute(`data-bs-${W(e)}`, i)
    },
    removeDataAttribute(t, e) {
      t.removeAttribute(`data-bs-${W(e)}`)
    },
    getDataAttributes(t) {
      if (!t) return {};
      const e = {},
        i = Object.keys(t.dataset).filter((t => t.startsWith("bs") && !t.startsWith("bsConfig")));
      for (const n of i) {
        let i = n.replace(/^bs/, "");
        i = i.charAt(0).toLowerCase() + i.slice(1, i.length), e[i] = $(t.dataset[n])
      }
      return e
    },
    getDataAttribute: (t, e) => $(t.getAttribute(`data-bs-${W(e)}`))
  };
  class F {
    static get Default() {
      return {}
    }
    static get DefaultType() {
      return {}
    }
    static get NAME() {
      throw new Error('You have to implement the static method "NAME", for each component!')
    }
    _getConfig(t) {
      return t = this._mergeConfigObj(t), t = this._configAfterMerge(t), this._typeCheckConfig(t), t
    }
    _configAfterMerge(t) {
      return t
    }
    _mergeConfigObj(t, e) {
      const i = o(e) ? B.getDataAttribute(e, "config") : {};
      return {
        ...this.constructor.Default,
        ..."object" == typeof i ? i : {},
        ...o(e) ? B.getDataAttributes(e) : {},
        ..."object" == typeof t ? t : {}
      }
    }
    _typeCheckConfig(t, e = this.constructor.DefaultType) {
      for (const n of Object.keys(e)) {
        const s = e[n],
          r = t[n],
          a = o(r) ? "element" : null == (i = r) ? `${i}` : Object.prototype.toString.call(i).match(/\s([a-z]+)/i)[1].toLowerCase();
        if (!new RegExp(s).test(a)) throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${n}" provided type "${a}" but expected type "${s}".`)
      }
      var i
    }
  }
  class z extends F {
    constructor(t, e) {
      super(), (t = r(t)) && (this._element = t, this._config = this._getConfig(e), H.set(this._element, this.constructor.DATA_KEY, this))
    }
    dispose() {
      H.remove(this._element, this.constructor.DATA_KEY), P.off(this._element, this.constructor.EVENT_KEY);
      for (const t of Object.getOwnPropertyNames(this)) this[t] = null
    }
    _queueCallback(t, e, i = !0) {
      _(t, e, i)
    }
    _getConfig(t) {
      return t = this._mergeConfigObj(t, this._element), t = this._configAfterMerge(t), this._typeCheckConfig(t), t
    }
    static getInstance(t) {
      return H.get(r(t), this.DATA_KEY)
    }
    static getOrCreateInstance(t, e = {}) {
      return this.getInstance(t) || new this(t, "object" == typeof e ? e : null)
    }
    static get VERSION() {
      return "5.2.0"
    }
    static get DATA_KEY() {
      return `bs.${this.NAME}`
    }
    static get EVENT_KEY() {
      return `.${this.DATA_KEY}`
    }
    static eventName(t) {
      return `${t}${this.EVENT_KEY}`
    }
  }
  const R = (t, e = "hide") => {
    const i = `click.dismiss${t.EVENT_KEY}`,
      s = t.NAME;
    P.on(document, i, `[data-bs-dismiss="${s}"]`, (function (i) {
      if (["A", "AREA"].includes(this.tagName) && i.preventDefault(), l(this)) return;
      const o = n(this) || this.closest(`.${s}`);
      t.getOrCreateInstance(o)[e]()
    }))
  };
  class q extends z {
    static get NAME() {
      return "alert"
    }
    close() {
      if (P.trigger(this._element, "close.bs.alert").defaultPrevented) return;
      this._element.classList.remove("show");
      const t = this._element.classList.contains("fade");
      this._queueCallback((() => this._destroyElement()), this._element, t)
    }
    _destroyElement() {
      this._element.remove(), P.trigger(this._element, "closed.bs.alert"), this.dispose()
    }
    static jQueryInterface(t) {
      return this.each((function () {
        const e = q.getOrCreateInstance(this);
        if ("string" == typeof t) {
          if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
          e[t](this)
        }
      }))
    }
  }
  R(q, "close"), g(q);
  const V = '[data-bs-toggle="button"]';
  class K extends z {
    static get NAME() {
      return "button"
    }
    toggle() {
      this._element.setAttribute("aria-pressed", this._element.classList.toggle("active"))
    }
    static jQueryInterface(t) {
      return this.each((function () {
        const e = K.getOrCreateInstance(this);
        "toggle" === t && e[t]()
      }))
    }
  }
  P.on(document, "click.bs.button.data-api", V, (t => {
    t.preventDefault();
    const e = t.target.closest(V);
    K.getOrCreateInstance(e).toggle()
  })), g(K);
  const Q = {
      find: (t, e = document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(e, t)),
      findOne: (t, e = document.documentElement) => Element.prototype.querySelector.call(e, t),
      children: (t, e) => [].concat(...t.children).filter((t => t.matches(e))),
      parents(t, e) {
        const i = [];
        let n = t.parentNode.closest(e);
        for (; n;) i.push(n), n = n.parentNode.closest(e);
        return i
      },
      prev(t, e) {
        let i = t.previousElementSibling;
        for (; i;) {
          if (i.matches(e)) return [i];
          i = i.previousElementSibling
        }
        return []
      },
      next(t, e) {
        let i = t.nextElementSibling;
        for (; i;) {
          if (i.matches(e)) return [i];
          i = i.nextElementSibling
        }
        return []
      },
      focusableChildren(t) {
        const e = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map((t => `${t}:not([tabindex^="-"])`)).join(",");
        return this.find(e, t).filter((t => !l(t) && a(t)))
      }
    },
    X = {
      endCallback: null,
      leftCallback: null,
      rightCallback: null
    },
    Y = {
      endCallback: "(function|null)",
      leftCallback: "(function|null)",
      rightCallback: "(function|null)"
    };
  class U extends F {
    constructor(t, e) {
      super(), this._element = t, t && U.isSupported() && (this._config = this._getConfig(e), this._deltaX = 0, this._supportPointerEvents = Boolean(window.PointerEvent), this._initEvents())
    }
    static get Default() {
      return X
    }
    static get DefaultType() {
      return Y
    }
    static get NAME() {
      return "swipe"
    }
    dispose() {
      P.off(this._element, ".bs.swipe")
    }
    _start(t) {
      this._supportPointerEvents ? this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX) : this._deltaX = t.touches[0].clientX
    }
    _end(t) {
      this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX - this._deltaX), this._handleSwipe(), m(this._config.endCallback)
    }
    _move(t) {
      this._deltaX = t.touches && t.touches.length > 1 ? 0 : t.touches[0].clientX - this._deltaX
    }
    _handleSwipe() {
      const t = Math.abs(this._deltaX);
      if (t <= 40) return;
      const e = t / this._deltaX;
      this._deltaX = 0, e && m(e > 0 ? this._config.rightCallback : this._config.leftCallback)
    }
    _initEvents() {
      this._supportPointerEvents ? (P.on(this._element, "pointerdown.bs.swipe", (t => this._start(t))), P.on(this._element, "pointerup.bs.swipe", (t => this._end(t))), this._element.classList.add("pointer-event")) : (P.on(this._element, "touchstart.bs.swipe", (t => this._start(t))), P.on(this._element, "touchmove.bs.swipe", (t => this._move(t))), P.on(this._element, "touchend.bs.swipe", (t => this._end(t))))
    }
    _eventIsPointerPenTouch(t) {
      return this._supportPointerEvents && ("pen" === t.pointerType || "touch" === t.pointerType)
    }
    static isSupported() {
      return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0
    }
  }
  const G = "next",
    J = "prev",
    Z = "left",
    tt = "right",
    et = "slid.bs.carousel",
    it = "carousel",
    nt = "active",
    st = {
      ArrowLeft: tt,
      ArrowRight: Z
    },
    ot = {
      interval: 5e3,
      keyboard: !0,
      pause: "hover",
      ride: !1,
      touch: !0,
      wrap: !0
    },
    rt = {
      interval: "(number|boolean)",
      keyboard: "boolean",
      pause: "(string|boolean)",
      ride: "(boolean|string)",
      touch: "boolean",
      wrap: "boolean"
    };
  class at extends z {
    constructor(t, e) {
      super(t, e), this._interval = null, this._activeElement = null, this._isSliding = !1, this.touchTimeout = null, this._swipeHelper = null, this._indicatorsElement = Q.findOne(".carousel-indicators", this._element), this._addEventListeners(), this._config.ride === it && this.cycle()
    }
    static get Default() {
      return ot
    }
    static get DefaultType() {
      return rt
    }
    static get NAME() {
      return "carousel"
    }
    next() {
      this._slide(G)
    }
    nextWhenVisible() {
      !document.hidden && a(this._element) && this.next()
    }
    prev() {
      this._slide(J)
    }
    pause() {
      this._isSliding && s(this._element), this._clearInterval()
    }
    cycle() {
      this._clearInterval(), this._updateInterval(), this._interval = setInterval((() => this.nextWhenVisible()), this._config.interval)
    }
    _maybeEnableCycle() {
      this._config.ride && (this._isSliding ? P.one(this._element, et, (() => this.cycle())) : this.cycle())
    }
    to(t) {
      const e = this._getItems();
      if (t > e.length - 1 || t < 0) return;
      if (this._isSliding) return void P.one(this._element, et, (() => this.to(t)));
      const i = this._getItemIndex(this._getActive());
      if (i === t) return;
      const n = t > i ? G : J;
      this._slide(n, e[t])
    }
    dispose() {
      this._swipeHelper && this._swipeHelper.dispose(), super.dispose()
    }
    _configAfterMerge(t) {
      return t.defaultInterval = t.interval, t
    }
    _addEventListeners() {
      this._config.keyboard && P.on(this._element, "keydown.bs.carousel", (t => this._keydown(t))), "hover" === this._config.pause && (P.on(this._element, "mouseenter.bs.carousel", (() => this.pause())), P.on(this._element, "mouseleave.bs.carousel", (() => this._maybeEnableCycle()))), this._config.touch && U.isSupported() && this._addTouchEventListeners()
    }
    _addTouchEventListeners() {
      for (const t of Q.find(".carousel-item img", this._element)) P.on(t, "dragstart.bs.carousel", (t => t.preventDefault()));
      const t = {
        leftCallback: () => this._slide(this._directionToOrder(Z)),
        rightCallback: () => this._slide(this._directionToOrder(tt)),
        endCallback: () => {
          "hover" === this._config.pause && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout((() => this._maybeEnableCycle()), 500 + this._config.interval))
        }
      };
      this._swipeHelper = new U(this._element, t)
    }
    _keydown(t) {
      if (/input|textarea/i.test(t.target.tagName)) return;
      const e = st[t.key];
      e && (t.preventDefault(), this._slide(this._directionToOrder(e)))
    }
    _getItemIndex(t) {
      return this._getItems().indexOf(t)
    }
    _setActiveIndicatorElement(t) {
      if (!this._indicatorsElement) return;
      const e = Q.findOne(".active", this._indicatorsElement);
      e.classList.remove(nt), e.removeAttribute("aria-current");
      const i = Q.findOne(`[data-bs-slide-to="${t}"]`, this._indicatorsElement);
      i && (i.classList.add(nt), i.setAttribute("aria-current", "true"))
    }
    _updateInterval() {
      const t = this._activeElement || this._getActive();
      if (!t) return;
      const e = Number.parseInt(t.getAttribute("data-bs-interval"), 10);
      this._config.interval = e || this._config.defaultInterval
    }
    _slide(t, e = null) {
      if (this._isSliding) return;
      const i = this._getActive(),
        n = t === G,
        s = e || b(this._getItems(), i, n, this._config.wrap);
      if (s === i) return;
      const o = this._getItemIndex(s),
        r = e => P.trigger(this._element, e, {
          relatedTarget: s,
          direction: this._orderToDirection(t),
          from: this._getItemIndex(i),
          to: o
        });
      if (r("slide.bs.carousel").defaultPrevented) return;
      if (!i || !s) return;
      const a = Boolean(this._interval);
      this.pause(), this._isSliding = !0, this._setActiveIndicatorElement(o), this._activeElement = s;
      const l = n ? "carousel-item-start" : "carousel-item-end",
        c = n ? "carousel-item-next" : "carousel-item-prev";
      s.classList.add(c), d(s), i.classList.add(l), s.classList.add(l), this._queueCallback((() => {
        s.classList.remove(l, c), s.classList.add(nt), i.classList.remove(nt, c, l), this._isSliding = !1, r(et)
      }), i, this._isAnimated()), a && this.cycle()
    }
    _isAnimated() {
      return this._element.classList.contains("slide")
    }
    _getActive() {
      return Q.findOne(".active.carousel-item", this._element)
    }
    _getItems() {
      return Q.find(".carousel-item", this._element)
    }
    _clearInterval() {
      this._interval && (clearInterval(this._interval), this._interval = null)
    }
    _directionToOrder(t) {
      return p() ? t === Z ? J : G : t === Z ? G : J
    }
    _orderToDirection(t) {
      return p() ? t === J ? Z : tt : t === J ? tt : Z
    }
    static jQueryInterface(t) {
      return this.each((function () {
        const e = at.getOrCreateInstance(this, t);
        if ("number" != typeof t) {
          if ("string" == typeof t) {
            if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
            e[t]()
          }
        } else e.to(t)
      }))
    }
  }
  P.on(document, "click.bs.carousel.data-api", "[data-bs-slide], [data-bs-slide-to]", (function (t) {
    const e = n(this);
    if (!e || !e.classList.contains(it)) return;
    t.preventDefault();
    const i = at.getOrCreateInstance(e),
      s = this.getAttribute("data-bs-slide-to");
    return s ? (i.to(s), void i._maybeEnableCycle()) : "next" === B.getDataAttribute(this, "slide") ? (i.next(), void i._maybeEnableCycle()) : (i.prev(), void i._maybeEnableCycle())
  })), P.on(window, "load.bs.carousel.data-api", (() => {
    const t = Q.find('[data-bs-ride="carousel"]');
    for (const e of t) at.getOrCreateInstance(e)
  })), g(at);
  const lt = "show",
    ct = "collapse",
    ht = "collapsing",
    dt = '[data-bs-toggle="collapse"]',
    ut = {
      parent: null,
      toggle: !0
    },
    ft = {
      parent: "(null|element)",
      toggle: "boolean"
    };
  class pt extends z {
    constructor(t, e) {
      super(t, e), this._isTransitioning = !1, this._triggerArray = [];
      const n = Q.find(dt);
      for (const t of n) {
        const e = i(t),
          n = Q.find(e).filter((t => t === this._element));
        null !== e && n.length && this._triggerArray.push(t)
      }
      this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle()
    }
    static get Default() {
      return ut
    }
    static get DefaultType() {
      return ft
    }
    static get NAME() {
      return "collapse"
    }
    toggle() {
      this._isShown() ? this.hide() : this.show()
    }
    show() {
      if (this._isTransitioning || this._isShown()) return;
      let t = [];
      if (this._config.parent && (t = this._getFirstLevelChildren(".collapse.show, .collapse.collapsing").filter((t => t !== this._element)).map((t => pt.getOrCreateInstance(t, {
          toggle: !1
        })))), t.length && t[0]._isTransitioning) return;
      if (P.trigger(this._element, "show.bs.collapse").defaultPrevented) return;
      for (const e of t) e.hide();
      const e = this._getDimension();
      this._element.classList.remove(ct), this._element.classList.add(ht), this._element.style[e] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0;
      const i = `scroll${e[0].toUpperCase()+e.slice(1)}`;
      this._queueCallback((() => {
        this._isTransitioning = !1, this._element.classList.remove(ht), this._element.classList.add(ct, lt), this._element.style[e] = "", P.trigger(this._element, "shown.bs.collapse")
      }), this._element, !0), this._element.style[e] = `${this._element[i]}px`
    }
    hide() {
      if (this._isTransitioning || !this._isShown()) return;
      if (P.trigger(this._element, "hide.bs.collapse").defaultPrevented) return;
      const t = this._getDimension();
      this._element.style[t] = `${this._element.getBoundingClientRect()[t]}px`, d(this._element), this._element.classList.add(ht), this._element.classList.remove(ct, lt);
      for (const t of this._triggerArray) {
        const e = n(t);
        e && !this._isShown(e) && this._addAriaAndCollapsedClass([t], !1)
      }
      this._isTransitioning = !0, this._element.style[t] = "", this._queueCallback((() => {
        this._isTransitioning = !1, this._element.classList.remove(ht), this._element.classList.add(ct), P.trigger(this._element, "hidden.bs.collapse")
      }), this._element, !0)
    }
    _isShown(t = this._element) {
      return t.classList.contains(lt)
    }
    _configAfterMerge(t) {
      return t.toggle = Boolean(t.toggle), t.parent = r(t.parent), t
    }
    _getDimension() {
      return this._element.classList.contains("collapse-horizontal") ? "width" : "height"
    }
    _initializeChildren() {
      if (!this._config.parent) return;
      const t = this._getFirstLevelChildren(dt);
      for (const e of t) {
        const t = n(e);
        t && this._addAriaAndCollapsedClass([e], this._isShown(t))
      }
    }
    _getFirstLevelChildren(t) {
      const e = Q.find(":scope .collapse .collapse", this._config.parent);
      return Q.find(t, this._config.parent).filter((t => !e.includes(t)))
    }
    _addAriaAndCollapsedClass(t, e) {
      if (t.length)
        for (const i of t) i.classList.toggle("collapsed", !e), i.setAttribute("aria-expanded", e)
    }
    static jQueryInterface(t) {
      const e = {};
      return "string" == typeof t && /show|hide/.test(t) && (e.toggle = !1), this.each((function () {
        const i = pt.getOrCreateInstance(this, e);
        if ("string" == typeof t) {
          if (void 0 === i[t]) throw new TypeError(`No method named "${t}"`);
          i[t]()
        }
      }))
    }
  }
  P.on(document, "click.bs.collapse.data-api", dt, (function (t) {
    ("A" === t.target.tagName || t.delegateTarget && "A" === t.delegateTarget.tagName) && t.preventDefault();
    const e = i(this),
      n = Q.find(e);
    for (const t of n) pt.getOrCreateInstance(t, {
      toggle: !1
    }).toggle()
  })), g(pt);
  var gt = "top",
    mt = "bottom",
    _t = "right",
    bt = "left",
    vt = "auto",
    yt = [gt, mt, _t, bt],
    wt = "start",
    At = "end",
    Et = "clippingParents",
    Tt = "viewport",
    Ct = "popper",
    Ot = "reference",
    xt = yt.reduce((function (t, e) {
      return t.concat([e + "-" + wt, e + "-" + At])
    }), []),
    kt = [].concat(yt, [vt]).reduce((function (t, e) {
      return t.concat([e, e + "-" + wt, e + "-" + At])
    }), []),
    Lt = "beforeRead",
    Dt = "read",
    St = "afterRead",
    It = "beforeMain",
    Nt = "main",
    Pt = "afterMain",
    jt = "beforeWrite",
    Mt = "write",
    Ht = "afterWrite",
    $t = [Lt, Dt, St, It, Nt, Pt, jt, Mt, Ht];

  function Wt(t) {
    return t ? (t.nodeName || "").toLowerCase() : null
  }

  function Bt(t) {
    if (null == t) return window;
    if ("[object Window]" !== t.toString()) {
      var e = t.ownerDocument;
      return e && e.defaultView || window
    }
    return t
  }

  function Ft(t) {
    return t instanceof Bt(t).Element || t instanceof Element
  }

  function zt(t) {
    return t instanceof Bt(t).HTMLElement || t instanceof HTMLElement
  }

  function Rt(t) {
    return "undefined" != typeof ShadowRoot && (t instanceof Bt(t).ShadowRoot || t instanceof ShadowRoot)
  }
  const qt = {
    name: "applyStyles",
    enabled: !0,
    phase: "write",
    fn: function (t) {
      var e = t.state;
      Object.keys(e.elements).forEach((function (t) {
        var i = e.styles[t] || {},
          n = e.attributes[t] || {},
          s = e.elements[t];
        zt(s) && Wt(s) && (Object.assign(s.style, i), Object.keys(n).forEach((function (t) {
          var e = n[t];
          !1 === e ? s.removeAttribute(t) : s.setAttribute(t, !0 === e ? "" : e)
        })))
      }))
    },
    effect: function (t) {
      var e = t.state,
        i = {
          popper: {
            position: e.options.strategy,
            left: "0",
            top: "0",
            margin: "0"
          },
          arrow: {
            position: "absolute"
          },
          reference: {}
        };
      return Object.assign(e.elements.popper.style, i.popper), e.styles = i, e.elements.arrow && Object.assign(e.elements.arrow.style, i.arrow),
        function () {
          Object.keys(e.elements).forEach((function (t) {
            var n = e.elements[t],
              s = e.attributes[t] || {},
              o = Object.keys(e.styles.hasOwnProperty(t) ? e.styles[t] : i[t]).reduce((function (t, e) {
                return t[e] = "", t
              }), {});
            zt(n) && Wt(n) && (Object.assign(n.style, o), Object.keys(s).forEach((function (t) {
              n.removeAttribute(t)
            })))
          }))
        }
    },
    requires: ["computeStyles"]
  };

  function Vt(t) {
    return t.split("-")[0]
  }
  var Kt = Math.max,
    Qt = Math.min,
    Xt = Math.round;

  function Yt(t, e) {
    void 0 === e && (e = !1);
    var i = t.getBoundingClientRect(),
      n = 1,
      s = 1;
    if (zt(t) && e) {
      var o = t.offsetHeight,
        r = t.offsetWidth;
      r > 0 && (n = Xt(i.width) / r || 1), o > 0 && (s = Xt(i.height) / o || 1)
    }
    return {
      width: i.width / n,
      height: i.height / s,
      top: i.top / s,
      right: i.right / n,
      bottom: i.bottom / s,
      left: i.left / n,
      x: i.left / n,
      y: i.top / s
    }
  }

  function Ut(t) {
    var e = Yt(t),
      i = t.offsetWidth,
      n = t.offsetHeight;
    return Math.abs(e.width - i) <= 1 && (i = e.width), Math.abs(e.height - n) <= 1 && (n = e.height), {
      x: t.offsetLeft,
      y: t.offsetTop,
      width: i,
      height: n
    }
  }

  function Gt(t, e) {
    var i = e.getRootNode && e.getRootNode();
    if (t.contains(e)) return !0;
    if (i && Rt(i)) {
      var n = e;
      do {
        if (n && t.isSameNode(n)) return !0;
        n = n.parentNode || n.host
      } while (n)
    }
    return !1
  }

  function Jt(t) {
    return Bt(t).getComputedStyle(t)
  }

  function Zt(t) {
    return ["table", "td", "th"].indexOf(Wt(t)) >= 0
  }

  function te(t) {
    return ((Ft(t) ? t.ownerDocument : t.document) || window.document).documentElement
  }

  function ee(t) {
    return "html" === Wt(t) ? t : t.assignedSlot || t.parentNode || (Rt(t) ? t.host : null) || te(t)
  }

  function ie(t) {
    return zt(t) && "fixed" !== Jt(t).position ? t.offsetParent : null
  }

  function ne(t) {
    for (var e = Bt(t), i = ie(t); i && Zt(i) && "static" === Jt(i).position;) i = ie(i);
    return i && ("html" === Wt(i) || "body" === Wt(i) && "static" === Jt(i).position) ? e : i || function (t) {
      var e = -1 !== navigator.userAgent.toLowerCase().indexOf("firefox");
      if (-1 !== navigator.userAgent.indexOf("Trident") && zt(t) && "fixed" === Jt(t).position) return null;
      var i = ee(t);
      for (Rt(i) && (i = i.host); zt(i) && ["html", "body"].indexOf(Wt(i)) < 0;) {
        var n = Jt(i);
        if ("none" !== n.transform || "none" !== n.perspective || "paint" === n.contain || -1 !== ["transform", "perspective"].indexOf(n.willChange) || e && "filter" === n.willChange || e && n.filter && "none" !== n.filter) return i;
        i = i.parentNode
      }
      return null
    }(t) || e
  }

  function se(t) {
    return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y"
  }

  function oe(t, e, i) {
    return Kt(t, Qt(e, i))
  }

  function re(t) {
    return Object.assign({}, {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }, t)
  }

  function ae(t, e) {
    return e.reduce((function (e, i) {
      return e[i] = t, e
    }), {})
  }
  const le = {
    name: "arrow",
    enabled: !0,
    phase: "main",
    fn: function (t) {
      var e, i = t.state,
        n = t.name,
        s = t.options,
        o = i.elements.arrow,
        r = i.modifiersData.popperOffsets,
        a = Vt(i.placement),
        l = se(a),
        c = [bt, _t].indexOf(a) >= 0 ? "height" : "width";
      if (o && r) {
        var h = function (t, e) {
            return re("number" != typeof (t = "function" == typeof t ? t(Object.assign({}, e.rects, {
              placement: e.placement
            })) : t) ? t : ae(t, yt))
          }(s.padding, i),
          d = Ut(o),
          u = "y" === l ? gt : bt,
          f = "y" === l ? mt : _t,
          p = i.rects.reference[c] + i.rects.reference[l] - r[l] - i.rects.popper[c],
          g = r[l] - i.rects.reference[l],
          m = ne(o),
          _ = m ? "y" === l ? m.clientHeight || 0 : m.clientWidth || 0 : 0,
          b = p / 2 - g / 2,
          v = h[u],
          y = _ - d[c] - h[f],
          w = _ / 2 - d[c] / 2 + b,
          A = oe(v, w, y),
          E = l;
        i.modifiersData[n] = ((e = {})[E] = A, e.centerOffset = A - w, e)
      }
    },
    effect: function (t) {
      var e = t.state,
        i = t.options.element,
        n = void 0 === i ? "[data-popper-arrow]" : i;
      null != n && ("string" != typeof n || (n = e.elements.popper.querySelector(n))) && Gt(e.elements.popper, n) && (e.elements.arrow = n)
    },
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
  };

  function ce(t) {
    return t.split("-")[1]
  }
  var he = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };

  function de(t) {
    var e, i = t.popper,
      n = t.popperRect,
      s = t.placement,
      o = t.variation,
      r = t.offsets,
      a = t.position,
      l = t.gpuAcceleration,
      c = t.adaptive,
      h = t.roundOffsets,
      d = t.isFixed,
      u = r.x,
      f = void 0 === u ? 0 : u,
      p = r.y,
      g = void 0 === p ? 0 : p,
      m = "function" == typeof h ? h({
        x: f,
        y: g
      }) : {
        x: f,
        y: g
      };
    f = m.x, g = m.y;
    var _ = r.hasOwnProperty("x"),
      b = r.hasOwnProperty("y"),
      v = bt,
      y = gt,
      w = window;
    if (c) {
      var A = ne(i),
        E = "clientHeight",
        T = "clientWidth";
      A === Bt(i) && "static" !== Jt(A = te(i)).position && "absolute" === a && (E = "scrollHeight", T = "scrollWidth"), (s === gt || (s === bt || s === _t) && o === At) && (y = mt, g -= (d && A === w && w.visualViewport ? w.visualViewport.height : A[E]) - n.height, g *= l ? 1 : -1), s !== bt && (s !== gt && s !== mt || o !== At) || (v = _t, f -= (d && A === w && w.visualViewport ? w.visualViewport.width : A[T]) - n.width, f *= l ? 1 : -1)
    }
    var C, O = Object.assign({
        position: a
      }, c && he),
      x = !0 === h ? function (t) {
        var e = t.x,
          i = t.y,
          n = window.devicePixelRatio || 1;
        return {
          x: Xt(e * n) / n || 0,
          y: Xt(i * n) / n || 0
        }
      }({
        x: f,
        y: g
      }) : {
        x: f,
        y: g
      };
    return f = x.x, g = x.y, l ? Object.assign({}, O, ((C = {})[y] = b ? "0" : "", C[v] = _ ? "0" : "", C.transform = (w.devicePixelRatio || 1) <= 1 ? "translate(" + f + "px, " + g + "px)" : "translate3d(" + f + "px, " + g + "px, 0)", C)) : Object.assign({}, O, ((e = {})[y] = b ? g + "px" : "", e[v] = _ ? f + "px" : "", e.transform = "", e))
  }
  const ue = {
    name: "computeStyles",
    enabled: !0,
    phase: "beforeWrite",
    fn: function (t) {
      var e = t.state,
        i = t.options,
        n = i.gpuAcceleration,
        s = void 0 === n || n,
        o = i.adaptive,
        r = void 0 === o || o,
        a = i.roundOffsets,
        l = void 0 === a || a,
        c = {
          placement: Vt(e.placement),
          variation: ce(e.placement),
          popper: e.elements.popper,
          popperRect: e.rects.popper,
          gpuAcceleration: s,
          isFixed: "fixed" === e.options.strategy
        };
      null != e.modifiersData.popperOffsets && (e.styles.popper = Object.assign({}, e.styles.popper, de(Object.assign({}, c, {
        offsets: e.modifiersData.popperOffsets,
        position: e.options.strategy,
        adaptive: r,
        roundOffsets: l
      })))), null != e.modifiersData.arrow && (e.styles.arrow = Object.assign({}, e.styles.arrow, de(Object.assign({}, c, {
        offsets: e.modifiersData.arrow,
        position: "absolute",
        adaptive: !1,
        roundOffsets: l
      })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
        "data-popper-placement": e.placement
      })
    },
    data: {}
  };
  var fe = {
    passive: !0
  };
  const pe = {
    name: "eventListeners",
    enabled: !0,
    phase: "write",
    fn: function () {},
    effect: function (t) {
      var e = t.state,
        i = t.instance,
        n = t.options,
        s = n.scroll,
        o = void 0 === s || s,
        r = n.resize,
        a = void 0 === r || r,
        l = Bt(e.elements.popper),
        c = [].concat(e.scrollParents.reference, e.scrollParents.popper);
      return o && c.forEach((function (t) {
          t.addEventListener("scroll", i.update, fe)
        })), a && l.addEventListener("resize", i.update, fe),
        function () {
          o && c.forEach((function (t) {
            t.removeEventListener("scroll", i.update, fe)
          })), a && l.removeEventListener("resize", i.update, fe)
        }
    },
    data: {}
  };
  var ge = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };

  function me(t) {
    return t.replace(/left|right|bottom|top/g, (function (t) {
      return ge[t]
    }))
  }
  var _e = {
    start: "end",
    end: "start"
  };

  function be(t) {
    return t.replace(/start|end/g, (function (t) {
      return _e[t]
    }))
  }

  function ve(t) {
    var e = Bt(t);
    return {
      scrollLeft: e.pageXOffset,
      scrollTop: e.pageYOffset
    }
  }

  function ye(t) {
    return Yt(te(t)).left + ve(t).scrollLeft
  }

  function we(t) {
    var e = Jt(t),
      i = e.overflow,
      n = e.overflowX,
      s = e.overflowY;
    return /auto|scroll|overlay|hidden/.test(i + s + n)
  }

  function Ae(t) {
    return ["html", "body", "#document"].indexOf(Wt(t)) >= 0 ? t.ownerDocument.body : zt(t) && we(t) ? t : Ae(ee(t))
  }

  function Ee(t, e) {
    var i;
    void 0 === e && (e = []);
    var n = Ae(t),
      s = n === (null == (i = t.ownerDocument) ? void 0 : i.body),
      o = Bt(n),
      r = s ? [o].concat(o.visualViewport || [], we(n) ? n : []) : n,
      a = e.concat(r);
    return s ? a : a.concat(Ee(ee(r)))
  }

  function Te(t) {
    return Object.assign({}, t, {
      left: t.x,
      top: t.y,
      right: t.x + t.width,
      bottom: t.y + t.height
    })
  }

  function Ce(t, e) {
    return e === Tt ? Te(function (t) {
      var e = Bt(t),
        i = te(t),
        n = e.visualViewport,
        s = i.clientWidth,
        o = i.clientHeight,
        r = 0,
        a = 0;
      return n && (s = n.width, o = n.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (r = n.offsetLeft, a = n.offsetTop)), {
        width: s,
        height: o,
        x: r + ye(t),
        y: a
      }
    }(t)) : Ft(e) ? function (t) {
      var e = Yt(t);
      return e.top = e.top + t.clientTop, e.left = e.left + t.clientLeft, e.bottom = e.top + t.clientHeight, e.right = e.left + t.clientWidth, e.width = t.clientWidth, e.height = t.clientHeight, e.x = e.left, e.y = e.top, e
    }(e) : Te(function (t) {
      var e, i = te(t),
        n = ve(t),
        s = null == (e = t.ownerDocument) ? void 0 : e.body,
        o = Kt(i.scrollWidth, i.clientWidth, s ? s.scrollWidth : 0, s ? s.clientWidth : 0),
        r = Kt(i.scrollHeight, i.clientHeight, s ? s.scrollHeight : 0, s ? s.clientHeight : 0),
        a = -n.scrollLeft + ye(t),
        l = -n.scrollTop;
      return "rtl" === Jt(s || i).direction && (a += Kt(i.clientWidth, s ? s.clientWidth : 0) - o), {
        width: o,
        height: r,
        x: a,
        y: l
      }
    }(te(t)))
  }

  function Oe(t) {
    var e, i = t.reference,
      n = t.element,
      s = t.placement,
      o = s ? Vt(s) : null,
      r = s ? ce(s) : null,
      a = i.x + i.width / 2 - n.width / 2,
      l = i.y + i.height / 2 - n.height / 2;
    switch (o) {
      case gt:
        e = {
          x: a,
          y: i.y - n.height
        };
        break;
      case mt:
        e = {
          x: a,
          y: i.y + i.height
        };
        break;
      case _t:
        e = {
          x: i.x + i.width,
          y: l
        };
        break;
      case bt:
        e = {
          x: i.x - n.width,
          y: l
        };
        break;
      default:
        e = {
          x: i.x,
          y: i.y
        }
    }
    var c = o ? se(o) : null;
    if (null != c) {
      var h = "y" === c ? "height" : "width";
      switch (r) {
        case wt:
          e[c] = e[c] - (i[h] / 2 - n[h] / 2);
          break;
        case At:
          e[c] = e[c] + (i[h] / 2 - n[h] / 2)
      }
    }
    return e
  }

  function xe(t, e) {
    void 0 === e && (e = {});
    var i = e,
      n = i.placement,
      s = void 0 === n ? t.placement : n,
      o = i.boundary,
      r = void 0 === o ? Et : o,
      a = i.rootBoundary,
      l = void 0 === a ? Tt : a,
      c = i.elementContext,
      h = void 0 === c ? Ct : c,
      d = i.altBoundary,
      u = void 0 !== d && d,
      f = i.padding,
      p = void 0 === f ? 0 : f,
      g = re("number" != typeof p ? p : ae(p, yt)),
      m = h === Ct ? Ot : Ct,
      _ = t.rects.popper,
      b = t.elements[u ? m : h],
      v = function (t, e, i) {
        var n = "clippingParents" === e ? function (t) {
            var e = Ee(ee(t)),
              i = ["absolute", "fixed"].indexOf(Jt(t).position) >= 0 && zt(t) ? ne(t) : t;
            return Ft(i) ? e.filter((function (t) {
              return Ft(t) && Gt(t, i) && "body" !== Wt(t)
            })) : []
          }(t) : [].concat(e),
          s = [].concat(n, [i]),
          o = s[0],
          r = s.reduce((function (e, i) {
            var n = Ce(t, i);
            return e.top = Kt(n.top, e.top), e.right = Qt(n.right, e.right), e.bottom = Qt(n.bottom, e.bottom), e.left = Kt(n.left, e.left), e
          }), Ce(t, o));
        return r.width = r.right - r.left, r.height = r.bottom - r.top, r.x = r.left, r.y = r.top, r
      }(Ft(b) ? b : b.contextElement || te(t.elements.popper), r, l),
      y = Yt(t.elements.reference),
      w = Oe({
        reference: y,
        element: _,
        strategy: "absolute",
        placement: s
      }),
      A = Te(Object.assign({}, _, w)),
      E = h === Ct ? A : y,
      T = {
        top: v.top - E.top + g.top,
        bottom: E.bottom - v.bottom + g.bottom,
        left: v.left - E.left + g.left,
        right: E.right - v.right + g.right
      },
      C = t.modifiersData.offset;
    if (h === Ct && C) {
      var O = C[s];
      Object.keys(T).forEach((function (t) {
        var e = [_t, mt].indexOf(t) >= 0 ? 1 : -1,
          i = [gt, mt].indexOf(t) >= 0 ? "y" : "x";
        T[t] += O[i] * e
      }))
    }
    return T
  }

  function ke(t, e) {
    void 0 === e && (e = {});
    var i = e,
      n = i.placement,
      s = i.boundary,
      o = i.rootBoundary,
      r = i.padding,
      a = i.flipVariations,
      l = i.allowedAutoPlacements,
      c = void 0 === l ? kt : l,
      h = ce(n),
      d = h ? a ? xt : xt.filter((function (t) {
        return ce(t) === h
      })) : yt,
      u = d.filter((function (t) {
        return c.indexOf(t) >= 0
      }));
    0 === u.length && (u = d);
    var f = u.reduce((function (e, i) {
      return e[i] = xe(t, {
        placement: i,
        boundary: s,
        rootBoundary: o,
        padding: r
      })[Vt(i)], e
    }), {});
    return Object.keys(f).sort((function (t, e) {
      return f[t] - f[e]
    }))
  }
  const Le = {
    name: "flip",
    enabled: !0,
    phase: "main",
    fn: function (t) {
      var e = t.state,
        i = t.options,
        n = t.name;
      if (!e.modifiersData[n]._skip) {
        for (var s = i.mainAxis, o = void 0 === s || s, r = i.altAxis, a = void 0 === r || r, l = i.fallbackPlacements, c = i.padding, h = i.boundary, d = i.rootBoundary, u = i.altBoundary, f = i.flipVariations, p = void 0 === f || f, g = i.allowedAutoPlacements, m = e.options.placement, _ = Vt(m), b = l || (_ !== m && p ? function (t) {
            if (Vt(t) === vt) return [];
            var e = me(t);
            return [be(t), e, be(e)]
          }(m) : [me(m)]), v = [m].concat(b).reduce((function (t, i) {
            return t.concat(Vt(i) === vt ? ke(e, {
              placement: i,
              boundary: h,
              rootBoundary: d,
              padding: c,
              flipVariations: p,
              allowedAutoPlacements: g
            }) : i)
          }), []), y = e.rects.reference, w = e.rects.popper, A = new Map, E = !0, T = v[0], C = 0; C < v.length; C++) {
          var O = v[C],
            x = Vt(O),
            k = ce(O) === wt,
            L = [gt, mt].indexOf(x) >= 0,
            D = L ? "width" : "height",
            S = xe(e, {
              placement: O,
              boundary: h,
              rootBoundary: d,
              altBoundary: u,
              padding: c
            }),
            I = L ? k ? _t : bt : k ? mt : gt;
          y[D] > w[D] && (I = me(I));
          var N = me(I),
            P = [];
          if (o && P.push(S[x] <= 0), a && P.push(S[I] <= 0, S[N] <= 0), P.every((function (t) {
              return t
            }))) {
            T = O, E = !1;
            break
          }
          A.set(O, P)
        }
        if (E)
          for (var j = function (t) {
              var e = v.find((function (e) {
                var i = A.get(e);
                if (i) return i.slice(0, t).every((function (t) {
                  return t
                }))
              }));
              if (e) return T = e, "break"
            }, M = p ? 3 : 1; M > 0 && "break" !== j(M); M--);
        e.placement !== T && (e.modifiersData[n]._skip = !0, e.placement = T, e.reset = !0)
      }
    },
    requiresIfExists: ["offset"],
    data: {
      _skip: !1
    }
  };

  function De(t, e, i) {
    return void 0 === i && (i = {
      x: 0,
      y: 0
    }), {
      top: t.top - e.height - i.y,
      right: t.right - e.width + i.x,
      bottom: t.bottom - e.height + i.y,
      left: t.left - e.width - i.x
    }
  }

  function Se(t) {
    return [gt, _t, mt, bt].some((function (e) {
      return t[e] >= 0
    }))
  }
  const Ie = {
      name: "hide",
      enabled: !0,
      phase: "main",
      requiresIfExists: ["preventOverflow"],
      fn: function (t) {
        var e = t.state,
          i = t.name,
          n = e.rects.reference,
          s = e.rects.popper,
          o = e.modifiersData.preventOverflow,
          r = xe(e, {
            elementContext: "reference"
          }),
          a = xe(e, {
            altBoundary: !0
          }),
          l = De(r, n),
          c = De(a, s, o),
          h = Se(l),
          d = Se(c);
        e.modifiersData[i] = {
          referenceClippingOffsets: l,
          popperEscapeOffsets: c,
          isReferenceHidden: h,
          hasPopperEscaped: d
        }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
          "data-popper-reference-hidden": h,
          "data-popper-escaped": d
        })
      }
    },
    Ne = {
      name: "offset",
      enabled: !0,
      phase: "main",
      requires: ["popperOffsets"],
      fn: function (t) {
        var e = t.state,
          i = t.options,
          n = t.name,
          s = i.offset,
          o = void 0 === s ? [0, 0] : s,
          r = kt.reduce((function (t, i) {
            return t[i] = function (t, e, i) {
              var n = Vt(t),
                s = [bt, gt].indexOf(n) >= 0 ? -1 : 1,
                o = "function" == typeof i ? i(Object.assign({}, e, {
                  placement: t
                })) : i,
                r = o[0],
                a = o[1];
              return r = r || 0, a = (a || 0) * s, [bt, _t].indexOf(n) >= 0 ? {
                x: a,
                y: r
              } : {
                x: r,
                y: a
              }
            }(i, e.rects, o), t
          }), {}),
          a = r[e.placement],
          l = a.x,
          c = a.y;
        null != e.modifiersData.popperOffsets && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += c), e.modifiersData[n] = r
      }
    },
    Pe = {
      name: "popperOffsets",
      enabled: !0,
      phase: "read",
      fn: function (t) {
        var e = t.state,
          i = t.name;
        e.modifiersData[i] = Oe({
          reference: e.rects.reference,
          element: e.rects.popper,
          strategy: "absolute",
          placement: e.placement
        })
      },
      data: {}
    },
    je = {
      name: "preventOverflow",
      enabled: !0,
      phase: "main",
      fn: function (t) {
        var e = t.state,
          i = t.options,
          n = t.name,
          s = i.mainAxis,
          o = void 0 === s || s,
          r = i.altAxis,
          a = void 0 !== r && r,
          l = i.boundary,
          c = i.rootBoundary,
          h = i.altBoundary,
          d = i.padding,
          u = i.tether,
          f = void 0 === u || u,
          p = i.tetherOffset,
          g = void 0 === p ? 0 : p,
          m = xe(e, {
            boundary: l,
            rootBoundary: c,
            padding: d,
            altBoundary: h
          }),
          _ = Vt(e.placement),
          b = ce(e.placement),
          v = !b,
          y = se(_),
          w = "x" === y ? "y" : "x",
          A = e.modifiersData.popperOffsets,
          E = e.rects.reference,
          T = e.rects.popper,
          C = "function" == typeof g ? g(Object.assign({}, e.rects, {
            placement: e.placement
          })) : g,
          O = "number" == typeof C ? {
            mainAxis: C,
            altAxis: C
          } : Object.assign({
            mainAxis: 0,
            altAxis: 0
          }, C),
          x = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null,
          k = {
            x: 0,
            y: 0
          };
        if (A) {
          if (o) {
            var L, D = "y" === y ? gt : bt,
              S = "y" === y ? mt : _t,
              I = "y" === y ? "height" : "width",
              N = A[y],
              P = N + m[D],
              j = N - m[S],
              M = f ? -T[I] / 2 : 0,
              H = b === wt ? E[I] : T[I],
              $ = b === wt ? -T[I] : -E[I],
              W = e.elements.arrow,
              B = f && W ? Ut(W) : {
                width: 0,
                height: 0
              },
              F = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : {
                top: 0,
                right: 0,
                bottom: 0,
                left: 0
              },
              z = F[D],
              R = F[S],
              q = oe(0, E[I], B[I]),
              V = v ? E[I] / 2 - M - q - z - O.mainAxis : H - q - z - O.mainAxis,
              K = v ? -E[I] / 2 + M + q + R + O.mainAxis : $ + q + R + O.mainAxis,
              Q = e.elements.arrow && ne(e.elements.arrow),
              X = Q ? "y" === y ? Q.clientTop || 0 : Q.clientLeft || 0 : 0,
              Y = null != (L = null == x ? void 0 : x[y]) ? L : 0,
              U = N + K - Y,
              G = oe(f ? Qt(P, N + V - Y - X) : P, N, f ? Kt(j, U) : j);
            A[y] = G, k[y] = G - N
          }
          if (a) {
            var J, Z = "x" === y ? gt : bt,
              tt = "x" === y ? mt : _t,
              et = A[w],
              it = "y" === w ? "height" : "width",
              nt = et + m[Z],
              st = et - m[tt],
              ot = -1 !== [gt, bt].indexOf(_),
              rt = null != (J = null == x ? void 0 : x[w]) ? J : 0,
              at = ot ? nt : et - E[it] - T[it] - rt + O.altAxis,
              lt = ot ? et + E[it] + T[it] - rt - O.altAxis : st,
              ct = f && ot ? function (t, e, i) {
                var n = oe(t, e, i);
                return n > i ? i : n
              }(at, et, lt) : oe(f ? at : nt, et, f ? lt : st);
            A[w] = ct, k[w] = ct - et
          }
          e.modifiersData[n] = k
        }
      },
      requiresIfExists: ["offset"]
    };

  function Me(t, e, i) {
    void 0 === i && (i = !1);
    var n, s, o = zt(e),
      r = zt(e) && function (t) {
        var e = t.getBoundingClientRect(),
          i = Xt(e.width) / t.offsetWidth || 1,
          n = Xt(e.height) / t.offsetHeight || 1;
        return 1 !== i || 1 !== n
      }(e),
      a = te(e),
      l = Yt(t, r),
      c = {
        scrollLeft: 0,
        scrollTop: 0
      },
      h = {
        x: 0,
        y: 0
      };
    return (o || !o && !i) && (("body" !== Wt(e) || we(a)) && (c = (n = e) !== Bt(n) && zt(n) ? {
      scrollLeft: (s = n).scrollLeft,
      scrollTop: s.scrollTop
    } : ve(n)), zt(e) ? ((h = Yt(e, !0)).x += e.clientLeft, h.y += e.clientTop) : a && (h.x = ye(a))), {
      x: l.left + c.scrollLeft - h.x,
      y: l.top + c.scrollTop - h.y,
      width: l.width,
      height: l.height
    }
  }

  function He(t) {
    var e = new Map,
      i = new Set,
      n = [];

    function s(t) {
      i.add(t.name), [].concat(t.requires || [], t.requiresIfExists || []).forEach((function (t) {
        if (!i.has(t)) {
          var n = e.get(t);
          n && s(n)
        }
      })), n.push(t)
    }
    return t.forEach((function (t) {
      e.set(t.name, t)
    })), t.forEach((function (t) {
      i.has(t.name) || s(t)
    })), n
  }
  var $e = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };

  function We() {
    for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
    return !e.some((function (t) {
      return !(t && "function" == typeof t.getBoundingClientRect)
    }))
  }

  function Be(t) {
    void 0 === t && (t = {});
    var e = t,
      i = e.defaultModifiers,
      n = void 0 === i ? [] : i,
      s = e.defaultOptions,
      o = void 0 === s ? $e : s;
    return function (t, e, i) {
      void 0 === i && (i = o);
      var s, r, a = {
          placement: "bottom",
          orderedModifiers: [],
          options: Object.assign({}, $e, o),
          modifiersData: {},
          elements: {
            reference: t,
            popper: e
          },
          attributes: {},
          styles: {}
        },
        l = [],
        c = !1,
        h = {
          state: a,
          setOptions: function (i) {
            var s = "function" == typeof i ? i(a.options) : i;
            d(), a.options = Object.assign({}, o, a.options, s), a.scrollParents = {
              reference: Ft(t) ? Ee(t) : t.contextElement ? Ee(t.contextElement) : [],
              popper: Ee(e)
            };
            var r, c, u = function (t) {
              var e = He(t);
              return $t.reduce((function (t, i) {
                return t.concat(e.filter((function (t) {
                  return t.phase === i
                })))
              }), [])
            }((r = [].concat(n, a.options.modifiers), c = r.reduce((function (t, e) {
              var i = t[e.name];
              return t[e.name] = i ? Object.assign({}, i, e, {
                options: Object.assign({}, i.options, e.options),
                data: Object.assign({}, i.data, e.data)
              }) : e, t
            }), {}), Object.keys(c).map((function (t) {
              return c[t]
            }))));
            return a.orderedModifiers = u.filter((function (t) {
              return t.enabled
            })), a.orderedModifiers.forEach((function (t) {
              var e = t.name,
                i = t.options,
                n = void 0 === i ? {} : i,
                s = t.effect;
              if ("function" == typeof s) {
                var o = s({
                  state: a,
                  name: e,
                  instance: h,
                  options: n
                });
                l.push(o || function () {})
              }
            })), h.update()
          },
          forceUpdate: function () {
            if (!c) {
              var t = a.elements,
                e = t.reference,
                i = t.popper;
              if (We(e, i)) {
                a.rects = {
                  reference: Me(e, ne(i), "fixed" === a.options.strategy),
                  popper: Ut(i)
                }, a.reset = !1, a.placement = a.options.placement, a.orderedModifiers.forEach((function (t) {
                  return a.modifiersData[t.name] = Object.assign({}, t.data)
                }));
                for (var n = 0; n < a.orderedModifiers.length; n++)
                  if (!0 !== a.reset) {
                    var s = a.orderedModifiers[n],
                      o = s.fn,
                      r = s.options,
                      l = void 0 === r ? {} : r,
                      d = s.name;
                    "function" == typeof o && (a = o({
                      state: a,
                      options: l,
                      name: d,
                      instance: h
                    }) || a)
                  } else a.reset = !1, n = -1
              }
            }
          },
          update: (s = function () {
            return new Promise((function (t) {
              h.forceUpdate(), t(a)
            }))
          }, function () {
            return r || (r = new Promise((function (t) {
              Promise.resolve().then((function () {
                r = void 0, t(s())
              }))
            }))), r
          }),
          destroy: function () {
            d(), c = !0
          }
        };
      if (!We(t, e)) return h;

      function d() {
        l.forEach((function (t) {
          return t()
        })), l = []
      }
      return h.setOptions(i).then((function (t) {
        !c && i.onFirstUpdate && i.onFirstUpdate(t)
      })), h
    }
  }
  var Fe = Be(),
    ze = Be({
      defaultModifiers: [pe, Pe, ue, qt]
    }),
    Re = Be({
      defaultModifiers: [pe, Pe, ue, qt, Ne, Le, je, le, Ie]
    });
  const qe = Object.freeze(Object.defineProperty({
      __proto__: null,
      popperGenerator: Be,
      detectOverflow: xe,
      createPopperBase: Fe,
      createPopper: Re,
      createPopperLite: ze,
      top: gt,
      bottom: mt,
      right: _t,
      left: bt,
      auto: vt,
      basePlacements: yt,
      start: wt,
      end: At,
      clippingParents: Et,
      viewport: Tt,
      popper: Ct,
      reference: Ot,
      variationPlacements: xt,
      placements: kt,
      beforeRead: Lt,
      read: Dt,
      afterRead: St,
      beforeMain: It,
      main: Nt,
      afterMain: Pt,
      beforeWrite: jt,
      write: Mt,
      afterWrite: Ht,
      modifierPhases: $t,
      applyStyles: qt,
      arrow: le,
      computeStyles: ue,
      eventListeners: pe,
      flip: Le,
      hide: Ie,
      offset: Ne,
      popperOffsets: Pe,
      preventOverflow: je
    }, Symbol.toStringTag, {
      value: "Module"
    })),
    Ve = "dropdown",
    Ke = "ArrowUp",
    Qe = "ArrowDown",
    Xe = "click.bs.dropdown.data-api",
    Ye = "keydown.bs.dropdown.data-api",
    Ue = "show",
    Ge = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)',
    Je = `${Ge}.show`,
    Ze = ".dropdown-menu",
    ti = p() ? "top-end" : "top-start",
    ei = p() ? "top-start" : "top-end",
    ii = p() ? "bottom-end" : "bottom-start",
    ni = p() ? "bottom-start" : "bottom-end",
    si = p() ? "left-start" : "right-start",
    oi = p() ? "right-start" : "left-start",
    ri = {
      autoClose: !0,
      boundary: "clippingParents",
      display: "dynamic",
      offset: [0, 2],
      popperConfig: null,
      reference: "toggle"
    },
    ai = {
      autoClose: "(boolean|string)",
      boundary: "(string|element)",
      display: "string",
      offset: "(array|string|function)",
      popperConfig: "(null|object|function)",
      reference: "(string|element|object)"
    };
  class li extends z {
    constructor(t, e) {
      super(t, e), this._popper = null, this._parent = this._element.parentNode, this._menu = Q.findOne(Ze, this._parent), this._inNavbar = this._detectNavbar()
    }
    static get Default() {
      return ri
    }
    static get DefaultType() {
      return ai
    }
    static get NAME() {
      return Ve
    }
    toggle() {
      return this._isShown() ? this.hide() : this.show()
    }
    show() {
      if (l(this._element) || this._isShown()) return;
      const t = {
        relatedTarget: this._element
      };
      if (!P.trigger(this._element, "show.bs.dropdown", t).defaultPrevented) {
        if (this._createPopper(), "ontouchstart" in document.documentElement && !this._parent.closest(".navbar-nav"))
          for (const t of [].concat(...document.body.children)) P.on(t, "mouseover", h);
        this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.classList.add(Ue), this._element.classList.add(Ue), P.trigger(this._element, "shown.bs.dropdown", t)
      }
    }
    hide() {
      if (l(this._element) || !this._isShown()) return;
      const t = {
        relatedTarget: this._element
      };
      this._completeHide(t)
    }
    dispose() {
      this._popper && this._popper.destroy(), super.dispose()
    }
    update() {
      this._inNavbar = this._detectNavbar(), this._popper && this._popper.update()
    }
    _completeHide(t) {
      if (!P.trigger(this._element, "hide.bs.dropdown", t).defaultPrevented) {
        if ("ontouchstart" in document.documentElement)
          for (const t of [].concat(...document.body.children)) P.off(t, "mouseover", h);
        this._popper && this._popper.destroy(), this._menu.classList.remove(Ue), this._element.classList.remove(Ue), this._element.setAttribute("aria-expanded", "false"), B.removeDataAttribute(this._menu, "popper"), P.trigger(this._element, "hidden.bs.dropdown", t)
      }
    }
    _getConfig(t) {
      if ("object" == typeof (t = super._getConfig(t)).reference && !o(t.reference) && "function" != typeof t.reference.getBoundingClientRect) throw new TypeError(`${Ve.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
      return t
    }
    _createPopper() {
      if (void 0 === qe) throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
      let t = this._element;
      "parent" === this._config.reference ? t = this._parent : o(this._config.reference) ? t = r(this._config.reference) : "object" == typeof this._config.reference && (t = this._config.reference);
      const e = this._getPopperConfig();
      this._popper = Re(t, this._menu, e)
    }
    _isShown() {
      return this._menu.classList.contains(Ue)
    }
    _getPlacement() {
      const t = this._parent;
      if (t.classList.contains("dropend")) return si;
      if (t.classList.contains("dropstart")) return oi;
      if (t.classList.contains("dropup-center")) return "top";
      if (t.classList.contains("dropdown-center")) return "bottom";
      const e = "end" === getComputedStyle(this._menu).getPropertyValue("--bs-position").trim();
      return t.classList.contains("dropup") ? e ? ei : ti : e ? ni : ii
    }
    _detectNavbar() {
      return null !== this._element.closest(".navbar")
    }
    _getOffset() {
      const {
        offset: t
      } = this._config;
      return "string" == typeof t ? t.split(",").map((t => Number.parseInt(t, 10))) : "function" == typeof t ? e => t(e, this._element) : t
    }
    _getPopperConfig() {
      const t = {
        placement: this._getPlacement(),
        modifiers: [{
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        }, {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        }]
      };
      return (this._inNavbar || "static" === this._config.display) && (B.setDataAttribute(this._menu, "popper", "static"), t.modifiers = [{
        name: "applyStyles",
        enabled: !1
      }]), {
        ...t,
        ..."function" == typeof this._config.popperConfig ? this._config.popperConfig(t) : this._config.popperConfig
      }
    }
    _selectMenuItem({
      key: t,
      target: e
    }) {
      const i = Q.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", this._menu).filter((t => a(t)));
      i.length && b(i, e, t === Qe, !i.includes(e)).focus()
    }
    static jQueryInterface(t) {
      return this.each((function () {
        const e = li.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
          e[t]()
        }
      }))
    }
    static clearMenus(t) {
      if (2 === t.button || "keyup" === t.type && "Tab" !== t.key) return;
      const e = Q.find(Je);
      for (const i of e) {
        const e = li.getInstance(i);
        if (!e || !1 === e._config.autoClose) continue;
        const n = t.composedPath(),
          s = n.includes(e._menu);
        if (n.includes(e._element) || "inside" === e._config.autoClose && !s || "outside" === e._config.autoClose && s) continue;
        if (e._menu.contains(t.target) && ("keyup" === t.type && "Tab" === t.key || /input|select|option|textarea|form/i.test(t.target.tagName))) continue;
        const o = {
          relatedTarget: e._element
        };
        "click" === t.type && (o.clickEvent = t), e._completeHide(o)
      }
    }
    static dataApiKeydownHandler(t) {
      const e = /input|textarea/i.test(t.target.tagName),
        i = "Escape" === t.key,
        n = [Ke, Qe].includes(t.key);
      if (!n && !i) return;
      if (e && !i) return;
      t.preventDefault();
      const s = Q.findOne(Ge, t.delegateTarget.parentNode),
        o = li.getOrCreateInstance(s);
      if (n) return t.stopPropagation(), o.show(), void o._selectMenuItem(t);
      o._isShown() && (t.stopPropagation(), o.hide(), s.focus())
    }
  }
  P.on(document, Ye, Ge, li.dataApiKeydownHandler), P.on(document, Ye, Ze, li.dataApiKeydownHandler), P.on(document, Xe, li.clearMenus), P.on(document, "keyup.bs.dropdown.data-api", li.clearMenus), P.on(document, Xe, Ge, (function (t) {
    t.preventDefault(), li.getOrCreateInstance(this).toggle()
  })), g(li);
  const ci = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top",
    hi = ".sticky-top",
    di = "padding-right",
    ui = "margin-right";
  class fi {
    constructor() {
      this._element = document.body
    }
    getWidth() {
      const t = document.documentElement.clientWidth;
      return Math.abs(window.innerWidth - t)
    }
    hide() {
      const t = this.getWidth();
      this._disableOverFlow(), this._setElementAttributes(this._element, di, (e => e + t)), this._setElementAttributes(ci, di, (e => e + t)), this._setElementAttributes(hi, ui, (e => e - t))
    }
    reset() {
      this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, di), this._resetElementAttributes(ci, di), this._resetElementAttributes(hi, ui)
    }
    isOverflowing() {
      return this.getWidth() > 0
    }
    _disableOverFlow() {
      this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden"
    }
    _setElementAttributes(t, e, i) {
      const n = this.getWidth();
      this._applyManipulationCallback(t, (t => {
        if (t !== this._element && window.innerWidth > t.clientWidth + n) return;
        this._saveInitialAttribute(t, e);
        const s = window.getComputedStyle(t).getPropertyValue(e);
        t.style.setProperty(e, `${i(Number.parseFloat(s))}px`)
      }))
    }
    _saveInitialAttribute(t, e) {
      const i = t.style.getPropertyValue(e);
      i && B.setDataAttribute(t, e, i)
    }
    _resetElementAttributes(t, e) {
      this._applyManipulationCallback(t, (t => {
        const i = B.getDataAttribute(t, e);
        null !== i ? (B.removeDataAttribute(t, e), t.style.setProperty(e, i)) : t.style.removeProperty(e)
      }))
    }
    _applyManipulationCallback(t, e) {
      if (o(t)) e(t);
      else
        for (const i of Q.find(t, this._element)) e(i)
    }
  }
  const pi = "show",
    gi = "mousedown.bs.backdrop",
    mi = {
      className: "modal-backdrop",
      clickCallback: null,
      isAnimated: !1,
      isVisible: !0,
      rootElement: "body"
    },
    _i = {
      className: "string",
      clickCallback: "(function|null)",
      isAnimated: "boolean",
      isVisible: "boolean",
      rootElement: "(element|string)"
    };
  class bi extends F {
    constructor(t) {
      super(), this._config = this._getConfig(t), this._isAppended = !1, this._element = null
    }
    static get Default() {
      return mi
    }
    static get DefaultType() {
      return _i
    }
    static get NAME() {
      return "backdrop"
    }
    show(t) {
      if (!this._config.isVisible) return void m(t);
      this._append();
      const e = this._getElement();
      this._config.isAnimated && d(e), e.classList.add(pi), this._emulateAnimation((() => {
        m(t)
      }))
    }
    hide(t) {
      this._config.isVisible ? (this._getElement().classList.remove(pi), this._emulateAnimation((() => {
        this.dispose(), m(t)
      }))) : m(t)
    }
    dispose() {
      this._isAppended && (P.off(this._element, gi), this._element.remove(), this._isAppended = !1)
    }
    _getElement() {
      if (!this._element) {
        const t = document.createElement("div");
        t.className = this._config.className, this._config.isAnimated && t.classList.add("fade"), this._element = t
      }
      return this._element
    }
    _configAfterMerge(t) {
      return t.rootElement = r(t.rootElement), t
    }
    _append() {
      if (this._isAppended) return;
      const t = this._getElement();
      this._config.rootElement.append(t), P.on(t, gi, (() => {
        m(this._config.clickCallback)
      })), this._isAppended = !0
    }
    _emulateAnimation(t) {
      _(t, this._getElement(), this._config.isAnimated)
    }
  }
  const vi = ".bs.focustrap",
    yi = "backward",
    wi = {
      autofocus: !0,
      trapElement: null
    },
    Ai = {
      autofocus: "boolean",
      trapElement: "element"
    };
  class Ei extends F {
    constructor(t) {
      super(), this._config = this._getConfig(t), this._isActive = !1, this._lastTabNavDirection = null
    }
    static get Default() {
      return wi
    }
    static get DefaultType() {
      return Ai
    }
    static get NAME() {
      return "focustrap"
    }
    activate() {
      this._isActive || (this._config.autofocus && this._config.trapElement.focus(), P.off(document, vi), P.on(document, "focusin.bs.focustrap", (t => this._handleFocusin(t))), P.on(document, "keydown.tab.bs.focustrap", (t => this._handleKeydown(t))), this._isActive = !0)
    }
    deactivate() {
      this._isActive && (this._isActive = !1, P.off(document, vi))
    }
    _handleFocusin(t) {
      const {
        trapElement: e
      } = this._config;
      if (t.target === document || t.target === e || e.contains(t.target)) return;
      const i = Q.focusableChildren(e);
      0 === i.length ? e.focus() : this._lastTabNavDirection === yi ? i[i.length - 1].focus() : i[0].focus()
    }
    _handleKeydown(t) {
      "Tab" === t.key && (this._lastTabNavDirection = t.shiftKey ? yi : "forward")
    }
  }
  const Ti = "hidden.bs.modal",
    Ci = "show.bs.modal",
    Oi = "modal-open",
    xi = "show",
    ki = "modal-static",
    Li = {
      backdrop: !0,
      focus: !0,
      keyboard: !0
    },
    Di = {
      backdrop: "(boolean|string)",
      focus: "boolean",
      keyboard: "boolean"
    };
  class Si extends z {
    constructor(t, e) {
      super(t, e), this._dialog = Q.findOne(".modal-dialog", this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._isTransitioning = !1, this._scrollBar = new fi, this._addEventListeners()
    }
    static get Default() {
      return Li
    }
    static get DefaultType() {
      return Di
    }
    static get NAME() {
      return "modal"
    }
    toggle(t) {
      return this._isShown ? this.hide() : this.show(t)
    }
    show(t) {
      this._isShown || this._isTransitioning || P.trigger(this._element, Ci, {
        relatedTarget: t
      }).defaultPrevented || (this._isShown = !0, this._isTransitioning = !0, this._scrollBar.hide(), document.body.classList.add(Oi), this._adjustDialog(), this._backdrop.show((() => this._showElement(t))))
    }
    hide() {
      this._isShown && !this._isTransitioning && (P.trigger(this._element, "hide.bs.modal").defaultPrevented || (this._isShown = !1, this._isTransitioning = !0, this._focustrap.deactivate(), this._element.classList.remove(xi), this._queueCallback((() => this._hideModal()), this._element, this._isAnimated())))
    }
    dispose() {
      for (const t of [window, this._dialog]) P.off(t, ".bs.modal");
      this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose()
    }
    handleUpdate() {
      this._adjustDialog()
    }
    _initializeBackDrop() {
      return new bi({
        isVisible: Boolean(this._config.backdrop),
        isAnimated: this._isAnimated()
      })
    }
    _initializeFocusTrap() {
      return new Ei({
        trapElement: this._element
      })
    }
    _showElement(t) {
      document.body.contains(this._element) || document.body.append(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0;
      const e = Q.findOne(".modal-body", this._dialog);
      e && (e.scrollTop = 0), d(this._element), this._element.classList.add(xi), this._queueCallback((() => {
        this._config.focus && this._focustrap.activate(), this._isTransitioning = !1, P.trigger(this._element, "shown.bs.modal", {
          relatedTarget: t
        })
      }), this._dialog, this._isAnimated())
    }
    _addEventListeners() {
      P.on(this._element, "keydown.dismiss.bs.modal", (t => {
        if ("Escape" === t.key) return this._config.keyboard ? (t.preventDefault(), void this.hide()) : void this._triggerBackdropTransition()
      })), P.on(window, "resize.bs.modal", (() => {
        this._isShown && !this._isTransitioning && this._adjustDialog()
      })), P.on(this._element, "mousedown.dismiss.bs.modal", (t => {
        t.target === t.currentTarget && ("static" !== this._config.backdrop ? this._config.backdrop && this.hide() : this._triggerBackdropTransition())
      }))
    }
    _hideModal() {
      this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._backdrop.hide((() => {
        document.body.classList.remove(Oi), this._resetAdjustments(), this._scrollBar.reset(), P.trigger(this._element, Ti)
      }))
    }
    _isAnimated() {
      return this._element.classList.contains("fade")
    }
    _triggerBackdropTransition() {
      if (P.trigger(this._element, "hidePrevented.bs.modal").defaultPrevented) return;
      const t = this._element.scrollHeight > document.documentElement.clientHeight,
        e = this._element.style.overflowY;
      "hidden" === e || this._element.classList.contains(ki) || (t || (this._element.style.overflowY = "hidden"), this._element.classList.add(ki), this._queueCallback((() => {
        this._element.classList.remove(ki), this._queueCallback((() => {
          this._element.style.overflowY = e
        }), this._dialog)
      }), this._dialog), this._element.focus())
    }
    _adjustDialog() {
      const t = this._element.scrollHeight > document.documentElement.clientHeight,
        e = this._scrollBar.getWidth(),
        i = e > 0;
      if (i && !t) {
        const t = p() ? "paddingLeft" : "paddingRight";
        this._element.style[t] = `${e}px`
      }
      if (!i && t) {
        const t = p() ? "paddingRight" : "paddingLeft";
        this._element.style[t] = `${e}px`
      }
    }
    _resetAdjustments() {
      this._element.style.paddingLeft = "", this._element.style.paddingRight = ""
    }
    static jQueryInterface(t, e) {
      return this.each((function () {
        const i = Si.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === i[t]) throw new TypeError(`No method named "${t}"`);
          i[t](e)
        }
      }))
    }
  }
  P.on(document, "click.bs.modal.data-api", '[data-bs-toggle="modal"]', (function (t) {
    const e = n(this);
    ["A", "AREA"].includes(this.tagName) && t.preventDefault(), P.one(e, Ci, (t => {
      t.defaultPrevented || P.one(e, Ti, (() => {
        a(this) && this.focus()
      }))
    }));
    const i = Q.findOne(".modal.show");
    i && Si.getInstance(i).hide(), Si.getOrCreateInstance(e).toggle(this)
  })), R(Si), g(Si);
  const Ii = "show",
    Ni = "showing",
    Pi = "hiding",
    ji = ".offcanvas.show",
    Mi = "hidePrevented.bs.offcanvas",
    Hi = "hidden.bs.offcanvas",
    $i = {
      backdrop: !0,
      keyboard: !0,
      scroll: !1
    },
    Wi = {
      backdrop: "(boolean|string)",
      keyboard: "boolean",
      scroll: "boolean"
    };
  class Bi extends z {
    constructor(t, e) {
      super(t, e), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners()
    }
    static get Default() {
      return $i
    }
    static get DefaultType() {
      return Wi
    }
    static get NAME() {
      return "offcanvas"
    }
    toggle(t) {
      return this._isShown ? this.hide() : this.show(t)
    }
    show(t) {
      this._isShown || P.trigger(this._element, "show.bs.offcanvas", {
        relatedTarget: t
      }).defaultPrevented || (this._isShown = !0, this._backdrop.show(), this._config.scroll || (new fi).hide(), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.classList.add(Ni), this._queueCallback((() => {
        this._config.scroll && !this._config.backdrop || this._focustrap.activate(), this._element.classList.add(Ii), this._element.classList.remove(Ni), P.trigger(this._element, "shown.bs.offcanvas", {
          relatedTarget: t
        })
      }), this._element, !0))
    }
    hide() {
      this._isShown && (P.trigger(this._element, "hide.bs.offcanvas").defaultPrevented || (this._focustrap.deactivate(), this._element.blur(), this._isShown = !1, this._element.classList.add(Pi), this._backdrop.hide(), this._queueCallback((() => {
        this._element.classList.remove(Ii, Pi), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._config.scroll || (new fi).reset(), P.trigger(this._element, Hi)
      }), this._element, !0)))
    }
    dispose() {
      this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose()
    }
    _initializeBackDrop() {
      const t = Boolean(this._config.backdrop);
      return new bi({
        className: "offcanvas-backdrop",
        isVisible: t,
        isAnimated: !0,
        rootElement: this._element.parentNode,
        clickCallback: t ? () => {
          "static" !== this._config.backdrop ? this.hide() : P.trigger(this._element, Mi)
        } : null
      })
    }
    _initializeFocusTrap() {
      return new Ei({
        trapElement: this._element
      })
    }
    _addEventListeners() {
      P.on(this._element, "keydown.dismiss.bs.offcanvas", (t => {
        "Escape" === t.key && (this._config.keyboard ? this.hide() : P.trigger(this._element, Mi))
      }))
    }
    static jQueryInterface(t) {
      return this.each((function () {
        const e = Bi.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
          e[t](this)
        }
      }))
    }
  }
  P.on(document, "click.bs.offcanvas.data-api", '[data-bs-toggle="offcanvas"]', (function (t) {
    const e = n(this);
    if (["A", "AREA"].includes(this.tagName) && t.preventDefault(), l(this)) return;
    P.one(e, Hi, (() => {
      a(this) && this.focus()
    }));
    const i = Q.findOne(ji);
    i && i !== e && Bi.getInstance(i).hide(), Bi.getOrCreateInstance(e).toggle(this)
  })), P.on(window, "load.bs.offcanvas.data-api", (() => {
    for (const t of Q.find(ji)) Bi.getOrCreateInstance(t).show()
  })), P.on(window, "resize.bs.offcanvas", (() => {
    for (const t of Q.find("[aria-modal][class*=show][class*=offcanvas-]")) "fixed" !== getComputedStyle(t).position && Bi.getOrCreateInstance(t).hide()
  })), R(Bi), g(Bi);
  const Fi = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]),
    zi = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i,
    Ri = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i,
    qi = (t, e) => {
      const i = t.nodeName.toLowerCase();
      return e.includes(i) ? !Fi.has(i) || Boolean(zi.test(t.nodeValue) || Ri.test(t.nodeValue)) : e.filter((t => t instanceof RegExp)).some((t => t.test(i)))
    },
    Vi = {
      "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i],
      a: ["target", "href", "title", "rel"],
      area: [],
      b: [],
      br: [],
      col: [],
      code: [],
      div: [],
      em: [],
      hr: [],
      h1: [],
      h2: [],
      h3: [],
      h4: [],
      h5: [],
      h6: [],
      i: [],
      img: ["src", "srcset", "alt", "title", "width", "height"],
      li: [],
      ol: [],
      p: [],
      pre: [],
      s: [],
      small: [],
      span: [],
      sub: [],
      sup: [],
      strong: [],
      u: [],
      ul: []
    },
    Ki = {
      allowList: Vi,
      content: {},
      extraClass: "",
      html: !1,
      sanitize: !0,
      sanitizeFn: null,
      template: "<div></div>"
    },
    Qi = {
      allowList: "object",
      content: "object",
      extraClass: "(string|function)",
      html: "boolean",
      sanitize: "boolean",
      sanitizeFn: "(null|function)",
      template: "string"
    },
    Xi = {
      entry: "(string|element|function|null)",
      selector: "(string|element)"
    };
  class Yi extends F {
    constructor(t) {
      super(), this._config = this._getConfig(t)
    }
    static get Default() {
      return Ki
    }
    static get DefaultType() {
      return Qi
    }
    static get NAME() {
      return "TemplateFactory"
    }
    getContent() {
      return Object.values(this._config.content).map((t => this._resolvePossibleFunction(t))).filter(Boolean)
    }
    hasContent() {
      return this.getContent().length > 0
    }
    changeContent(t) {
      return this._checkContent(t), this._config.content = {
        ...this._config.content,
        ...t
      }, this
    }
    toHtml() {
      const t = document.createElement("div");
      t.innerHTML = this._maybeSanitize(this._config.template);
      for (const [e, i] of Object.entries(this._config.content)) this._setContent(t, i, e);
      const e = t.children[0],
        i = this._resolvePossibleFunction(this._config.extraClass);
      return i && e.classList.add(...i.split(" ")), e
    }
    _typeCheckConfig(t) {
      super._typeCheckConfig(t), this._checkContent(t.content)
    }
    _checkContent(t) {
      for (const [e, i] of Object.entries(t)) super._typeCheckConfig({
        selector: e,
        entry: i
      }, Xi)
    }
    _setContent(t, e, i) {
      const n = Q.findOne(i, t);
      n && ((e = this._resolvePossibleFunction(e)) ? o(e) ? this._putElementInTemplate(r(e), n) : this._config.html ? n.innerHTML = this._maybeSanitize(e) : n.textContent = e : n.remove())
    }
    _maybeSanitize(t) {
      return this._config.sanitize ? function (t, e, i) {
        if (!t.length) return t;
        if (i && "function" == typeof i) return i(t);
        const n = (new window.DOMParser).parseFromString(t, "text/html"),
          s = [].concat(...n.body.querySelectorAll("*"));
        for (const t of s) {
          const i = t.nodeName.toLowerCase();
          if (!Object.keys(e).includes(i)) {
            t.remove();
            continue
          }
          const n = [].concat(...t.attributes),
            s = [].concat(e["*"] || [], e[i] || []);
          for (const e of n) qi(e, s) || t.removeAttribute(e.nodeName)
        }
        return n.body.innerHTML
      }(t, this._config.allowList, this._config.sanitizeFn) : t
    }
    _resolvePossibleFunction(t) {
      return "function" == typeof t ? t(this) : t
    }
    _putElementInTemplate(t, e) {
      if (this._config.html) return e.innerHTML = "", void e.append(t);
      e.textContent = t.textContent
    }
  }
  const Ui = new Set(["sanitize", "allowList", "sanitizeFn"]),
    Gi = "fade",
    Ji = "show",
    Zi = ".modal",
    tn = "hide.bs.modal",
    en = "hover",
    nn = "focus",
    sn = {
      AUTO: "auto",
      TOP: "top",
      RIGHT: p() ? "left" : "right",
      BOTTOM: "bottom",
      LEFT: p() ? "right" : "left"
    },
    on = {
      allowList: Vi,
      animation: !0,
      boundary: "clippingParents",
      container: !1,
      customClass: "",
      delay: 0,
      fallbackPlacements: ["top", "right", "bottom", "left"],
      html: !1,
      offset: [0, 0],
      placement: "top",
      popperConfig: null,
      sanitize: !0,
      sanitizeFn: null,
      selector: !1,
      template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
      title: "",
      trigger: "hover focus"
    },
    rn = {
      allowList: "object",
      animation: "boolean",
      boundary: "(string|element)",
      container: "(string|element|boolean)",
      customClass: "(string|function)",
      delay: "(number|object)",
      fallbackPlacements: "array",
      html: "boolean",
      offset: "(array|string|function)",
      placement: "(string|function)",
      popperConfig: "(null|object|function)",
      sanitize: "boolean",
      sanitizeFn: "(null|function)",
      selector: "(string|boolean)",
      template: "string",
      title: "(string|element|function)",
      trigger: "string"
    };
  class an extends z {
    constructor(t, e) {
      if (void 0 === qe) throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
      super(t, e), this._isEnabled = !0, this._timeout = 0, this._isHovered = !1, this._activeTrigger = {}, this._popper = null, this._templateFactory = null, this._newContent = null, this.tip = null, this._setListeners()
    }
    static get Default() {
      return on
    }
    static get DefaultType() {
      return rn
    }
    static get NAME() {
      return "tooltip"
    }
    enable() {
      this._isEnabled = !0
    }
    disable() {
      this._isEnabled = !1
    }
    toggleEnabled() {
      this._isEnabled = !this._isEnabled
    }
    toggle(t) {
      if (this._isEnabled) {
        if (t) {
          const e = this._initializeOnDelegatedTarget(t);
          return e._activeTrigger.click = !e._activeTrigger.click, void(e._isWithActiveTrigger() ? e._enter() : e._leave())
        }
        this._isShown() ? this._leave() : this._enter()
      }
    }
    dispose() {
      clearTimeout(this._timeout), P.off(this._element.closest(Zi), tn, this._hideModalHandler), this.tip && this.tip.remove(), this._disposePopper(), super.dispose()
    }
    show() {
      if ("none" === this._element.style.display) throw new Error("Please use show on visible elements");
      if (!this._isWithContent() || !this._isEnabled) return;
      const t = P.trigger(this._element, this.constructor.eventName("show")),
        e = (c(this._element) || this._element.ownerDocument.documentElement).contains(this._element);
      if (t.defaultPrevented || !e) return;
      this.tip && (this.tip.remove(), this.tip = null);
      const i = this._getTipElement();
      this._element.setAttribute("aria-describedby", i.getAttribute("id"));
      const {
        container: n
      } = this._config;
      if (this._element.ownerDocument.documentElement.contains(this.tip) || (n.append(i), P.trigger(this._element, this.constructor.eventName("inserted"))), this._popper ? this._popper.update() : this._popper = this._createPopper(i), i.classList.add(Ji), "ontouchstart" in document.documentElement)
        for (const t of [].concat(...document.body.children)) P.on(t, "mouseover", h);
      this._queueCallback((() => {
        const t = this._isHovered;
        this._isHovered = !1, P.trigger(this._element, this.constructor.eventName("shown")), t && this._leave()
      }), this.tip, this._isAnimated())
    }
    hide() {
      if (!this._isShown()) return;
      if (P.trigger(this._element, this.constructor.eventName("hide")).defaultPrevented) return;
      const t = this._getTipElement();
      if (t.classList.remove(Ji), "ontouchstart" in document.documentElement)
        for (const t of [].concat(...document.body.children)) P.off(t, "mouseover", h);
      this._activeTrigger.click = !1, this._activeTrigger.focus = !1, this._activeTrigger.hover = !1, this._isHovered = !1, this._queueCallback((() => {
        this._isWithActiveTrigger() || (this._isHovered || t.remove(), this._element.removeAttribute("aria-describedby"), P.trigger(this._element, this.constructor.eventName("hidden")), this._disposePopper())
      }), this.tip, this._isAnimated())
    }
    update() {
      this._popper && this._popper.update()
    }
    _isWithContent() {
      return Boolean(this._getTitle())
    }
    _getTipElement() {
      return this.tip || (this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())), this.tip
    }
    _createTipElement(t) {
      const e = this._getTemplateFactory(t).toHtml();
      if (!e) return null;
      e.classList.remove(Gi, Ji), e.classList.add(`bs-${this.constructor.NAME}-auto`);
      const i = (t => {
        do {
          t += Math.floor(1e6 * Math.random())
        } while (document.getElementById(t));
        return t
      })(this.constructor.NAME).toString();
      return e.setAttribute("id", i), this._isAnimated() && e.classList.add(Gi), e
    }
    setContent(t) {
      this._newContent = t, this._isShown() && (this._disposePopper(), this.show())
    }
    _getTemplateFactory(t) {
      return this._templateFactory ? this._templateFactory.changeContent(t) : this._templateFactory = new Yi({
        ...this._config,
        content: t,
        extraClass: this._resolvePossibleFunction(this._config.customClass)
      }), this._templateFactory
    }
    _getContentForTemplate() {
      return {
        ".tooltip-inner": this._getTitle()
      }
    }
    _getTitle() {
      return this._resolvePossibleFunction(this._config.title) || this._config.originalTitle
    }
    _initializeOnDelegatedTarget(t) {
      return this.constructor.getOrCreateInstance(t.delegateTarget, this._getDelegateConfig())
    }
    _isAnimated() {
      return this._config.animation || this.tip && this.tip.classList.contains(Gi)
    }
    _isShown() {
      return this.tip && this.tip.classList.contains(Ji)
    }
    _createPopper(t) {
      const e = "function" == typeof this._config.placement ? this._config.placement.call(this, t, this._element) : this._config.placement,
        i = sn[e.toUpperCase()];
      return Re(this._element, t, this._getPopperConfig(i))
    }
    _getOffset() {
      const {
        offset: t
      } = this._config;
      return "string" == typeof t ? t.split(",").map((t => Number.parseInt(t, 10))) : "function" == typeof t ? e => t(e, this._element) : t
    }
    _resolvePossibleFunction(t) {
      return "function" == typeof t ? t.call(this._element) : t
    }
    _getPopperConfig(t) {
      const e = {
        placement: t,
        modifiers: [{
          name: "flip",
          options: {
            fallbackPlacements: this._config.fallbackPlacements
          }
        }, {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        }, {
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        }, {
          name: "arrow",
          options: {
            element: `.${this.constructor.NAME}-arrow`
          }
        }, {
          name: "preSetPlacement",
          enabled: !0,
          phase: "beforeMain",
          fn: t => {
            this._getTipElement().setAttribute("data-popper-placement", t.state.placement)
          }
        }]
      };
      return {
        ...e,
        ..."function" == typeof this._config.popperConfig ? this._config.popperConfig(e) : this._config.popperConfig
      }
    }
    _setListeners() {
      const t = this._config.trigger.split(" ");
      for (const e of t)
        if ("click" === e) P.on(this._element, this.constructor.eventName("click"), this._config.selector, (t => this.toggle(t)));
        else if ("manual" !== e) {
        const t = e === en ? this.constructor.eventName("mouseenter") : this.constructor.eventName("focusin"),
          i = e === en ? this.constructor.eventName("mouseleave") : this.constructor.eventName("focusout");
        P.on(this._element, t, this._config.selector, (t => {
          const e = this._initializeOnDelegatedTarget(t);
          e._activeTrigger["focusin" === t.type ? nn : en] = !0, e._enter()
        })), P.on(this._element, i, this._config.selector, (t => {
          const e = this._initializeOnDelegatedTarget(t);
          e._activeTrigger["focusout" === t.type ? nn : en] = e._element.contains(t.relatedTarget), e._leave()
        }))
      }
      this._hideModalHandler = () => {
        this._element && this.hide()
      }, P.on(this._element.closest(Zi), tn, this._hideModalHandler), this._config.selector ? this._config = {
        ...this._config,
        trigger: "manual",
        selector: ""
      } : this._fixTitle()
    }
    _fixTitle() {
      const t = this._config.originalTitle;
      t && (this._element.getAttribute("aria-label") || this._element.textContent.trim() || this._element.setAttribute("aria-label", t), this._element.removeAttribute("title"))
    }
    _enter() {
      this._isShown() || this._isHovered ? this._isHovered = !0 : (this._isHovered = !0, this._setTimeout((() => {
        this._isHovered && this.show()
      }), this._config.delay.show))
    }
    _leave() {
      this._isWithActiveTrigger() || (this._isHovered = !1, this._setTimeout((() => {
        this._isHovered || this.hide()
      }), this._config.delay.hide))
    }
    _setTimeout(t, e) {
      clearTimeout(this._timeout), this._timeout = setTimeout(t, e)
    }
    _isWithActiveTrigger() {
      return Object.values(this._activeTrigger).includes(!0)
    }
    _getConfig(t) {
      const e = B.getDataAttributes(this._element);
      for (const t of Object.keys(e)) Ui.has(t) && delete e[t];
      return t = {
        ...e,
        ..."object" == typeof t && t ? t : {}
      }, t = this._mergeConfigObj(t), t = this._configAfterMerge(t), this._typeCheckConfig(t), t
    }
    _configAfterMerge(t) {
      return t.container = !1 === t.container ? document.body : r(t.container), "number" == typeof t.delay && (t.delay = {
        show: t.delay,
        hide: t.delay
      }), t.originalTitle = this._element.getAttribute("title") || "", "number" == typeof t.title && (t.title = t.title.toString()), "number" == typeof t.content && (t.content = t.content.toString()), t
    }
    _getDelegateConfig() {
      const t = {};
      for (const e in this._config) this.constructor.Default[e] !== this._config[e] && (t[e] = this._config[e]);
      return t
    }
    _disposePopper() {
      this._popper && (this._popper.destroy(), this._popper = null)
    }
    static jQueryInterface(t) {
      return this.each((function () {
        const e = an.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
          e[t]()
        }
      }))
    }
  }
  g(an);
  const ln = {
      ...an.Default,
      content: "",
      offset: [0, 8],
      placement: "right",
      template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
      trigger: "click"
    },
    cn = {
      ...an.DefaultType,
      content: "(null|string|element|function)"
    };
  class hn extends an {
    static get Default() {
      return ln
    }
    static get DefaultType() {
      return cn
    }
    static get NAME() {
      return "popover"
    }
    _isWithContent() {
      return this._getTitle() || this._getContent()
    }
    _getContentForTemplate() {
      return {
        ".popover-header": this._getTitle(),
        ".popover-body": this._getContent()
      }
    }
    _getContent() {
      return this._resolvePossibleFunction(this._config.content)
    }
    static jQueryInterface(t) {
      return this.each((function () {
        const e = hn.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
          e[t]()
        }
      }))
    }
  }
  g(hn);
  const dn = "click.bs.scrollspy",
    un = "active",
    fn = "[href]",
    pn = {
      offset: null,
      rootMargin: "0px 0px -25%",
      smoothScroll: !1,
      target: null
    },
    gn = {
      offset: "(number|null)",
      rootMargin: "string",
      smoothScroll: "boolean",
      target: "element"
    };
  class mn extends z {
    constructor(t, e) {
      super(t, e), this._targetLinks = new Map, this._observableSections = new Map, this._rootElement = "visible" === getComputedStyle(this._element).overflowY ? null : this._element, this._activeTarget = null, this._observer = null, this._previousScrollData = {
        visibleEntryTop: 0,
        parentScrollTop: 0
      }, this.refresh()
    }
    static get Default() {
      return pn
    }
    static get DefaultType() {
      return gn
    }
    static get NAME() {
      return "scrollspy"
    }
    refresh() {
      this._initializeTargetsAndObservables(), this._maybeEnableSmoothScroll(), this._observer ? this._observer.disconnect() : this._observer = this._getNewObserver();
      for (const t of this._observableSections.values()) this._observer.observe(t)
    }
    dispose() {
      this._observer.disconnect(), super.dispose()
    }
    _configAfterMerge(t) {
      return t.target = r(t.target) || document.body, t
    }
    _maybeEnableSmoothScroll() {
      this._config.smoothScroll && (P.off(this._config.target, dn), P.on(this._config.target, dn, fn, (t => {
        const e = this._observableSections.get(t.target.hash);
        if (e) {
          t.preventDefault();
          const i = this._rootElement || window,
            n = e.offsetTop - this._element.offsetTop;
          if (i.scrollTo) return void i.scrollTo({
            top: n,
            behavior: "smooth"
          });
          i.scrollTop = n
        }
      })))
    }
    _getNewObserver() {
      const t = {
        root: this._rootElement,
        threshold: [.1, .5, 1],
        rootMargin: this._getRootMargin()
      };
      return new IntersectionObserver((t => this._observerCallback(t)), t)
    }
    _observerCallback(t) {
      const e = t => this._targetLinks.get(`#${t.target.id}`),
        i = t => {
          this._previousScrollData.visibleEntryTop = t.target.offsetTop, this._process(e(t))
        },
        n = (this._rootElement || document.documentElement).scrollTop,
        s = n >= this._previousScrollData.parentScrollTop;
      this._previousScrollData.parentScrollTop = n;
      for (const o of t) {
        if (!o.isIntersecting) {
          this._activeTarget = null, this._clearActiveClass(e(o));
          continue
        }
        const t = o.target.offsetTop >= this._previousScrollData.visibleEntryTop;
        if (s && t) {
          if (i(o), !n) return
        } else s || t || i(o)
      }
    }
    _getRootMargin() {
      return this._config.offset ? `${this._config.offset}px 0px -30%` : this._config.rootMargin
    }
    _initializeTargetsAndObservables() {
      this._targetLinks = new Map, this._observableSections = new Map;
      const t = Q.find(fn, this._config.target);
      for (const e of t) {
        if (!e.hash || l(e)) continue;
        const t = Q.findOne(e.hash, this._element);
        a(t) && (this._targetLinks.set(e.hash, e), this._observableSections.set(e.hash, t))
      }
    }
    _process(t) {
      this._activeTarget !== t && (this._clearActiveClass(this._config.target), this._activeTarget = t, t.classList.add(un), this._activateParents(t), P.trigger(this._element, "activate.bs.scrollspy", {
        relatedTarget: t
      }))
    }
    _activateParents(t) {
      if (t.classList.contains("dropdown-item")) Q.findOne(".dropdown-toggle", t.closest(".dropdown")).classList.add(un);
      else
        for (const e of Q.parents(t, ".nav, .list-group"))
          for (const t of Q.prev(e, ".nav-link, .nav-item > .nav-link, .list-group-item")) t.classList.add(un)
    }
    _clearActiveClass(t) {
      t.classList.remove(un);
      const e = Q.find("[href].active", t);
      for (const t of e) t.classList.remove(un)
    }
    static jQueryInterface(t) {
      return this.each((function () {
        const e = mn.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
          e[t]()
        }
      }))
    }
  }
  P.on(window, "load.bs.scrollspy.data-api", (() => {
    for (const t of Q.find('[data-bs-spy="scroll"]')) mn.getOrCreateInstance(t)
  })), g(mn);
  const _n = "ArrowLeft",
    bn = "ArrowRight",
    vn = "ArrowUp",
    yn = "ArrowDown",
    wn = "active",
    An = "fade",
    En = "show",
    Tn = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]',
    Cn = `.nav-link:not(.dropdown-toggle), .list-group-item:not(.dropdown-toggle), [role="tab"]:not(.dropdown-toggle), ${Tn}`;
  class On extends z {
    constructor(t) {
      super(t), this._parent = this._element.closest('.list-group, .nav, [role="tablist"]'), this._parent && (this._setInitialAttributes(this._parent, this._getChildren()), P.on(this._element, "keydown.bs.tab", (t => this._keydown(t))))
    }
    static get NAME() {
      return "tab"
    }
    show() {
      const t = this._element;
      if (this._elemIsActive(t)) return;
      const e = this._getActiveElem(),
        i = e ? P.trigger(e, "hide.bs.tab", {
          relatedTarget: t
        }) : null;
      P.trigger(t, "show.bs.tab", {
        relatedTarget: e
      }).defaultPrevented || i && i.defaultPrevented || (this._deactivate(e, t), this._activate(t, e))
    }
    _activate(t, e) {
      t && (t.classList.add(wn), this._activate(n(t)), this._queueCallback((() => {
        "tab" === t.getAttribute("role") ? (t.focus(), t.removeAttribute("tabindex"), t.setAttribute("aria-selected", !0), this._toggleDropDown(t, !0), P.trigger(t, "shown.bs.tab", {
          relatedTarget: e
        })) : t.classList.add(En)
      }), t, t.classList.contains(An)))
    }
    _deactivate(t, e) {
      t && (t.classList.remove(wn), t.blur(), this._deactivate(n(t)), this._queueCallback((() => {
        "tab" === t.getAttribute("role") ? (t.setAttribute("aria-selected", !1), t.setAttribute("tabindex", "-1"), this._toggleDropDown(t, !1), P.trigger(t, "hidden.bs.tab", {
          relatedTarget: e
        })) : t.classList.remove(En)
      }), t, t.classList.contains(An)))
    }
    _keydown(t) {
      if (![_n, bn, vn, yn].includes(t.key)) return;
      t.stopPropagation(), t.preventDefault();
      const e = [bn, yn].includes(t.key),
        i = b(this._getChildren().filter((t => !l(t))), t.target, e, !0);
      i && On.getOrCreateInstance(i).show()
    }
    _getChildren() {
      return Q.find(Cn, this._parent)
    }
    _getActiveElem() {
      return this._getChildren().find((t => this._elemIsActive(t))) || null
    }
    _setInitialAttributes(t, e) {
      this._setAttributeIfNotExists(t, "role", "tablist");
      for (const t of e) this._setInitialAttributesOnChild(t)
    }
    _setInitialAttributesOnChild(t) {
      t = this._getInnerElement(t);
      const e = this._elemIsActive(t),
        i = this._getOuterElement(t);
      t.setAttribute("aria-selected", e), i !== t && this._setAttributeIfNotExists(i, "role", "presentation"), e || t.setAttribute("tabindex", "-1"), this._setAttributeIfNotExists(t, "role", "tab"), this._setInitialAttributesOnTargetPanel(t)
    }
    _setInitialAttributesOnTargetPanel(t) {
      const e = n(t);
      e && (this._setAttributeIfNotExists(e, "role", "tabpanel"), t.id && this._setAttributeIfNotExists(e, "aria-labelledby", `#${t.id}`))
    }
    _toggleDropDown(t, e) {
      const i = this._getOuterElement(t);
      if (!i.classList.contains("dropdown")) return;
      const n = (t, n) => {
        const s = Q.findOne(t, i);
        s && s.classList.toggle(n, e)
      };
      n(".dropdown-toggle", wn), n(".dropdown-menu", En), n(".dropdown-item", wn), i.setAttribute("aria-expanded", e)
    }
    _setAttributeIfNotExists(t, e, i) {
      t.hasAttribute(e) || t.setAttribute(e, i)
    }
    _elemIsActive(t) {
      return t.classList.contains(wn)
    }
    _getInnerElement(t) {
      return t.matches(Cn) ? t : Q.findOne(Cn, t)
    }
    _getOuterElement(t) {
      return t.closest(".nav-item, .list-group-item") || t
    }
    static jQueryInterface(t) {
      return this.each((function () {
        const e = On.getOrCreateInstance(this);
        if ("string" == typeof t) {
          if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
          e[t]()
        }
      }))
    }
  }
  P.on(document, "click.bs.tab", Tn, (function (t) {
    ["A", "AREA"].includes(this.tagName) && t.preventDefault(), l(this) || On.getOrCreateInstance(this).show()
  })), P.on(window, "load.bs.tab", (() => {
    for (const t of Q.find('.active[data-bs-toggle="tab"], .active[data-bs-toggle="pill"], .active[data-bs-toggle="list"]')) On.getOrCreateInstance(t)
  })), g(On);
  const xn = "hide",
    kn = "show",
    Ln = "showing",
    Dn = {
      animation: "boolean",
      autohide: "boolean",
      delay: "number"
    },
    Sn = {
      animation: !0,
      autohide: !0,
      delay: 5e3
    };
  class In extends z {
    constructor(t, e) {
      super(t, e), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners()
    }
    static get Default() {
      return Sn
    }
    static get DefaultType() {
      return Dn
    }
    static get NAME() {
      return "toast"
    }
    show() {
      P.trigger(this._element, "show.bs.toast").defaultPrevented || (this._clearTimeout(), this._config.animation && this._element.classList.add("fade"), this._element.classList.remove(xn), d(this._element), this._element.classList.add(kn, Ln), this._queueCallback((() => {
        this._element.classList.remove(Ln), P.trigger(this._element, "shown.bs.toast"), this._maybeScheduleHide()
      }), this._element, this._config.animation))
    }
    hide() {
      this.isShown() && (P.trigger(this._element, "hide.bs.toast").defaultPrevented || (this._element.classList.add(Ln), this._queueCallback((() => {
        this._element.classList.add(xn), this._element.classList.remove(Ln, kn), P.trigger(this._element, "hidden.bs.toast")
      }), this._element, this._config.animation)))
    }
    dispose() {
      this._clearTimeout(), this.isShown() && this._element.classList.remove(kn), super.dispose()
    }
    isShown() {
      return this._element.classList.contains(kn)
    }
    _maybeScheduleHide() {
      this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout((() => {
        this.hide()
      }), this._config.delay)))
    }
    _onInteraction(t, e) {
      switch (t.type) {
        case "mouseover":
        case "mouseout":
          this._hasMouseInteraction = e;
          break;
        case "focusin":
        case "focusout":
          this._hasKeyboardInteraction = e
      }
      if (e) return void this._clearTimeout();
      const i = t.relatedTarget;
      this._element === i || this._element.contains(i) || this._maybeScheduleHide()
    }
    _setListeners() {
      P.on(this._element, "mouseover.bs.toast", (t => this._onInteraction(t, !0))), P.on(this._element, "mouseout.bs.toast", (t => this._onInteraction(t, !1))), P.on(this._element, "focusin.bs.toast", (t => this._onInteraction(t, !0))), P.on(this._element, "focusout.bs.toast", (t => this._onInteraction(t, !1)))
    }
    _clearTimeout() {
      clearTimeout(this._timeout), this._timeout = null
    }
    static jQueryInterface(t) {
      return this.each((function () {
        const e = In.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
          e[t](this)
        }
      }))
    }
  }
  return R(In), g(In), {
    Alert: q,
    Button: K,
    Carousel: at,
    Collapse: pt,
    Dropdown: li,
    Modal: Si,
    Offcanvas: Bi,
    Popover: hn,
    ScrollSpy: mn,
    Tab: On,
    Toast: In,
    Tooltip: an
  }
}));
//# sourceMappingURL=bootstrap.bundle.min.js.map
/*!
 * clipboard.js v2.0.11
 * https://clipboardjs.com/
 *
 * Licensed MIT © Zeno Rocha
 */
! function (t, e) {
  "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports ? exports.ClipboardJS = e() : t.ClipboardJS = e()
}(this, function () {
  return n = {
    686: function (t, e, n) {
      "use strict";
      n.d(e, {
        default: function () {
          return b
        }
      });
      var e = n(279),
        i = n.n(e),
        e = n(370),
        u = n.n(e),
        e = n(817),
        r = n.n(e);

      function c(t) {
        try {
          return document.execCommand(t)
        } catch (t) {
          return
        }
      }
      var a = function (t) {
        t = r()(t);
        return c("cut"), t
      };

      function o(t, e) {
        var n, o, t = (n = t, o = "rtl" === document.documentElement.getAttribute("dir"), (t = document.createElement("textarea")).style.fontSize = "12pt", t.style.border = "0", t.style.padding = "0", t.style.margin = "0", t.style.position = "absolute", t.style[o ? "right" : "left"] = "-9999px", o = window.pageYOffset || document.documentElement.scrollTop, t.style.top = "".concat(o, "px"), t.setAttribute("readonly", ""), t.value = n, t);
        return e.container.appendChild(t), e = r()(t), c("copy"), t.remove(), e
      }
      var f = function (t) {
        var e = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {
            container: document.body
          },
          n = "";
        return "string" == typeof t ? n = o(t, e) : t instanceof HTMLInputElement && !["text", "search", "url", "tel", "password"].includes(null == t ? void 0 : t.type) ? n = o(t.value, e) : (n = r()(t), c("copy")), n
      };

      function l(t) {
        return (l = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
      }
      var s = function () {
        var t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {},
          e = t.action,
          n = void 0 === e ? "copy" : e,
          o = t.container,
          e = t.target,
          t = t.text;
        if ("copy" !== n && "cut" !== n) throw new Error('Invalid "action" value, use either "copy" or "cut"');
        if (void 0 !== e) {
          if (!e || "object" !== l(e) || 1 !== e.nodeType) throw new Error('Invalid "target" value, use a valid Element');
          if ("copy" === n && e.hasAttribute("disabled")) throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute');
          if ("cut" === n && (e.hasAttribute("readonly") || e.hasAttribute("disabled"))) throw new Error('Invalid "target" attribute. You can\'t cut text from elements with "readonly" or "disabled" attributes')
        }
        return t ? f(t, {
          container: o
        }) : e ? "cut" === n ? a(e) : f(e, {
          container: o
        }) : void 0
      };

      function p(t) {
        return (p = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
          return typeof t
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
      }

      function d(t, e) {
        for (var n = 0; n < e.length; n++) {
          var o = e[n];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o)
        }
      }

      function y(t, e) {
        return (y = Object.setPrototypeOf || function (t, e) {
          return t.__proto__ = e, t
        })(t, e)
      }

      function h(n) {
        var o = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0
          } catch (t) {
            return !1
          }
        }();
        return function () {
          var t, e = v(n);
          return t = o ? (t = v(this).constructor, Reflect.construct(e, arguments, t)) : e.apply(this, arguments), e = this, !(t = t) || "object" !== p(t) && "function" != typeof t ? function (t) {
            if (void 0 !== t) return t;
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
          }(e) : t
        }
      }

      function v(t) {
        return (v = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
      }

      function m(t, e) {
        t = "data-clipboard-".concat(t);
        if (e.hasAttribute(t)) return e.getAttribute(t)
      }
      var b = function () {
        ! function (t, e) {
          if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              writable: !0,
              configurable: !0
            }
          }), e && y(t, e)
        }(r, i());
        var t, e, n, o = h(r);

        function r(t, e) {
          var n;
          return function (t) {
            if (!(t instanceof r)) throw new TypeError("Cannot call a class as a function")
          }(this), (n = o.call(this)).resolveOptions(e), n.listenClick(t), n
        }
        return t = r, n = [{
          key: "copy",
          value: function (t) {
            var e = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {
              container: document.body
            };
            return f(t, e)
          }
        }, {
          key: "cut",
          value: function (t) {
            return a(t)
          }
        }, {
          key: "isSupported",
          value: function () {
            var t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : ["copy", "cut"],
              t = "string" == typeof t ? [t] : t,
              e = !!document.queryCommandSupported;
            return t.forEach(function (t) {
              e = e && !!document.queryCommandSupported(t)
            }), e
          }
        }], (e = [{
          key: "resolveOptions",
          value: function () {
            var t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};
            this.action = "function" == typeof t.action ? t.action : this.defaultAction, this.target = "function" == typeof t.target ? t.target : this.defaultTarget, this.text = "function" == typeof t.text ? t.text : this.defaultText, this.container = "object" === p(t.container) ? t.container : document.body
          }
        }, {
          key: "listenClick",
          value: function (t) {
            var e = this;
            this.listener = u()(t, "click", function (t) {
              return e.onClick(t)
            })
          }
        }, {
          key: "onClick",
          value: function (t) {
            var e = t.delegateTarget || t.currentTarget,
              n = this.action(e) || "copy",
              t = s({
                action: n,
                container: this.container,
                target: this.target(e),
                text: this.text(e)
              });
            this.emit(t ? "success" : "error", {
              action: n,
              text: t,
              trigger: e,
              clearSelection: function () {
                e && e.focus(), window.getSelection().removeAllRanges()
              }
            })
          }
        }, {
          key: "defaultAction",
          value: function (t) {
            return m("action", t)
          }
        }, {
          key: "defaultTarget",
          value: function (t) {
            t = m("target", t);
            if (t) return document.querySelector(t)
          }
        }, {
          key: "defaultText",
          value: function (t) {
            return m("text", t)
          }
        }, {
          key: "destroy",
          value: function () {
            this.listener.destroy()
          }
        }]) && d(t.prototype, e), n && d(t, n), r
      }()
    },
    828: function (t) {
      var e;
      "undefined" == typeof Element || Element.prototype.matches || ((e = Element.prototype).matches = e.matchesSelector || e.mozMatchesSelector || e.msMatchesSelector || e.oMatchesSelector || e.webkitMatchesSelector), t.exports = function (t, e) {
        for (; t && 9 !== t.nodeType;) {
          if ("function" == typeof t.matches && t.matches(e)) return t;
          t = t.parentNode
        }
      }
    },
    438: function (t, e, n) {
      var u = n(828);

      function i(t, e, n, o, r) {
        var i = function (e, n, t, o) {
          return function (t) {
            t.delegateTarget = u(t.target, n), t.delegateTarget && o.call(e, t)
          }
        }.apply(this, arguments);
        return t.addEventListener(n, i, r), {
          destroy: function () {
            t.removeEventListener(n, i, r)
          }
        }
      }
      t.exports = function (t, e, n, o, r) {
        return "function" == typeof t.addEventListener ? i.apply(null, arguments) : "function" == typeof n ? i.bind(null, document).apply(null, arguments) : ("string" == typeof t && (t = document.querySelectorAll(t)), Array.prototype.map.call(t, function (t) {
          return i(t, e, n, o, r)
        }))
      }
    },
    879: function (t, n) {
      n.node = function (t) {
        return void 0 !== t && t instanceof HTMLElement && 1 === t.nodeType
      }, n.nodeList = function (t) {
        var e = Object.prototype.toString.call(t);
        return void 0 !== t && ("[object NodeList]" === e || "[object HTMLCollection]" === e) && "length" in t && (0 === t.length || n.node(t[0]))
      }, n.string = function (t) {
        return "string" == typeof t || t instanceof String
      }, n.fn = function (t) {
        return "[object Function]" === Object.prototype.toString.call(t)
      }
    },
    370: function (t, e, n) {
      var f = n(879),
        l = n(438);
      t.exports = function (t, e, n) {
        if (!t && !e && !n) throw new Error("Missing required arguments");
        if (!f.string(e)) throw new TypeError("Second argument must be a String");
        if (!f.fn(n)) throw new TypeError("Third argument must be a Function");
        if (f.node(t)) return c = e, a = n, (u = t).addEventListener(c, a), {
          destroy: function () {
            u.removeEventListener(c, a)
          }
        };
        if (f.nodeList(t)) return o = t, r = e, i = n, Array.prototype.forEach.call(o, function (t) {
          t.addEventListener(r, i)
        }), {
          destroy: function () {
            Array.prototype.forEach.call(o, function (t) {
              t.removeEventListener(r, i)
            })
          }
        };
        if (f.string(t)) return t = t, e = e, n = n, l(document.body, t, e, n);
        throw new TypeError("First argument must be a String, HTMLElement, HTMLCollection, or NodeList");
        var o, r, i, u, c, a
      }
    },
    817: function (t) {
      t.exports = function (t) {
        var e, n = "SELECT" === t.nodeName ? (t.focus(), t.value) : "INPUT" === t.nodeName || "TEXTAREA" === t.nodeName ? ((e = t.hasAttribute("readonly")) || t.setAttribute("readonly", ""), t.select(), t.setSelectionRange(0, t.value.length), e || t.removeAttribute("readonly"), t.value) : (t.hasAttribute("contenteditable") && t.focus(), n = window.getSelection(), (e = document.createRange()).selectNodeContents(t), n.removeAllRanges(), n.addRange(e), n.toString());
        return n
      }
    },
    279: function (t) {
      function e() {}
      e.prototype = {
        on: function (t, e, n) {
          var o = this.e || (this.e = {});
          return (o[t] || (o[t] = [])).push({
            fn: e,
            ctx: n
          }), this
        },
        once: function (t, e, n) {
          var o = this;

          function r() {
            o.off(t, r), e.apply(n, arguments)
          }
          return r._ = e, this.on(t, r, n)
        },
        emit: function (t) {
          for (var e = [].slice.call(arguments, 1), n = ((this.e || (this.e = {}))[t] || []).slice(), o = 0, r = n.length; o < r; o++) n[o].fn.apply(n[o].ctx, e);
          return this
        },
        off: function (t, e) {
          var n = this.e || (this.e = {}),
            o = n[t],
            r = [];
          if (o && e)
            for (var i = 0, u = o.length; i < u; i++) o[i].fn !== e && o[i].fn._ !== e && r.push(o[i]);
          return r.length ? n[t] = r : delete n[t], this
        }
      }, t.exports = e, t.exports.TinyEmitter = e
    }
  }, r = {}, o.n = function (t) {
    var e = t && t.__esModule ? function () {
      return t.default
    } : function () {
      return t
    };
    return o.d(e, {
      a: e
    }), e
  }, o.d = function (t, e) {
    for (var n in e) o.o(e, n) && !o.o(t, n) && Object.defineProperty(t, n, {
      enumerable: !0,
      get: e[n]
    })
  }, o.o = function (t, e) {
    return Object.prototype.hasOwnProperty.call(t, e)
  }, o(686).default;

  function o(t) {
    if (r[t]) return r[t].exports;
    var e = r[t] = {
      exports: {}
    };
    return n[t](e, e.exports, o), e.exports
  }
  var n, r
});
/*!
 * Chart.js v3.9.1
 * https://www.chartjs.org
 * (c) 2022 Chart.js Contributors
 * Released under the MIT License
 */
! function (t, e) {
  "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).Chart = e()
}(this, (function () {
  "use strict";

  function t() {}
  const e = function () {
    let t = 0;
    return function () {
      return t++
    }
  }();

  function i(t) {
    return null == t
  }

  function s(t) {
    if (Array.isArray && Array.isArray(t)) return !0;
    const e = Object.prototype.toString.call(t);
    return "[object" === e.slice(0, 7) && "Array]" === e.slice(-6)
  }

  function n(t) {
    return null !== t && "[object Object]" === Object.prototype.toString.call(t)
  }
  const o = t => ("number" == typeof t || t instanceof Number) && isFinite(+t);

  function a(t, e) {
    return o(t) ? t : e
  }

  function r(t, e) {
    return void 0 === t ? e : t
  }
  const l = (t, e) => "string" == typeof t && t.endsWith("%") ? parseFloat(t) / 100 : t / e,
    h = (t, e) => "string" == typeof t && t.endsWith("%") ? parseFloat(t) / 100 * e : +t;

  function c(t, e, i) {
    if (t && "function" == typeof t.call) return t.apply(i, e)
  }

  function d(t, e, i, o) {
    let a, r, l;
    if (s(t))
      if (r = t.length, o)
        for (a = r - 1; a >= 0; a--) e.call(i, t[a], a);
      else
        for (a = 0; a < r; a++) e.call(i, t[a], a);
    else if (n(t))
      for (l = Object.keys(t), r = l.length, a = 0; a < r; a++) e.call(i, t[l[a]], l[a])
  }

  function u(t, e) {
    let i, s, n, o;
    if (!t || !e || t.length !== e.length) return !1;
    for (i = 0, s = t.length; i < s; ++i)
      if (n = t[i], o = e[i], n.datasetIndex !== o.datasetIndex || n.index !== o.index) return !1;
    return !0
  }

  function f(t) {
    if (s(t)) return t.map(f);
    if (n(t)) {
      const e = Object.create(null),
        i = Object.keys(t),
        s = i.length;
      let n = 0;
      for (; n < s; ++n) e[i[n]] = f(t[i[n]]);
      return e
    }
    return t
  }

  function g(t) {
    return -1 === ["__proto__", "prototype", "constructor"].indexOf(t)
  }

  function p(t, e, i, s) {
    if (!g(t)) return;
    const o = e[t],
      a = i[t];
    n(o) && n(a) ? m(o, a, s) : e[t] = f(a)
  }

  function m(t, e, i) {
    const o = s(e) ? e : [e],
      a = o.length;
    if (!n(t)) return t;
    const r = (i = i || {}).merger || p;
    for (let s = 0; s < a; ++s) {
      if (!n(e = o[s])) continue;
      const a = Object.keys(e);
      for (let s = 0, n = a.length; s < n; ++s) r(a[s], t, e, i)
    }
    return t
  }

  function b(t, e) {
    return m(t, e, {
      merger: x
    })
  }

  function x(t, e, i) {
    if (!g(t)) return;
    const s = e[t],
      o = i[t];
    n(s) && n(o) ? b(s, o) : Object.prototype.hasOwnProperty.call(e, t) || (e[t] = f(o))
  }
  const _ = {
    "": t => t,
    x: t => t.x,
    y: t => t.y
  };

  function y(t, e) {
    const i = _[e] || (_[e] = function (t) {
      const e = v(t);
      return t => {
        for (const i of e) {
          if ("" === i) break;
          t = t && t[i]
        }
        return t
      }
    }(e));
    return i(t)
  }

  function v(t) {
    const e = t.split("."),
      i = [];
    let s = "";
    for (const t of e) s += t, s.endsWith("\\") ? s = s.slice(0, -1) + "." : (i.push(s), s = "");
    return i
  }

  function w(t) {
    return t.charAt(0).toUpperCase() + t.slice(1)
  }
  const M = t => void 0 !== t,
    k = t => "function" == typeof t,
    S = (t, e) => {
      if (t.size !== e.size) return !1;
      for (const i of t)
        if (!e.has(i)) return !1;
      return !0
    };

  function P(t) {
    return "mouseup" === t.type || "click" === t.type || "contextmenu" === t.type
  }
  const D = Math.PI,
    O = 2 * D,
    C = O + D,
    A = Number.POSITIVE_INFINITY,
    T = D / 180,
    L = D / 2,
    E = D / 4,
    R = 2 * D / 3,
    I = Math.log10,
    z = Math.sign;

  function F(t) {
    const e = Math.round(t);
    t = N(t, e, t / 1e3) ? e : t;
    const i = Math.pow(10, Math.floor(I(t))),
      s = t / i;
    return (s <= 1 ? 1 : s <= 2 ? 2 : s <= 5 ? 5 : 10) * i
  }

  function V(t) {
    const e = [],
      i = Math.sqrt(t);
    let s;
    for (s = 1; s < i; s++) t % s == 0 && (e.push(s), e.push(t / s));
    return i === (0 | i) && e.push(i), e.sort(((t, e) => t - e)).pop(), e
  }

  function B(t) {
    return !isNaN(parseFloat(t)) && isFinite(t)
  }

  function N(t, e, i) {
    return Math.abs(t - e) < i
  }

  function W(t, e) {
    const i = Math.round(t);
    return i - e <= t && i + e >= t
  }

  function j(t, e, i) {
    let s, n, o;
    for (s = 0, n = t.length; s < n; s++) o = t[s][i], isNaN(o) || (e.min = Math.min(e.min, o), e.max = Math.max(e.max, o))
  }

  function H(t) {
    return t * (D / 180)
  }

  function $(t) {
    return t * (180 / D)
  }

  function Y(t) {
    if (!o(t)) return;
    let e = 1,
      i = 0;
    for (; Math.round(t * e) / e !== t;) e *= 10, i++;
    return i
  }

  function U(t, e) {
    const i = e.x - t.x,
      s = e.y - t.y,
      n = Math.sqrt(i * i + s * s);
    let o = Math.atan2(s, i);
    return o < -.5 * D && (o += O), {
      angle: o,
      distance: n
    }
  }

  function X(t, e) {
    return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2))
  }

  function q(t, e) {
    return (t - e + C) % O - D
  }

  function K(t) {
    return (t % O + O) % O
  }

  function G(t, e, i, s) {
    const n = K(t),
      o = K(e),
      a = K(i),
      r = K(o - n),
      l = K(a - n),
      h = K(n - o),
      c = K(n - a);
    return n === o || n === a || s && o === a || r > l && h < c
  }

  function Z(t, e, i) {
    return Math.max(e, Math.min(i, t))
  }

  function J(t) {
    return Z(t, -32768, 32767)
  }

  function Q(t, e, i, s = 1e-6) {
    return t >= Math.min(e, i) - s && t <= Math.max(e, i) + s
  }

  function tt(t, e, i) {
    i = i || (i => t[i] < e);
    let s, n = t.length - 1,
      o = 0;
    for (; n - o > 1;) s = o + n >> 1, i(s) ? o = s : n = s;
    return {
      lo: o,
      hi: n
    }
  }
  const et = (t, e, i, s) => tt(t, i, s ? s => t[s][e] <= i : s => t[s][e] < i),
    it = (t, e, i) => tt(t, i, (s => t[s][e] >= i));

  function st(t, e, i) {
    let s = 0,
      n = t.length;
    for (; s < n && t[s] < e;) s++;
    for (; n > s && t[n - 1] > i;) n--;
    return s > 0 || n < t.length ? t.slice(s, n) : t
  }
  const nt = ["push", "pop", "shift", "splice", "unshift"];

  function ot(t, e) {
    t._chartjs ? t._chartjs.listeners.push(e) : (Object.defineProperty(t, "_chartjs", {
      configurable: !0,
      enumerable: !1,
      value: {
        listeners: [e]
      }
    }), nt.forEach((e => {
      const i = "_onData" + w(e),
        s = t[e];
      Object.defineProperty(t, e, {
        configurable: !0,
        enumerable: !1,
        value(...e) {
          const n = s.apply(this, e);
          return t._chartjs.listeners.forEach((t => {
            "function" == typeof t[i] && t[i](...e)
          })), n
        }
      })
    })))
  }

  function at(t, e) {
    const i = t._chartjs;
    if (!i) return;
    const s = i.listeners,
      n = s.indexOf(e); - 1 !== n && s.splice(n, 1), s.length > 0 || (nt.forEach((e => {
      delete t[e]
    })), delete t._chartjs)
  }

  function rt(t) {
    const e = new Set;
    let i, s;
    for (i = 0, s = t.length; i < s; ++i) e.add(t[i]);
    return e.size === s ? t : Array.from(e)
  }
  const lt = "undefined" == typeof window ? function (t) {
    return t()
  } : window.requestAnimationFrame;

  function ht(t, e, i) {
    const s = i || (t => Array.prototype.slice.call(t));
    let n = !1,
      o = [];
    return function (...i) {
      o = s(i), n || (n = !0, lt.call(window, (() => {
        n = !1, t.apply(e, o)
      })))
    }
  }

  function ct(t, e) {
    let i;
    return function (...s) {
      return e ? (clearTimeout(i), i = setTimeout(t, e, s)) : t.apply(this, s), e
    }
  }
  const dt = t => "start" === t ? "left" : "end" === t ? "right" : "center",
    ut = (t, e, i) => "start" === t ? e : "end" === t ? i : (e + i) / 2,
    ft = (t, e, i, s) => t === (s ? "left" : "right") ? i : "center" === t ? (e + i) / 2 : e;

  function gt(t, e, i) {
    const s = e.length;
    let n = 0,
      o = s;
    if (t._sorted) {
      const {
        iScale: a,
        _parsed: r
      } = t, l = a.axis, {
        min: h,
        max: c,
        minDefined: d,
        maxDefined: u
      } = a.getUserBounds();
      d && (n = Z(Math.min(et(r, a.axis, h).lo, i ? s : et(e, l, a.getPixelForValue(h)).lo), 0, s - 1)), o = u ? Z(Math.max(et(r, a.axis, c, !0).hi + 1, i ? 0 : et(e, l, a.getPixelForValue(c), !0).hi + 1), n, s) - n : s - n
    }
    return {
      start: n,
      count: o
    }
  }

  function pt(t) {
    const {
      xScale: e,
      yScale: i,
      _scaleRanges: s
    } = t, n = {
      xmin: e.min,
      xmax: e.max,
      ymin: i.min,
      ymax: i.max
    };
    if (!s) return t._scaleRanges = n, !0;
    const o = s.xmin !== e.min || s.xmax !== e.max || s.ymin !== i.min || s.ymax !== i.max;
    return Object.assign(s, n), o
  }
  var mt = new class {
    constructor() {
      this._request = null, this._charts = new Map, this._running = !1, this._lastDate = void 0
    }
    _notify(t, e, i, s) {
      const n = e.listeners[s],
        o = e.duration;
      n.forEach((s => s({
        chart: t,
        initial: e.initial,
        numSteps: o,
        currentStep: Math.min(i - e.start, o)
      })))
    }
    _refresh() {
      this._request || (this._running = !0, this._request = lt.call(window, (() => {
        this._update(), this._request = null, this._running && this._refresh()
      })))
    }
    _update(t = Date.now()) {
      let e = 0;
      this._charts.forEach(((i, s) => {
        if (!i.running || !i.items.length) return;
        const n = i.items;
        let o, a = n.length - 1,
          r = !1;
        for (; a >= 0; --a) o = n[a], o._active ? (o._total > i.duration && (i.duration = o._total), o.tick(t), r = !0) : (n[a] = n[n.length - 1], n.pop());
        r && (s.draw(), this._notify(s, i, t, "progress")), n.length || (i.running = !1, this._notify(s, i, t, "complete"), i.initial = !1), e += n.length
      })), this._lastDate = t, 0 === e && (this._running = !1)
    }
    _getAnims(t) {
      const e = this._charts;
      let i = e.get(t);
      return i || (i = {
        running: !1,
        initial: !0,
        items: [],
        listeners: {
          complete: [],
          progress: []
        }
      }, e.set(t, i)), i
    }
    listen(t, e, i) {
      this._getAnims(t).listeners[e].push(i)
    }
    add(t, e) {
      e && e.length && this._getAnims(t).items.push(...e)
    }
    has(t) {
      return this._getAnims(t).items.length > 0
    }
    start(t) {
      const e = this._charts.get(t);
      e && (e.running = !0, e.start = Date.now(), e.duration = e.items.reduce(((t, e) => Math.max(t, e._duration)), 0), this._refresh())
    }
    running(t) {
      if (!this._running) return !1;
      const e = this._charts.get(t);
      return !!(e && e.running && e.items.length)
    }
    stop(t) {
      const e = this._charts.get(t);
      if (!e || !e.items.length) return;
      const i = e.items;
      let s = i.length - 1;
      for (; s >= 0; --s) i[s].cancel();
      e.items = [], this._notify(t, e, Date.now(), "complete")
    }
    remove(t) {
      return this._charts.delete(t)
    }
  };
  /*!
   * @kurkle/color v0.2.1
   * https://github.com/kurkle/color#readme
   * (c) 2022 Jukka Kurkela
   * Released under the MIT License
   */
  function bt(t) {
    return t + .5 | 0
  }
  const xt = (t, e, i) => Math.max(Math.min(t, i), e);

  function _t(t) {
    return xt(bt(2.55 * t), 0, 255)
  }

  function yt(t) {
    return xt(bt(255 * t), 0, 255)
  }

  function vt(t) {
    return xt(bt(t / 2.55) / 100, 0, 1)
  }

  function wt(t) {
    return xt(bt(100 * t), 0, 100)
  }
  const Mt = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      A: 10,
      B: 11,
      C: 12,
      D: 13,
      E: 14,
      F: 15,
      a: 10,
      b: 11,
      c: 12,
      d: 13,
      e: 14,
      f: 15
    },
    kt = [..."0123456789ABCDEF"],
    St = t => kt[15 & t],
    Pt = t => kt[(240 & t) >> 4] + kt[15 & t],
    Dt = t => (240 & t) >> 4 == (15 & t);

  function Ot(t) {
    var e = (t => Dt(t.r) && Dt(t.g) && Dt(t.b) && Dt(t.a))(t) ? St : Pt;
    return t ? "#" + e(t.r) + e(t.g) + e(t.b) + ((t, e) => t < 255 ? e(t) : "")(t.a, e) : void 0
  }
  const Ct = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;

  function At(t, e, i) {
    const s = e * Math.min(i, 1 - i),
      n = (e, n = (e + t / 30) % 12) => i - s * Math.max(Math.min(n - 3, 9 - n, 1), -1);
    return [n(0), n(8), n(4)]
  }

  function Tt(t, e, i) {
    const s = (s, n = (s + t / 60) % 6) => i - i * e * Math.max(Math.min(n, 4 - n, 1), 0);
    return [s(5), s(3), s(1)]
  }

  function Lt(t, e, i) {
    const s = At(t, 1, .5);
    let n;
    for (e + i > 1 && (n = 1 / (e + i), e *= n, i *= n), n = 0; n < 3; n++) s[n] *= 1 - e - i, s[n] += e;
    return s
  }

  function Et(t) {
    const e = t.r / 255,
      i = t.g / 255,
      s = t.b / 255,
      n = Math.max(e, i, s),
      o = Math.min(e, i, s),
      a = (n + o) / 2;
    let r, l, h;
    return n !== o && (h = n - o, l = a > .5 ? h / (2 - n - o) : h / (n + o), r = function (t, e, i, s, n) {
      return t === n ? (e - i) / s + (e < i ? 6 : 0) : e === n ? (i - t) / s + 2 : (t - e) / s + 4
    }(e, i, s, h, n), r = 60 * r + .5), [0 | r, l || 0, a]
  }

  function Rt(t, e, i, s) {
    return (Array.isArray(e) ? t(e[0], e[1], e[2]) : t(e, i, s)).map(yt)
  }

  function It(t, e, i) {
    return Rt(At, t, e, i)
  }

  function zt(t) {
    return (t % 360 + 360) % 360
  }

  function Ft(t) {
    const e = Ct.exec(t);
    let i, s = 255;
    if (!e) return;
    e[5] !== i && (s = e[6] ? _t(+e[5]) : yt(+e[5]));
    const n = zt(+e[2]),
      o = +e[3] / 100,
      a = +e[4] / 100;
    return i = "hwb" === e[1] ? function (t, e, i) {
      return Rt(Lt, t, e, i)
    }(n, o, a) : "hsv" === e[1] ? function (t, e, i) {
      return Rt(Tt, t, e, i)
    }(n, o, a) : It(n, o, a), {
      r: i[0],
      g: i[1],
      b: i[2],
      a: s
    }
  }
  const Vt = {
      x: "dark",
      Z: "light",
      Y: "re",
      X: "blu",
      W: "gr",
      V: "medium",
      U: "slate",
      A: "ee",
      T: "ol",
      S: "or",
      B: "ra",
      C: "lateg",
      D: "ights",
      R: "in",
      Q: "turquois",
      E: "hi",
      P: "ro",
      O: "al",
      N: "le",
      M: "de",
      L: "yello",
      F: "en",
      K: "ch",
      G: "arks",
      H: "ea",
      I: "ightg",
      J: "wh"
    },
    Bt = {
      OiceXe: "f0f8ff",
      antiquewEte: "faebd7",
      aqua: "ffff",
      aquamarRe: "7fffd4",
      azuY: "f0ffff",
      beige: "f5f5dc",
      bisque: "ffe4c4",
      black: "0",
      blanKedOmond: "ffebcd",
      Xe: "ff",
      XeviTet: "8a2be2",
      bPwn: "a52a2a",
      burlywood: "deb887",
      caMtXe: "5f9ea0",
      KartYuse: "7fff00",
      KocTate: "d2691e",
      cSO: "ff7f50",
      cSnflowerXe: "6495ed",
      cSnsilk: "fff8dc",
      crimson: "dc143c",
      cyan: "ffff",
      xXe: "8b",
      xcyan: "8b8b",
      xgTMnPd: "b8860b",
      xWay: "a9a9a9",
      xgYF: "6400",
      xgYy: "a9a9a9",
      xkhaki: "bdb76b",
      xmagFta: "8b008b",
      xTivegYF: "556b2f",
      xSange: "ff8c00",
      xScEd: "9932cc",
      xYd: "8b0000",
      xsOmon: "e9967a",
      xsHgYF: "8fbc8f",
      xUXe: "483d8b",
      xUWay: "2f4f4f",
      xUgYy: "2f4f4f",
      xQe: "ced1",
      xviTet: "9400d3",
      dAppRk: "ff1493",
      dApskyXe: "bfff",
      dimWay: "696969",
      dimgYy: "696969",
      dodgerXe: "1e90ff",
      fiYbrick: "b22222",
      flSOwEte: "fffaf0",
      foYstWAn: "228b22",
      fuKsia: "ff00ff",
      gaRsbSo: "dcdcdc",
      ghostwEte: "f8f8ff",
      gTd: "ffd700",
      gTMnPd: "daa520",
      Way: "808080",
      gYF: "8000",
      gYFLw: "adff2f",
      gYy: "808080",
      honeyMw: "f0fff0",
      hotpRk: "ff69b4",
      RdianYd: "cd5c5c",
      Rdigo: "4b0082",
      ivSy: "fffff0",
      khaki: "f0e68c",
      lavFMr: "e6e6fa",
      lavFMrXsh: "fff0f5",
      lawngYF: "7cfc00",
      NmoncEffon: "fffacd",
      ZXe: "add8e6",
      ZcSO: "f08080",
      Zcyan: "e0ffff",
      ZgTMnPdLw: "fafad2",
      ZWay: "d3d3d3",
      ZgYF: "90ee90",
      ZgYy: "d3d3d3",
      ZpRk: "ffb6c1",
      ZsOmon: "ffa07a",
      ZsHgYF: "20b2aa",
      ZskyXe: "87cefa",
      ZUWay: "778899",
      ZUgYy: "778899",
      ZstAlXe: "b0c4de",
      ZLw: "ffffe0",
      lime: "ff00",
      limegYF: "32cd32",
      lRF: "faf0e6",
      magFta: "ff00ff",
      maPon: "800000",
      VaquamarRe: "66cdaa",
      VXe: "cd",
      VScEd: "ba55d3",
      VpurpN: "9370db",
      VsHgYF: "3cb371",
      VUXe: "7b68ee",
      VsprRggYF: "fa9a",
      VQe: "48d1cc",
      VviTetYd: "c71585",
      midnightXe: "191970",
      mRtcYam: "f5fffa",
      mistyPse: "ffe4e1",
      moccasR: "ffe4b5",
      navajowEte: "ffdead",
      navy: "80",
      Tdlace: "fdf5e6",
      Tive: "808000",
      TivedBb: "6b8e23",
      Sange: "ffa500",
      SangeYd: "ff4500",
      ScEd: "da70d6",
      pOegTMnPd: "eee8aa",
      pOegYF: "98fb98",
      pOeQe: "afeeee",
      pOeviTetYd: "db7093",
      papayawEp: "ffefd5",
      pHKpuff: "ffdab9",
      peru: "cd853f",
      pRk: "ffc0cb",
      plum: "dda0dd",
      powMrXe: "b0e0e6",
      purpN: "800080",
      YbeccapurpN: "663399",
      Yd: "ff0000",
      Psybrown: "bc8f8f",
      PyOXe: "4169e1",
      saddNbPwn: "8b4513",
      sOmon: "fa8072",
      sandybPwn: "f4a460",
      sHgYF: "2e8b57",
      sHshell: "fff5ee",
      siFna: "a0522d",
      silver: "c0c0c0",
      skyXe: "87ceeb",
      UXe: "6a5acd",
      UWay: "708090",
      UgYy: "708090",
      snow: "fffafa",
      sprRggYF: "ff7f",
      stAlXe: "4682b4",
      tan: "d2b48c",
      teO: "8080",
      tEstN: "d8bfd8",
      tomato: "ff6347",
      Qe: "40e0d0",
      viTet: "ee82ee",
      JHt: "f5deb3",
      wEte: "ffffff",
      wEtesmoke: "f5f5f5",
      Lw: "ffff00",
      LwgYF: "9acd32"
    };
  let Nt;

  function Wt(t) {
    Nt || (Nt = function () {
      const t = {},
        e = Object.keys(Bt),
        i = Object.keys(Vt);
      let s, n, o, a, r;
      for (s = 0; s < e.length; s++) {
        for (a = r = e[s], n = 0; n < i.length; n++) o = i[n], r = r.replace(o, Vt[o]);
        o = parseInt(Bt[a], 16), t[r] = [o >> 16 & 255, o >> 8 & 255, 255 & o]
      }
      return t
    }(), Nt.transparent = [0, 0, 0, 0]);
    const e = Nt[t.toLowerCase()];
    return e && {
      r: e[0],
      g: e[1],
      b: e[2],
      a: 4 === e.length ? e[3] : 255
    }
  }
  const jt = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
  const Ht = t => t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055,
    $t = t => t <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4);

  function Yt(t, e, i) {
    if (t) {
      let s = Et(t);
      s[e] = Math.max(0, Math.min(s[e] + s[e] * i, 0 === e ? 360 : 1)), s = It(s), t.r = s[0], t.g = s[1], t.b = s[2]
    }
  }

  function Ut(t, e) {
    return t ? Object.assign(e || {}, t) : t
  }

  function Xt(t) {
    var e = {
      r: 0,
      g: 0,
      b: 0,
      a: 255
    };
    return Array.isArray(t) ? t.length >= 3 && (e = {
      r: t[0],
      g: t[1],
      b: t[2],
      a: 255
    }, t.length > 3 && (e.a = yt(t[3]))) : (e = Ut(t, {
      r: 0,
      g: 0,
      b: 0,
      a: 1
    })).a = yt(e.a), e
  }

  function qt(t) {
    return "r" === t.charAt(0) ? function (t) {
      const e = jt.exec(t);
      let i, s, n, o = 255;
      if (e) {
        if (e[7] !== i) {
          const t = +e[7];
          o = e[8] ? _t(t) : xt(255 * t, 0, 255)
        }
        return i = +e[1], s = +e[3], n = +e[5], i = 255 & (e[2] ? _t(i) : xt(i, 0, 255)), s = 255 & (e[4] ? _t(s) : xt(s, 0, 255)), n = 255 & (e[6] ? _t(n) : xt(n, 0, 255)), {
          r: i,
          g: s,
          b: n,
          a: o
        }
      }
    }(t) : Ft(t)
  }
  class Kt {
    constructor(t) {
      if (t instanceof Kt) return t;
      const e = typeof t;
      let i;
      var s, n, o;
      "object" === e ? i = Xt(t) : "string" === e && (o = (s = t).length, "#" === s[0] && (4 === o || 5 === o ? n = {
        r: 255 & 17 * Mt[s[1]],
        g: 255 & 17 * Mt[s[2]],
        b: 255 & 17 * Mt[s[3]],
        a: 5 === o ? 17 * Mt[s[4]] : 255
      } : 7 !== o && 9 !== o || (n = {
        r: Mt[s[1]] << 4 | Mt[s[2]],
        g: Mt[s[3]] << 4 | Mt[s[4]],
        b: Mt[s[5]] << 4 | Mt[s[6]],
        a: 9 === o ? Mt[s[7]] << 4 | Mt[s[8]] : 255
      })), i = n || Wt(t) || qt(t)), this._rgb = i, this._valid = !!i
    }
    get valid() {
      return this._valid
    }
    get rgb() {
      var t = Ut(this._rgb);
      return t && (t.a = vt(t.a)), t
    }
    set rgb(t) {
      this._rgb = Xt(t)
    }
    rgbString() {
      return this._valid ? (t = this._rgb) && (t.a < 255 ? `rgba(${t.r}, ${t.g}, ${t.b}, ${vt(t.a)})` : `rgb(${t.r}, ${t.g}, ${t.b})`) : void 0;
      var t
    }
    hexString() {
      return this._valid ? Ot(this._rgb) : void 0
    }
    hslString() {
      return this._valid ? function (t) {
        if (!t) return;
        const e = Et(t),
          i = e[0],
          s = wt(e[1]),
          n = wt(e[2]);
        return t.a < 255 ? `hsla(${i}, ${s}%, ${n}%, ${vt(t.a)})` : `hsl(${i}, ${s}%, ${n}%)`
      }(this._rgb) : void 0
    }
    mix(t, e) {
      if (t) {
        const i = this.rgb,
          s = t.rgb;
        let n;
        const o = e === n ? .5 : e,
          a = 2 * o - 1,
          r = i.a - s.a,
          l = ((a * r == -1 ? a : (a + r) / (1 + a * r)) + 1) / 2;
        n = 1 - l, i.r = 255 & l * i.r + n * s.r + .5, i.g = 255 & l * i.g + n * s.g + .5, i.b = 255 & l * i.b + n * s.b + .5, i.a = o * i.a + (1 - o) * s.a, this.rgb = i
      }
      return this
    }
    interpolate(t, e) {
      return t && (this._rgb = function (t, e, i) {
        const s = $t(vt(t.r)),
          n = $t(vt(t.g)),
          o = $t(vt(t.b));
        return {
          r: yt(Ht(s + i * ($t(vt(e.r)) - s))),
          g: yt(Ht(n + i * ($t(vt(e.g)) - n))),
          b: yt(Ht(o + i * ($t(vt(e.b)) - o))),
          a: t.a + i * (e.a - t.a)
        }
      }(this._rgb, t._rgb, e)), this
    }
    clone() {
      return new Kt(this.rgb)
    }
    alpha(t) {
      return this._rgb.a = yt(t), this
    }
    clearer(t) {
      return this._rgb.a *= 1 - t, this
    }
    greyscale() {
      const t = this._rgb,
        e = bt(.3 * t.r + .59 * t.g + .11 * t.b);
      return t.r = t.g = t.b = e, this
    }
    opaquer(t) {
      return this._rgb.a *= 1 + t, this
    }
    negate() {
      const t = this._rgb;
      return t.r = 255 - t.r, t.g = 255 - t.g, t.b = 255 - t.b, this
    }
    lighten(t) {
      return Yt(this._rgb, 2, t), this
    }
    darken(t) {
      return Yt(this._rgb, 2, -t), this
    }
    saturate(t) {
      return Yt(this._rgb, 1, t), this
    }
    desaturate(t) {
      return Yt(this._rgb, 1, -t), this
    }
    rotate(t) {
      return function (t, e) {
        var i = Et(t);
        i[0] = zt(i[0] + e), i = It(i), t.r = i[0], t.g = i[1], t.b = i[2]
      }(this._rgb, t), this
    }
  }

  function Gt(t) {
    return new Kt(t)
  }

  function Zt(t) {
    if (t && "object" == typeof t) {
      const e = t.toString();
      return "[object CanvasPattern]" === e || "[object CanvasGradient]" === e
    }
    return !1
  }

  function Jt(t) {
    return Zt(t) ? t : Gt(t)
  }

  function Qt(t) {
    return Zt(t) ? t : Gt(t).saturate(.5).darken(.1).hexString()
  }
  const te = Object.create(null),
    ee = Object.create(null);

  function ie(t, e) {
    if (!e) return t;
    const i = e.split(".");
    for (let e = 0, s = i.length; e < s; ++e) {
      const s = i[e];
      t = t[s] || (t[s] = Object.create(null))
    }
    return t
  }

  function se(t, e, i) {
    return "string" == typeof e ? m(ie(t, e), i) : m(ie(t, ""), e)
  }
  var ne = new class {
    constructor(t) {
      this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = t => t.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = ["mousemove", "mouseout", "click", "touchstart", "touchmove"], this.font = {
        family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
        size: 12,
        style: "normal",
        lineHeight: 1.2,
        weight: null
      }, this.hover = {}, this.hoverBackgroundColor = (t, e) => Qt(e.backgroundColor), this.hoverBorderColor = (t, e) => Qt(e.borderColor), this.hoverColor = (t, e) => Qt(e.color), this.indexAxis = "x", this.interaction = {
        mode: "nearest",
        intersect: !0,
        includeInvisible: !1
      }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(t)
    }
    set(t, e) {
      return se(this, t, e)
    }
    get(t) {
      return ie(this, t)
    }
    describe(t, e) {
      return se(ee, t, e)
    }
    override(t, e) {
      return se(te, t, e)
    }
    route(t, e, i, s) {
      const o = ie(this, t),
        a = ie(this, i),
        l = "_" + e;
      Object.defineProperties(o, {
        [l]: {
          value: o[e],
          writable: !0
        },
        [e]: {
          enumerable: !0,
          get() {
            const t = this[l],
              e = a[s];
            return n(t) ? Object.assign({}, e, t) : r(t, e)
          },
          set(t) {
            this[l] = t
          }
        }
      })
    }
  }({
    _scriptable: t => !t.startsWith("on"),
    _indexable: t => "events" !== t,
    hover: {
      _fallback: "interaction"
    },
    interaction: {
      _scriptable: !1,
      _indexable: !1
    }
  });

  function oe() {
    return "undefined" != typeof window && "undefined" != typeof document
  }

  function ae(t) {
    let e = t.parentNode;
    return e && "[object ShadowRoot]" === e.toString() && (e = e.host), e
  }

  function re(t, e, i) {
    let s;
    return "string" == typeof t ? (s = parseInt(t, 10), -1 !== t.indexOf("%") && (s = s / 100 * e.parentNode[i])) : s = t, s
  }
  const le = t => window.getComputedStyle(t, null);

  function he(t, e) {
    return le(t).getPropertyValue(e)
  }
  const ce = ["top", "right", "bottom", "left"];

  function de(t, e, i) {
    const s = {};
    i = i ? "-" + i : "";
    for (let n = 0; n < 4; n++) {
      const o = ce[n];
      s[o] = parseFloat(t[e + "-" + o + i]) || 0
    }
    return s.width = s.left + s.right, s.height = s.top + s.bottom, s
  }

  function ue(t, e) {
    if ("native" in t) return t;
    const {
      canvas: i,
      currentDevicePixelRatio: s
    } = e, n = le(i), o = "border-box" === n.boxSizing, a = de(n, "padding"), r = de(n, "border", "width"), {
      x: l,
      y: h,
      box: c
    } = function (t, e) {
      const i = t.touches,
        s = i && i.length ? i[0] : t,
        {
          offsetX: n,
          offsetY: o
        } = s;
      let a, r, l = !1;
      if (((t, e, i) => (t > 0 || e > 0) && (!i || !i.shadowRoot))(n, o, t.target)) a = n, r = o;
      else {
        const t = e.getBoundingClientRect();
        a = s.clientX - t.left, r = s.clientY - t.top, l = !0
      }
      return {
        x: a,
        y: r,
        box: l
      }
    }(t, i), d = a.left + (c && r.left), u = a.top + (c && r.top);
    let {
      width: f,
      height: g
    } = e;
    return o && (f -= a.width + r.width, g -= a.height + r.height), {
      x: Math.round((l - d) / f * i.width / s),
      y: Math.round((h - u) / g * i.height / s)
    }
  }
  const fe = t => Math.round(10 * t) / 10;

  function ge(t, e, i, s) {
    const n = le(t),
      o = de(n, "margin"),
      a = re(n.maxWidth, t, "clientWidth") || A,
      r = re(n.maxHeight, t, "clientHeight") || A,
      l = function (t, e, i) {
        let s, n;
        if (void 0 === e || void 0 === i) {
          const o = ae(t);
          if (o) {
            const t = o.getBoundingClientRect(),
              a = le(o),
              r = de(a, "border", "width"),
              l = de(a, "padding");
            e = t.width - l.width - r.width, i = t.height - l.height - r.height, s = re(a.maxWidth, o, "clientWidth"), n = re(a.maxHeight, o, "clientHeight")
          } else e = t.clientWidth, i = t.clientHeight
        }
        return {
          width: e,
          height: i,
          maxWidth: s || A,
          maxHeight: n || A
        }
      }(t, e, i);
    let {
      width: h,
      height: c
    } = l;
    if ("content-box" === n.boxSizing) {
      const t = de(n, "border", "width"),
        e = de(n, "padding");
      h -= e.width + t.width, c -= e.height + t.height
    }
    return h = Math.max(0, h - o.width), c = Math.max(0, s ? Math.floor(h / s) : c - o.height), h = fe(Math.min(h, a, l.maxWidth)), c = fe(Math.min(c, r, l.maxHeight)), h && !c && (c = fe(h / 2)), {
      width: h,
      height: c
    }
  }

  function pe(t, e, i) {
    const s = e || 1,
      n = Math.floor(t.height * s),
      o = Math.floor(t.width * s);
    t.height = n / s, t.width = o / s;
    const a = t.canvas;
    return a.style && (i || !a.style.height && !a.style.width) && (a.style.height = `${t.height}px`, a.style.width = `${t.width}px`), (t.currentDevicePixelRatio !== s || a.height !== n || a.width !== o) && (t.currentDevicePixelRatio = s, a.height = n, a.width = o, t.ctx.setTransform(s, 0, 0, s, 0, 0), !0)
  }
  const me = function () {
    let t = !1;
    try {
      const e = {
        get passive() {
          return t = !0, !1
        }
      };
      window.addEventListener("test", null, e), window.removeEventListener("test", null, e)
    } catch (t) {}
    return t
  }();

  function be(t, e) {
    const i = he(t, e),
      s = i && i.match(/^(\d+)(\.\d+)?px$/);
    return s ? +s[1] : void 0
  }

  function xe(t) {
    return !t || i(t.size) || i(t.family) ? null : (t.style ? t.style + " " : "") + (t.weight ? t.weight + " " : "") + t.size + "px " + t.family
  }

  function _e(t, e, i, s, n) {
    let o = e[n];
    return o || (o = e[n] = t.measureText(n).width, i.push(n)), o > s && (s = o), s
  }

  function ye(t, e, i, n) {
    let o = (n = n || {}).data = n.data || {},
      a = n.garbageCollect = n.garbageCollect || [];
    n.font !== e && (o = n.data = {}, a = n.garbageCollect = [], n.font = e), t.save(), t.font = e;
    let r = 0;
    const l = i.length;
    let h, c, d, u, f;
    for (h = 0; h < l; h++)
      if (u = i[h], null != u && !0 !== s(u)) r = _e(t, o, a, r, u);
      else if (s(u))
      for (c = 0, d = u.length; c < d; c++) f = u[c], null == f || s(f) || (r = _e(t, o, a, r, f));
    t.restore();
    const g = a.length / 2;
    if (g > i.length) {
      for (h = 0; h < g; h++) delete o[a[h]];
      a.splice(0, g)
    }
    return r
  }

  function ve(t, e, i) {
    const s = t.currentDevicePixelRatio,
      n = 0 !== i ? Math.max(i / 2, .5) : 0;
    return Math.round((e - n) * s) / s + n
  }

  function we(t, e) {
    (e = e || t.getContext("2d")).save(), e.resetTransform(), e.clearRect(0, 0, t.width, t.height), e.restore()
  }

  function Me(t, e, i, s) {
    ke(t, e, i, s, null)
  }

  function ke(t, e, i, s, n) {
    let o, a, r, l, h, c;
    const d = e.pointStyle,
      u = e.rotation,
      f = e.radius;
    let g = (u || 0) * T;
    if (d && "object" == typeof d && (o = d.toString(), "[object HTMLImageElement]" === o || "[object HTMLCanvasElement]" === o)) return t.save(), t.translate(i, s), t.rotate(g), t.drawImage(d, -d.width / 2, -d.height / 2, d.width, d.height), void t.restore();
    if (!(isNaN(f) || f <= 0)) {
      switch (t.beginPath(), d) {
        default:
          n ? t.ellipse(i, s, n / 2, f, 0, 0, O) : t.arc(i, s, f, 0, O), t.closePath();
          break;
        case "triangle":
          t.moveTo(i + Math.sin(g) * f, s - Math.cos(g) * f), g += R, t.lineTo(i + Math.sin(g) * f, s - Math.cos(g) * f), g += R, t.lineTo(i + Math.sin(g) * f, s - Math.cos(g) * f), t.closePath();
          break;
        case "rectRounded":
          h = .516 * f, l = f - h, a = Math.cos(g + E) * l, r = Math.sin(g + E) * l, t.arc(i - a, s - r, h, g - D, g - L), t.arc(i + r, s - a, h, g - L, g), t.arc(i + a, s + r, h, g, g + L), t.arc(i - r, s + a, h, g + L, g + D), t.closePath();
          break;
        case "rect":
          if (!u) {
            l = Math.SQRT1_2 * f, c = n ? n / 2 : l, t.rect(i - c, s - l, 2 * c, 2 * l);
            break
          }
          g += E;
        case "rectRot":
          a = Math.cos(g) * f, r = Math.sin(g) * f, t.moveTo(i - a, s - r), t.lineTo(i + r, s - a), t.lineTo(i + a, s + r), t.lineTo(i - r, s + a), t.closePath();
          break;
        case "crossRot":
          g += E;
        case "cross":
          a = Math.cos(g) * f, r = Math.sin(g) * f, t.moveTo(i - a, s - r), t.lineTo(i + a, s + r), t.moveTo(i + r, s - a), t.lineTo(i - r, s + a);
          break;
        case "star":
          a = Math.cos(g) * f, r = Math.sin(g) * f, t.moveTo(i - a, s - r), t.lineTo(i + a, s + r), t.moveTo(i + r, s - a), t.lineTo(i - r, s + a), g += E, a = Math.cos(g) * f, r = Math.sin(g) * f, t.moveTo(i - a, s - r), t.lineTo(i + a, s + r), t.moveTo(i + r, s - a), t.lineTo(i - r, s + a);
          break;
        case "line":
          a = n ? n / 2 : Math.cos(g) * f, r = Math.sin(g) * f, t.moveTo(i - a, s - r), t.lineTo(i + a, s + r);
          break;
        case "dash":
          t.moveTo(i, s), t.lineTo(i + Math.cos(g) * f, s + Math.sin(g) * f)
      }
      t.fill(), e.borderWidth > 0 && t.stroke()
    }
  }

  function Se(t, e, i) {
    return i = i || .5, !e || t && t.x > e.left - i && t.x < e.right + i && t.y > e.top - i && t.y < e.bottom + i
  }

  function Pe(t, e) {
    t.save(), t.beginPath(), t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t.clip()
  }

  function De(t) {
    t.restore()
  }

  function Oe(t, e, i, s, n) {
    if (!e) return t.lineTo(i.x, i.y);
    if ("middle" === n) {
      const s = (e.x + i.x) / 2;
      t.lineTo(s, e.y), t.lineTo(s, i.y)
    } else "after" === n != !!s ? t.lineTo(e.x, i.y) : t.lineTo(i.x, e.y);
    t.lineTo(i.x, i.y)
  }

  function Ce(t, e, i, s) {
    if (!e) return t.lineTo(i.x, i.y);
    t.bezierCurveTo(s ? e.cp1x : e.cp2x, s ? e.cp1y : e.cp2y, s ? i.cp2x : i.cp1x, s ? i.cp2y : i.cp1y, i.x, i.y)
  }

  function Ae(t, e, n, o, a, r = {}) {
    const l = s(e) ? e : [e],
      h = r.strokeWidth > 0 && "" !== r.strokeColor;
    let c, d;
    for (t.save(), t.font = a.string, function (t, e) {
        e.translation && t.translate(e.translation[0], e.translation[1]);
        i(e.rotation) || t.rotate(e.rotation);
        e.color && (t.fillStyle = e.color);
        e.textAlign && (t.textAlign = e.textAlign);
        e.textBaseline && (t.textBaseline = e.textBaseline)
      }(t, r), c = 0; c < l.length; ++c) d = l[c], h && (r.strokeColor && (t.strokeStyle = r.strokeColor), i(r.strokeWidth) || (t.lineWidth = r.strokeWidth), t.strokeText(d, n, o, r.maxWidth)), t.fillText(d, n, o, r.maxWidth), Te(t, n, o, d, r), o += a.lineHeight;
    t.restore()
  }

  function Te(t, e, i, s, n) {
    if (n.strikethrough || n.underline) {
      const o = t.measureText(s),
        a = e - o.actualBoundingBoxLeft,
        r = e + o.actualBoundingBoxRight,
        l = i - o.actualBoundingBoxAscent,
        h = i + o.actualBoundingBoxDescent,
        c = n.strikethrough ? (l + h) / 2 : h;
      t.strokeStyle = t.fillStyle, t.beginPath(), t.lineWidth = n.decorationWidth || 2, t.moveTo(a, c), t.lineTo(r, c), t.stroke()
    }
  }

  function Le(t, e) {
    const {
      x: i,
      y: s,
      w: n,
      h: o,
      radius: a
    } = e;
    t.arc(i + a.topLeft, s + a.topLeft, a.topLeft, -L, D, !0), t.lineTo(i, s + o - a.bottomLeft), t.arc(i + a.bottomLeft, s + o - a.bottomLeft, a.bottomLeft, D, L, !0), t.lineTo(i + n - a.bottomRight, s + o), t.arc(i + n - a.bottomRight, s + o - a.bottomRight, a.bottomRight, L, 0, !0), t.lineTo(i + n, s + a.topRight), t.arc(i + n - a.topRight, s + a.topRight, a.topRight, 0, -L, !0), t.lineTo(i + a.topLeft, s)
  }

  function Ee(t, e = [""], i = t, s, n = (() => t[0])) {
    M(s) || (s = $e("_fallback", t));
    const o = {
      [Symbol.toStringTag]: "Object",
      _cacheable: !0,
      _scopes: t,
      _rootScopes: i,
      _fallback: s,
      _getTarget: n,
      override: n => Ee([n, ...t], e, i, s)
    };
    return new Proxy(o, {
      deleteProperty: (e, i) => (delete e[i], delete e._keys, delete t[0][i], !0),
      get: (i, s) => Ve(i, s, (() => function (t, e, i, s) {
        let n;
        for (const o of e)
          if (n = $e(ze(o, t), i), M(n)) return Fe(t, n) ? je(i, s, t, n) : n
      }(s, e, t, i))),
      getOwnPropertyDescriptor: (t, e) => Reflect.getOwnPropertyDescriptor(t._scopes[0], e),
      getPrototypeOf: () => Reflect.getPrototypeOf(t[0]),
      has: (t, e) => Ye(t).includes(e),
      ownKeys: t => Ye(t),
      set(t, e, i) {
        const s = t._storage || (t._storage = n());
        return t[e] = s[e] = i, delete t._keys, !0
      }
    })
  }

  function Re(t, e, i, o) {
    const a = {
      _cacheable: !1,
      _proxy: t,
      _context: e,
      _subProxy: i,
      _stack: new Set,
      _descriptors: Ie(t, o),
      setContext: e => Re(t, e, i, o),
      override: s => Re(t.override(s), e, i, o)
    };
    return new Proxy(a, {
      deleteProperty: (e, i) => (delete e[i], delete t[i], !0),
      get: (t, e, i) => Ve(t, e, (() => function (t, e, i) {
        const {
          _proxy: o,
          _context: a,
          _subProxy: r,
          _descriptors: l
        } = t;
        let h = o[e];
        k(h) && l.isScriptable(e) && (h = function (t, e, i, s) {
          const {
            _proxy: n,
            _context: o,
            _subProxy: a,
            _stack: r
          } = i;
          if (r.has(t)) throw new Error("Recursion detected: " + Array.from(r).join("->") + "->" + t);
          r.add(t), e = e(o, a || s), r.delete(t), Fe(t, e) && (e = je(n._scopes, n, t, e));
          return e
        }(e, h, t, i));
        s(h) && h.length && (h = function (t, e, i, s) {
          const {
            _proxy: o,
            _context: a,
            _subProxy: r,
            _descriptors: l
          } = i;
          if (M(a.index) && s(t)) e = e[a.index % e.length];
          else if (n(e[0])) {
            const i = e,
              s = o._scopes.filter((t => t !== i));
            e = [];
            for (const n of i) {
              const i = je(s, o, t, n);
              e.push(Re(i, a, r && r[t], l))
            }
          }
          return e
        }(e, h, t, l.isIndexable));
        Fe(e, h) && (h = Re(h, a, r && r[e], l));
        return h
      }(t, e, i))),
      getOwnPropertyDescriptor: (e, i) => e._descriptors.allKeys ? Reflect.has(t, i) ? {
        enumerable: !0,
        configurable: !0
      } : void 0 : Reflect.getOwnPropertyDescriptor(t, i),
      getPrototypeOf: () => Reflect.getPrototypeOf(t),
      has: (e, i) => Reflect.has(t, i),
      ownKeys: () => Reflect.ownKeys(t),
      set: (e, i, s) => (t[i] = s, delete e[i], !0)
    })
  }

  function Ie(t, e = {
    scriptable: !0,
    indexable: !0
  }) {
    const {
      _scriptable: i = e.scriptable,
      _indexable: s = e.indexable,
      _allKeys: n = e.allKeys
    } = t;
    return {
      allKeys: n,
      scriptable: i,
      indexable: s,
      isScriptable: k(i) ? i : () => i,
      isIndexable: k(s) ? s : () => s
    }
  }
  const ze = (t, e) => t ? t + w(e) : e,
    Fe = (t, e) => n(e) && "adapters" !== t && (null === Object.getPrototypeOf(e) || e.constructor === Object);

  function Ve(t, e, i) {
    if (Object.prototype.hasOwnProperty.call(t, e)) return t[e];
    const s = i();
    return t[e] = s, s
  }

  function Be(t, e, i) {
    return k(t) ? t(e, i) : t
  }
  const Ne = (t, e) => !0 === t ? e : "string" == typeof t ? y(e, t) : void 0;

  function We(t, e, i, s, n) {
    for (const o of e) {
      const e = Ne(i, o);
      if (e) {
        t.add(e);
        const o = Be(e._fallback, i, n);
        if (M(o) && o !== i && o !== s) return o
      } else if (!1 === e && M(s) && i !== s) return null
    }
    return !1
  }

  function je(t, e, i, o) {
    const a = e._rootScopes,
      r = Be(e._fallback, i, o),
      l = [...t, ...a],
      h = new Set;
    h.add(o);
    let c = He(h, l, i, r || i, o);
    return null !== c && ((!M(r) || r === i || (c = He(h, l, r, c, o), null !== c)) && Ee(Array.from(h), [""], a, r, (() => function (t, e, i) {
      const o = t._getTarget();
      e in o || (o[e] = {});
      const a = o[e];
      if (s(a) && n(i)) return i;
      return a
    }(e, i, o))))
  }

  function He(t, e, i, s, n) {
    for (; i;) i = We(t, e, i, s, n);
    return i
  }

  function $e(t, e) {
    for (const i of e) {
      if (!i) continue;
      const e = i[t];
      if (M(e)) return e
    }
  }

  function Ye(t) {
    let e = t._keys;
    return e || (e = t._keys = function (t) {
      const e = new Set;
      for (const i of t)
        for (const t of Object.keys(i).filter((t => !t.startsWith("_")))) e.add(t);
      return Array.from(e)
    }(t._scopes)), e
  }

  function Ue(t, e, i, s) {
    const {
      iScale: n
    } = t, {
      key: o = "r"
    } = this._parsing, a = new Array(s);
    let r, l, h, c;
    for (r = 0, l = s; r < l; ++r) h = r + i, c = e[h], a[r] = {
      r: n.parse(y(c, o), h)
    };
    return a
  }
  const Xe = Number.EPSILON || 1e-14,
    qe = (t, e) => e < t.length && !t[e].skip && t[e],
    Ke = t => "x" === t ? "y" : "x";

  function Ge(t, e, i, s) {
    const n = t.skip ? e : t,
      o = e,
      a = i.skip ? e : i,
      r = X(o, n),
      l = X(a, o);
    let h = r / (r + l),
      c = l / (r + l);
    h = isNaN(h) ? 0 : h, c = isNaN(c) ? 0 : c;
    const d = s * h,
      u = s * c;
    return {
      previous: {
        x: o.x - d * (a.x - n.x),
        y: o.y - d * (a.y - n.y)
      },
      next: {
        x: o.x + u * (a.x - n.x),
        y: o.y + u * (a.y - n.y)
      }
    }
  }

  function Ze(t, e = "x") {
    const i = Ke(e),
      s = t.length,
      n = Array(s).fill(0),
      o = Array(s);
    let a, r, l, h = qe(t, 0);
    for (a = 0; a < s; ++a)
      if (r = l, l = h, h = qe(t, a + 1), l) {
        if (h) {
          const t = h[e] - l[e];
          n[a] = 0 !== t ? (h[i] - l[i]) / t : 0
        }
        o[a] = r ? h ? z(n[a - 1]) !== z(n[a]) ? 0 : (n[a - 1] + n[a]) / 2 : n[a - 1] : n[a]
      }!
    function (t, e, i) {
      const s = t.length;
      let n, o, a, r, l, h = qe(t, 0);
      for (let c = 0; c < s - 1; ++c) l = h, h = qe(t, c + 1), l && h && (N(e[c], 0, Xe) ? i[c] = i[c + 1] = 0 : (n = i[c] / e[c], o = i[c + 1] / e[c], r = Math.pow(n, 2) + Math.pow(o, 2), r <= 9 || (a = 3 / Math.sqrt(r), i[c] = n * a * e[c], i[c + 1] = o * a * e[c])))
    }(t, n, o),
    function (t, e, i = "x") {
      const s = Ke(i),
        n = t.length;
      let o, a, r, l = qe(t, 0);
      for (let h = 0; h < n; ++h) {
        if (a = r, r = l, l = qe(t, h + 1), !r) continue;
        const n = r[i],
          c = r[s];
        a && (o = (n - a[i]) / 3, r[`cp1${i}`] = n - o, r[`cp1${s}`] = c - o * e[h]), l && (o = (l[i] - n) / 3, r[`cp2${i}`] = n + o, r[`cp2${s}`] = c + o * e[h])
      }
    }(t, o, e)
  }

  function Je(t, e, i) {
    return Math.max(Math.min(t, i), e)
  }

  function Qe(t, e, i, s, n) {
    let o, a, r, l;
    if (e.spanGaps && (t = t.filter((t => !t.skip))), "monotone" === e.cubicInterpolationMode) Ze(t, n);
    else {
      let i = s ? t[t.length - 1] : t[0];
      for (o = 0, a = t.length; o < a; ++o) r = t[o], l = Ge(i, r, t[Math.min(o + 1, a - (s ? 0 : 1)) % a], e.tension), r.cp1x = l.previous.x, r.cp1y = l.previous.y, r.cp2x = l.next.x, r.cp2y = l.next.y, i = r
    }
    e.capBezierPoints && function (t, e) {
      let i, s, n, o, a, r = Se(t[0], e);
      for (i = 0, s = t.length; i < s; ++i) a = o, o = r, r = i < s - 1 && Se(t[i + 1], e), o && (n = t[i], a && (n.cp1x = Je(n.cp1x, e.left, e.right), n.cp1y = Je(n.cp1y, e.top, e.bottom)), r && (n.cp2x = Je(n.cp2x, e.left, e.right), n.cp2y = Je(n.cp2y, e.top, e.bottom)))
    }(t, i)
  }
  const ti = t => 0 === t || 1 === t,
    ei = (t, e, i) => -Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * O / i),
    ii = (t, e, i) => Math.pow(2, -10 * t) * Math.sin((t - e) * O / i) + 1,
    si = {
      linear: t => t,
      easeInQuad: t => t * t,
      easeOutQuad: t => -t * (t - 2),
      easeInOutQuad: t => (t /= .5) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1),
      easeInCubic: t => t * t * t,
      easeOutCubic: t => (t -= 1) * t * t + 1,
      easeInOutCubic: t => (t /= .5) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2),
      easeInQuart: t => t * t * t * t,
      easeOutQuart: t => -((t -= 1) * t * t * t - 1),
      easeInOutQuart: t => (t /= .5) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2),
      easeInQuint: t => t * t * t * t * t,
      easeOutQuint: t => (t -= 1) * t * t * t * t + 1,
      easeInOutQuint: t => (t /= .5) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2),
      easeInSine: t => 1 - Math.cos(t * L),
      easeOutSine: t => Math.sin(t * L),
      easeInOutSine: t => -.5 * (Math.cos(D * t) - 1),
      easeInExpo: t => 0 === t ? 0 : Math.pow(2, 10 * (t - 1)),
      easeOutExpo: t => 1 === t ? 1 : 1 - Math.pow(2, -10 * t),
      easeInOutExpo: t => ti(t) ? t : t < .5 ? .5 * Math.pow(2, 10 * (2 * t - 1)) : .5 * (2 - Math.pow(2, -10 * (2 * t - 1))),
      easeInCirc: t => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
      easeOutCirc: t => Math.sqrt(1 - (t -= 1) * t),
      easeInOutCirc: t => (t /= .5) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
      easeInElastic: t => ti(t) ? t : ei(t, .075, .3),
      easeOutElastic: t => ti(t) ? t : ii(t, .075, .3),
      easeInOutElastic(t) {
        const e = .1125;
        return ti(t) ? t : t < .5 ? .5 * ei(2 * t, e, .45) : .5 + .5 * ii(2 * t - 1, e, .45)
      },
      easeInBack(t) {
        const e = 1.70158;
        return t * t * ((e + 1) * t - e)
      },
      easeOutBack(t) {
        const e = 1.70158;
        return (t -= 1) * t * ((e + 1) * t + e) + 1
      },
      easeInOutBack(t) {
        let e = 1.70158;
        return (t /= .5) < 1 ? t * t * ((1 + (e *= 1.525)) * t - e) * .5 : .5 * ((t -= 2) * t * ((1 + (e *= 1.525)) * t + e) + 2)
      },
      easeInBounce: t => 1 - si.easeOutBounce(1 - t),
      easeOutBounce(t) {
        const e = 7.5625,
          i = 2.75;
        return t < 1 / i ? e * t * t : t < 2 / i ? e * (t -= 1.5 / i) * t + .75 : t < 2.5 / i ? e * (t -= 2.25 / i) * t + .9375 : e * (t -= 2.625 / i) * t + .984375
      },
      easeInOutBounce: t => t < .5 ? .5 * si.easeInBounce(2 * t) : .5 * si.easeOutBounce(2 * t - 1) + .5
    };

  function ni(t, e, i, s) {
    return {
      x: t.x + i * (e.x - t.x),
      y: t.y + i * (e.y - t.y)
    }
  }

  function oi(t, e, i, s) {
    return {
      x: t.x + i * (e.x - t.x),
      y: "middle" === s ? i < .5 ? t.y : e.y : "after" === s ? i < 1 ? t.y : e.y : i > 0 ? e.y : t.y
    }
  }

  function ai(t, e, i, s) {
    const n = {
        x: t.cp2x,
        y: t.cp2y
      },
      o = {
        x: e.cp1x,
        y: e.cp1y
      },
      a = ni(t, n, i),
      r = ni(n, o, i),
      l = ni(o, e, i),
      h = ni(a, r, i),
      c = ni(r, l, i);
    return ni(h, c, i)
  }
  const ri = new Map;

  function li(t, e, i) {
    return function (t, e) {
      e = e || {};
      const i = t + JSON.stringify(e);
      let s = ri.get(i);
      return s || (s = new Intl.NumberFormat(t, e), ri.set(i, s)), s
    }(e, i).format(t)
  }
  const hi = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/),
    ci = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);

  function di(t, e) {
    const i = ("" + t).match(hi);
    if (!i || "normal" === i[1]) return 1.2 * e;
    switch (t = +i[2], i[3]) {
      case "px":
        return t;
      case "%":
        t /= 100
    }
    return e * t
  }

  function ui(t, e) {
    const i = {},
      s = n(e),
      o = s ? Object.keys(e) : e,
      a = n(t) ? s ? i => r(t[i], t[e[i]]) : e => t[e] : () => t;
    for (const t of o) i[t] = +a(t) || 0;
    return i
  }

  function fi(t) {
    return ui(t, {
      top: "y",
      right: "x",
      bottom: "y",
      left: "x"
    })
  }

  function gi(t) {
    return ui(t, ["topLeft", "topRight", "bottomLeft", "bottomRight"])
  }

  function pi(t) {
    const e = fi(t);
    return e.width = e.left + e.right, e.height = e.top + e.bottom, e
  }

  function mi(t, e) {
    t = t || {}, e = e || ne.font;
    let i = r(t.size, e.size);
    "string" == typeof i && (i = parseInt(i, 10));
    let s = r(t.style, e.style);
    s && !("" + s).match(ci) && (console.warn('Invalid font style specified: "' + s + '"'), s = "");
    const n = {
      family: r(t.family, e.family),
      lineHeight: di(r(t.lineHeight, e.lineHeight), i),
      size: i,
      style: s,
      weight: r(t.weight, e.weight),
      string: ""
    };
    return n.string = xe(n), n
  }

  function bi(t, e, i, n) {
    let o, a, r, l = !0;
    for (o = 0, a = t.length; o < a; ++o)
      if (r = t[o], void 0 !== r && (void 0 !== e && "function" == typeof r && (r = r(e), l = !1), void 0 !== i && s(r) && (r = r[i % r.length], l = !1), void 0 !== r)) return n && !l && (n.cacheable = !1), r
  }

  function xi(t, e, i) {
    const {
      min: s,
      max: n
    } = t, o = h(e, (n - s) / 2), a = (t, e) => i && 0 === t ? 0 : t + e;
    return {
      min: a(s, -Math.abs(o)),
      max: a(n, o)
    }
  }

  function _i(t, e) {
    return Object.assign(Object.create(t), e)
  }

  function yi(t, e, i) {
    return t ? function (t, e) {
      return {
        x: i => t + t + e - i,
        setWidth(t) {
          e = t
        },
        textAlign: t => "center" === t ? t : "right" === t ? "left" : "right",
        xPlus: (t, e) => t - e,
        leftForLtr: (t, e) => t - e
      }
    }(e, i) : {
      x: t => t,
      setWidth(t) {},
      textAlign: t => t,
      xPlus: (t, e) => t + e,
      leftForLtr: (t, e) => t
    }
  }

  function vi(t, e) {
    let i, s;
    "ltr" !== e && "rtl" !== e || (i = t.canvas.style, s = [i.getPropertyValue("direction"), i.getPropertyPriority("direction")], i.setProperty("direction", e, "important"), t.prevTextDirection = s)
  }

  function wi(t, e) {
    void 0 !== e && (delete t.prevTextDirection, t.canvas.style.setProperty("direction", e[0], e[1]))
  }

  function Mi(t) {
    return "angle" === t ? {
      between: G,
      compare: q,
      normalize: K
    } : {
      between: Q,
      compare: (t, e) => t - e,
      normalize: t => t
    }
  }

  function ki({
    start: t,
    end: e,
    count: i,
    loop: s,
    style: n
  }) {
    return {
      start: t % i,
      end: e % i,
      loop: s && (e - t + 1) % i == 0,
      style: n
    }
  }

  function Si(t, e, i) {
    if (!i) return [t];
    const {
      property: s,
      start: n,
      end: o
    } = i, a = e.length, {
      compare: r,
      between: l,
      normalize: h
    } = Mi(s), {
      start: c,
      end: d,
      loop: u,
      style: f
    } = function (t, e, i) {
      const {
        property: s,
        start: n,
        end: o
      } = i, {
        between: a,
        normalize: r
      } = Mi(s), l = e.length;
      let h, c, {
        start: d,
        end: u,
        loop: f
      } = t;
      if (f) {
        for (d += l, u += l, h = 0, c = l; h < c && a(r(e[d % l][s]), n, o); ++h) d--, u--;
        d %= l, u %= l
      }
      return u < d && (u += l), {
        start: d,
        end: u,
        loop: f,
        style: t.style
      }
    }(t, e, i), g = [];
    let p, m, b, x = !1,
      _ = null;
    const y = () => x || l(n, b, p) && 0 !== r(n, b),
      v = () => !x || 0 === r(o, p) || l(o, b, p);
    for (let t = c, i = c; t <= d; ++t) m = e[t % a], m.skip || (p = h(m[s]), p !== b && (x = l(p, n, o), null === _ && y() && (_ = 0 === r(p, n) ? t : i), null !== _ && v() && (g.push(ki({
      start: _,
      end: t,
      loop: u,
      count: a,
      style: f
    })), _ = null), i = t, b = p));
    return null !== _ && g.push(ki({
      start: _,
      end: d,
      loop: u,
      count: a,
      style: f
    })), g
  }

  function Pi(t, e) {
    const i = [],
      s = t.segments;
    for (let n = 0; n < s.length; n++) {
      const o = Si(s[n], t.points, e);
      o.length && i.push(...o)
    }
    return i
  }

  function Di(t, e) {
    const i = t.points,
      s = t.options.spanGaps,
      n = i.length;
    if (!n) return [];
    const o = !!t._loop,
      {
        start: a,
        end: r
      } = function (t, e, i, s) {
        let n = 0,
          o = e - 1;
        if (i && !s)
          for (; n < e && !t[n].skip;) n++;
        for (; n < e && t[n].skip;) n++;
        for (n %= e, i && (o += n); o > n && t[o % e].skip;) o--;
        return o %= e, {
          start: n,
          end: o
        }
      }(i, n, o, s);
    if (!0 === s) return Oi(t, [{
      start: a,
      end: r,
      loop: o
    }], i, e);
    return Oi(t, function (t, e, i, s) {
      const n = t.length,
        o = [];
      let a, r = e,
        l = t[e];
      for (a = e + 1; a <= i; ++a) {
        const i = t[a % n];
        i.skip || i.stop ? l.skip || (s = !1, o.push({
          start: e % n,
          end: (a - 1) % n,
          loop: s
        }), e = r = i.stop ? a : null) : (r = a, l.skip && (e = a)), l = i
      }
      return null !== r && o.push({
        start: e % n,
        end: r % n,
        loop: s
      }), o
    }(i, a, r < a ? r + n : r, !!t._fullLoop && 0 === a && r === n - 1), i, e)
  }

  function Oi(t, e, i, s) {
    return s && s.setContext && i ? function (t, e, i, s) {
      const n = t._chart.getContext(),
        o = Ci(t.options),
        {
          _datasetIndex: a,
          options: {
            spanGaps: r
          }
        } = t,
        l = i.length,
        h = [];
      let c = o,
        d = e[0].start,
        u = d;

      function f(t, e, s, n) {
        const o = r ? -1 : 1;
        if (t !== e) {
          for (t += l; i[t % l].skip;) t -= o;
          for (; i[e % l].skip;) e += o;
          t % l != e % l && (h.push({
            start: t % l,
            end: e % l,
            loop: s,
            style: n
          }), c = n, d = e % l)
        }
      }
      for (const t of e) {
        d = r ? d : t.start;
        let e, o = i[d % l];
        for (u = d + 1; u <= t.end; u++) {
          const r = i[u % l];
          e = Ci(s.setContext(_i(n, {
            type: "segment",
            p0: o,
            p1: r,
            p0DataIndex: (u - 1) % l,
            p1DataIndex: u % l,
            datasetIndex: a
          }))), Ai(e, c) && f(d, u - 1, t.loop, c), o = r, c = e
        }
        d < u - 1 && f(d, u - 1, t.loop, c)
      }
      return h
    }(t, e, i, s) : e
  }

  function Ci(t) {
    return {
      backgroundColor: t.backgroundColor,
      borderCapStyle: t.borderCapStyle,
      borderDash: t.borderDash,
      borderDashOffset: t.borderDashOffset,
      borderJoinStyle: t.borderJoinStyle,
      borderWidth: t.borderWidth,
      borderColor: t.borderColor
    }
  }

  function Ai(t, e) {
    return e && JSON.stringify(t) !== JSON.stringify(e)
  }
  var Ti = Object.freeze({
    __proto__: null,
    easingEffects: si,
    isPatternOrGradient: Zt,
    color: Jt,
    getHoverColor: Qt,
    noop: t,
    uid: e,
    isNullOrUndef: i,
    isArray: s,
    isObject: n,
    isFinite: o,
    finiteOrDefault: a,
    valueOrDefault: r,
    toPercentage: l,
    toDimension: h,
    callback: c,
    each: d,
    _elementsEqual: u,
    clone: f,
    _merger: p,
    merge: m,
    mergeIf: b,
    _mergerIf: x,
    _deprecated: function (t, e, i, s) {
      void 0 !== e && console.warn(t + ': "' + i + '" is deprecated. Please use "' + s + '" instead')
    },
    resolveObjectKey: y,
    _splitKey: v,
    _capitalize: w,
    defined: M,
    isFunction: k,
    setsEqual: S,
    _isClickEvent: P,
    toFontString: xe,
    _measureText: _e,
    _longestText: ye,
    _alignPixel: ve,
    clearCanvas: we,
    drawPoint: Me,
    drawPointLegend: ke,
    _isPointInArea: Se,
    clipArea: Pe,
    unclipArea: De,
    _steppedLineTo: Oe,
    _bezierCurveTo: Ce,
    renderText: Ae,
    addRoundedRectPath: Le,
    _lookup: tt,
    _lookupByKey: et,
    _rlookupByKey: it,
    _filterBetween: st,
    listenArrayEvents: ot,
    unlistenArrayEvents: at,
    _arrayUnique: rt,
    _createResolver: Ee,
    _attachContext: Re,
    _descriptors: Ie,
    _parseObjectDataRadialScale: Ue,
    splineCurve: Ge,
    splineCurveMonotone: Ze,
    _updateBezierControlPoints: Qe,
    _isDomSupported: oe,
    _getParentNode: ae,
    getStyle: he,
    getRelativePosition: ue,
    getMaximumSize: ge,
    retinaScale: pe,
    supportsEventListenerOptions: me,
    readUsedSize: be,
    fontString: function (t, e, i) {
      return e + " " + t + "px " + i
    },
    requestAnimFrame: lt,
    throttled: ht,
    debounce: ct,
    _toLeftRightCenter: dt,
    _alignStartEnd: ut,
    _textX: ft,
    _getStartAndCountOfVisiblePoints: gt,
    _scaleRangesChanged: pt,
    _pointInLine: ni,
    _steppedInterpolation: oi,
    _bezierInterpolation: ai,
    formatNumber: li,
    toLineHeight: di,
    _readValueToProps: ui,
    toTRBL: fi,
    toTRBLCorners: gi,
    toPadding: pi,
    toFont: mi,
    resolve: bi,
    _addGrace: xi,
    createContext: _i,
    PI: D,
    TAU: O,
    PITAU: C,
    INFINITY: A,
    RAD_PER_DEG: T,
    HALF_PI: L,
    QUARTER_PI: E,
    TWO_THIRDS_PI: R,
    log10: I,
    sign: z,
    niceNum: F,
    _factorize: V,
    isNumber: B,
    almostEquals: N,
    almostWhole: W,
    _setMinAndMaxByKey: j,
    toRadians: H,
    toDegrees: $,
    _decimalPlaces: Y,
    getAngleFromPoint: U,
    distanceBetweenPoints: X,
    _angleDiff: q,
    _normalizeAngle: K,
    _angleBetween: G,
    _limitValue: Z,
    _int16Range: J,
    _isBetween: Q,
    getRtlAdapter: yi,
    overrideTextDirection: vi,
    restoreTextDirection: wi,
    _boundSegment: Si,
    _boundSegments: Pi,
    _computeSegments: Di
  });

  function Li(t, e, i, s) {
    const {
      controller: n,
      data: o,
      _sorted: a
    } = t, r = n._cachedMeta.iScale;
    if (r && e === r.axis && "r" !== e && a && o.length) {
      const t = r._reversePixels ? it : et;
      if (!s) return t(o, e, i);
      if (n._sharedOptions) {
        const s = o[0],
          n = "function" == typeof s.getRange && s.getRange(e);
        if (n) {
          const s = t(o, e, i - n),
            a = t(o, e, i + n);
          return {
            lo: s.lo,
            hi: a.hi
          }
        }
      }
    }
    return {
      lo: 0,
      hi: o.length - 1
    }
  }

  function Ei(t, e, i, s, n) {
    const o = t.getSortedVisibleDatasetMetas(),
      a = i[e];
    for (let t = 0, i = o.length; t < i; ++t) {
      const {
        index: i,
        data: r
      } = o[t], {
        lo: l,
        hi: h
      } = Li(o[t], e, a, n);
      for (let t = l; t <= h; ++t) {
        const e = r[t];
        e.skip || s(e, i, t)
      }
    }
  }

  function Ri(t, e, i, s, n) {
    const o = [];
    if (!n && !t.isPointInArea(e)) return o;
    return Ei(t, i, e, (function (i, a, r) {
      (n || Se(i, t.chartArea, 0)) && i.inRange(e.x, e.y, s) && o.push({
        element: i,
        datasetIndex: a,
        index: r
      })
    }), !0), o
  }

  function Ii(t, e, i, s, n, o) {
    let a = [];
    const r = function (t) {
      const e = -1 !== t.indexOf("x"),
        i = -1 !== t.indexOf("y");
      return function (t, s) {
        const n = e ? Math.abs(t.x - s.x) : 0,
          o = i ? Math.abs(t.y - s.y) : 0;
        return Math.sqrt(Math.pow(n, 2) + Math.pow(o, 2))
      }
    }(i);
    let l = Number.POSITIVE_INFINITY;
    return Ei(t, i, e, (function (i, h, c) {
      const d = i.inRange(e.x, e.y, n);
      if (s && !d) return;
      const u = i.getCenterPoint(n);
      if (!(!!o || t.isPointInArea(u)) && !d) return;
      const f = r(e, u);
      f < l ? (a = [{
        element: i,
        datasetIndex: h,
        index: c
      }], l = f) : f === l && a.push({
        element: i,
        datasetIndex: h,
        index: c
      })
    })), a
  }

  function zi(t, e, i, s, n, o) {
    return o || t.isPointInArea(e) ? "r" !== i || s ? Ii(t, e, i, s, n, o) : function (t, e, i, s) {
      let n = [];
      return Ei(t, i, e, (function (t, i, o) {
        const {
          startAngle: a,
          endAngle: r
        } = t.getProps(["startAngle", "endAngle"], s), {
          angle: l
        } = U(t, {
          x: e.x,
          y: e.y
        });
        G(l, a, r) && n.push({
          element: t,
          datasetIndex: i,
          index: o
        })
      })), n
    }(t, e, i, n) : []
  }

  function Fi(t, e, i, s, n) {
    const o = [],
      a = "x" === i ? "inXRange" : "inYRange";
    let r = !1;
    return Ei(t, i, e, ((t, s, l) => {
      t[a](e[i], n) && (o.push({
        element: t,
        datasetIndex: s,
        index: l
      }), r = r || t.inRange(e.x, e.y, n))
    })), s && !r ? [] : o
  }
  var Vi = {
    evaluateInteractionItems: Ei,
    modes: {
      index(t, e, i, s) {
        const n = ue(e, t),
          o = i.axis || "x",
          a = i.includeInvisible || !1,
          r = i.intersect ? Ri(t, n, o, s, a) : zi(t, n, o, !1, s, a),
          l = [];
        return r.length ? (t.getSortedVisibleDatasetMetas().forEach((t => {
          const e = r[0].index,
            i = t.data[e];
          i && !i.skip && l.push({
            element: i,
            datasetIndex: t.index,
            index: e
          })
        })), l) : []
      },
      dataset(t, e, i, s) {
        const n = ue(e, t),
          o = i.axis || "xy",
          a = i.includeInvisible || !1;
        let r = i.intersect ? Ri(t, n, o, s, a) : zi(t, n, o, !1, s, a);
        if (r.length > 0) {
          const e = r[0].datasetIndex,
            i = t.getDatasetMeta(e).data;
          r = [];
          for (let t = 0; t < i.length; ++t) r.push({
            element: i[t],
            datasetIndex: e,
            index: t
          })
        }
        return r
      },
      point: (t, e, i, s) => Ri(t, ue(e, t), i.axis || "xy", s, i.includeInvisible || !1),
      nearest(t, e, i, s) {
        const n = ue(e, t),
          o = i.axis || "xy",
          a = i.includeInvisible || !1;
        return zi(t, n, o, i.intersect, s, a)
      },
      x: (t, e, i, s) => Fi(t, ue(e, t), "x", i.intersect, s),
      y: (t, e, i, s) => Fi(t, ue(e, t), "y", i.intersect, s)
    }
  };
  const Bi = ["left", "top", "right", "bottom"];

  function Ni(t, e) {
    return t.filter((t => t.pos === e))
  }

  function Wi(t, e) {
    return t.filter((t => -1 === Bi.indexOf(t.pos) && t.box.axis === e))
  }

  function ji(t, e) {
    return t.sort(((t, i) => {
      const s = e ? i : t,
        n = e ? t : i;
      return s.weight === n.weight ? s.index - n.index : s.weight - n.weight
    }))
  }

  function Hi(t, e) {
    const i = function (t) {
        const e = {};
        for (const i of t) {
          const {
            stack: t,
            pos: s,
            stackWeight: n
          } = i;
          if (!t || !Bi.includes(s)) continue;
          const o = e[t] || (e[t] = {
            count: 0,
            placed: 0,
            weight: 0,
            size: 0
          });
          o.count++, o.weight += n
        }
        return e
      }(t),
      {
        vBoxMaxWidth: s,
        hBoxMaxHeight: n
      } = e;
    let o, a, r;
    for (o = 0, a = t.length; o < a; ++o) {
      r = t[o];
      const {
        fullSize: a
      } = r.box, l = i[r.stack], h = l && r.stackWeight / l.weight;
      r.horizontal ? (r.width = h ? h * s : a && e.availableWidth, r.height = n) : (r.width = s, r.height = h ? h * n : a && e.availableHeight)
    }
    return i
  }

  function $i(t, e, i, s) {
    return Math.max(t[i], e[i]) + Math.max(t[s], e[s])
  }

  function Yi(t, e) {
    t.top = Math.max(t.top, e.top), t.left = Math.max(t.left, e.left), t.bottom = Math.max(t.bottom, e.bottom), t.right = Math.max(t.right, e.right)
  }

  function Ui(t, e, i, s) {
    const {
      pos: o,
      box: a
    } = i, r = t.maxPadding;
    if (!n(o)) {
      i.size && (t[o] -= i.size);
      const e = s[i.stack] || {
        size: 0,
        count: 1
      };
      e.size = Math.max(e.size, i.horizontal ? a.height : a.width), i.size = e.size / e.count, t[o] += i.size
    }
    a.getPadding && Yi(r, a.getPadding());
    const l = Math.max(0, e.outerWidth - $i(r, t, "left", "right")),
      h = Math.max(0, e.outerHeight - $i(r, t, "top", "bottom")),
      c = l !== t.w,
      d = h !== t.h;
    return t.w = l, t.h = h, i.horizontal ? {
      same: c,
      other: d
    } : {
      same: d,
      other: c
    }
  }

  function Xi(t, e) {
    const i = e.maxPadding;

    function s(t) {
      const s = {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      };
      return t.forEach((t => {
        s[t] = Math.max(e[t], i[t])
      })), s
    }
    return s(t ? ["left", "right"] : ["top", "bottom"])
  }

  function qi(t, e, i, s) {
    const n = [];
    let o, a, r, l, h, c;
    for (o = 0, a = t.length, h = 0; o < a; ++o) {
      r = t[o], l = r.box, l.update(r.width || e.w, r.height || e.h, Xi(r.horizontal, e));
      const {
        same: a,
        other: d
      } = Ui(e, i, r, s);
      h |= a && n.length, c = c || d, l.fullSize || n.push(r)
    }
    return h && qi(n, e, i, s) || c
  }

  function Ki(t, e, i, s, n) {
    t.top = i, t.left = e, t.right = e + s, t.bottom = i + n, t.width = s, t.height = n
  }

  function Gi(t, e, i, s) {
    const n = i.padding;
    let {
      x: o,
      y: a
    } = e;
    for (const r of t) {
      const t = r.box,
        l = s[r.stack] || {
          count: 1,
          placed: 0,
          weight: 1
        },
        h = r.stackWeight / l.weight || 1;
      if (r.horizontal) {
        const s = e.w * h,
          o = l.size || t.height;
        M(l.start) && (a = l.start), t.fullSize ? Ki(t, n.left, a, i.outerWidth - n.right - n.left, o) : Ki(t, e.left + l.placed, a, s, o), l.start = a, l.placed += s, a = t.bottom
      } else {
        const s = e.h * h,
          a = l.size || t.width;
        M(l.start) && (o = l.start), t.fullSize ? Ki(t, o, n.top, a, i.outerHeight - n.bottom - n.top) : Ki(t, o, e.top + l.placed, a, s), l.start = o, l.placed += s, o = t.right
      }
    }
    e.x = o, e.y = a
  }
  ne.set("layout", {
    autoPadding: !0,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
  var Zi = {
    addBox(t, e) {
      t.boxes || (t.boxes = []), e.fullSize = e.fullSize || !1, e.position = e.position || "top", e.weight = e.weight || 0, e._layers = e._layers || function () {
        return [{
          z: 0,
          draw(t) {
            e.draw(t)
          }
        }]
      }, t.boxes.push(e)
    },
    removeBox(t, e) {
      const i = t.boxes ? t.boxes.indexOf(e) : -1; - 1 !== i && t.boxes.splice(i, 1)
    },
    configure(t, e, i) {
      e.fullSize = i.fullSize, e.position = i.position, e.weight = i.weight
    },
    update(t, e, i, s) {
      if (!t) return;
      const n = pi(t.options.layout.padding),
        o = Math.max(e - n.width, 0),
        a = Math.max(i - n.height, 0),
        r = function (t) {
          const e = function (t) {
              const e = [];
              let i, s, n, o, a, r;
              for (i = 0, s = (t || []).length; i < s; ++i) n = t[i], ({
                position: o,
                options: {
                  stack: a,
                  stackWeight: r = 1
                }
              } = n), e.push({
                index: i,
                box: n,
                pos: o,
                horizontal: n.isHorizontal(),
                weight: n.weight,
                stack: a && o + a,
                stackWeight: r
              });
              return e
            }(t),
            i = ji(e.filter((t => t.box.fullSize)), !0),
            s = ji(Ni(e, "left"), !0),
            n = ji(Ni(e, "right")),
            o = ji(Ni(e, "top"), !0),
            a = ji(Ni(e, "bottom")),
            r = Wi(e, "x"),
            l = Wi(e, "y");
          return {
            fullSize: i,
            leftAndTop: s.concat(o),
            rightAndBottom: n.concat(l).concat(a).concat(r),
            chartArea: Ni(e, "chartArea"),
            vertical: s.concat(n).concat(l),
            horizontal: o.concat(a).concat(r)
          }
        }(t.boxes),
        l = r.vertical,
        h = r.horizontal;
      d(t.boxes, (t => {
        "function" == typeof t.beforeLayout && t.beforeLayout()
      }));
      const c = l.reduce(((t, e) => e.box.options && !1 === e.box.options.display ? t : t + 1), 0) || 1,
        u = Object.freeze({
          outerWidth: e,
          outerHeight: i,
          padding: n,
          availableWidth: o,
          availableHeight: a,
          vBoxMaxWidth: o / 2 / c,
          hBoxMaxHeight: a / 2
        }),
        f = Object.assign({}, n);
      Yi(f, pi(s));
      const g = Object.assign({
          maxPadding: f,
          w: o,
          h: a,
          x: n.left,
          y: n.top
        }, n),
        p = Hi(l.concat(h), u);
      qi(r.fullSize, g, u, p), qi(l, g, u, p), qi(h, g, u, p) && qi(l, g, u, p),
        function (t) {
          const e = t.maxPadding;

          function i(i) {
            const s = Math.max(e[i] - t[i], 0);
            return t[i] += s, s
          }
          t.y += i("top"), t.x += i("left"), i("right"), i("bottom")
        }(g), Gi(r.leftAndTop, g, u, p), g.x += g.w, g.y += g.h, Gi(r.rightAndBottom, g, u, p), t.chartArea = {
          left: g.left,
          top: g.top,
          right: g.left + g.w,
          bottom: g.top + g.h,
          height: g.h,
          width: g.w
        }, d(r.chartArea, (e => {
          const i = e.box;
          Object.assign(i, t.chartArea), i.update(g.w, g.h, {
            left: 0,
            top: 0,
            right: 0,
            bottom: 0
          })
        }))
    }
  };
  class Ji {
    acquireContext(t, e) {}
    releaseContext(t) {
      return !1
    }
    addEventListener(t, e, i) {}
    removeEventListener(t, e, i) {}
    getDevicePixelRatio() {
      return 1
    }
    getMaximumSize(t, e, i, s) {
      return e = Math.max(0, e || t.width), i = i || t.height, {
        width: e,
        height: Math.max(0, s ? Math.floor(e / s) : i)
      }
    }
    isAttached(t) {
      return !0
    }
    updateConfig(t) {}
  }
  class Qi extends Ji {
    acquireContext(t) {
      return t && t.getContext && t.getContext("2d") || null
    }
    updateConfig(t) {
      t.options.animation = !1
    }
  }
  const ts = {
      touchstart: "mousedown",
      touchmove: "mousemove",
      touchend: "mouseup",
      pointerenter: "mouseenter",
      pointerdown: "mousedown",
      pointermove: "mousemove",
      pointerup: "mouseup",
      pointerleave: "mouseout",
      pointerout: "mouseout"
    },
    es = t => null === t || "" === t;
  const is = !!me && {
    passive: !0
  };

  function ss(t, e, i) {
    t.canvas.removeEventListener(e, i, is)
  }

  function ns(t, e) {
    for (const i of t)
      if (i === e || i.contains(e)) return !0
  }

  function os(t, e, i) {
    const s = t.canvas,
      n = new MutationObserver((t => {
        let e = !1;
        for (const i of t) e = e || ns(i.addedNodes, s), e = e && !ns(i.removedNodes, s);
        e && i()
      }));
    return n.observe(document, {
      childList: !0,
      subtree: !0
    }), n
  }

  function as(t, e, i) {
    const s = t.canvas,
      n = new MutationObserver((t => {
        let e = !1;
        for (const i of t) e = e || ns(i.removedNodes, s), e = e && !ns(i.addedNodes, s);
        e && i()
      }));
    return n.observe(document, {
      childList: !0,
      subtree: !0
    }), n
  }
  const rs = new Map;
  let ls = 0;

  function hs() {
    const t = window.devicePixelRatio;
    t !== ls && (ls = t, rs.forEach(((e, i) => {
      i.currentDevicePixelRatio !== t && e()
    })))
  }

  function cs(t, e, i) {
    const s = t.canvas,
      n = s && ae(s);
    if (!n) return;
    const o = ht(((t, e) => {
        const s = n.clientWidth;
        i(t, e), s < n.clientWidth && i()
      }), window),
      a = new ResizeObserver((t => {
        const e = t[0],
          i = e.contentRect.width,
          s = e.contentRect.height;
        0 === i && 0 === s || o(i, s)
      }));
    return a.observe(n),
      function (t, e) {
        rs.size || window.addEventListener("resize", hs), rs.set(t, e)
      }(t, o), a
  }

  function ds(t, e, i) {
    i && i.disconnect(), "resize" === e && function (t) {
      rs.delete(t), rs.size || window.removeEventListener("resize", hs)
    }(t)
  }

  function us(t, e, i) {
    console.log(t);
    const s = t.canvas,
      n = ht((e => {
        null !== t.ctx && i(function (t, e) {
          const i = ts[t.type] || t.type,
            {
              x: s,
              y: n
            } = ue(t, e);
          return {
            type: i,
            chart: e,
            native: t,
            x: void 0 !== s ? s : null,
            y: void 0 !== n ? n : null
          }
        }(e, t))
      }), t, (t => {
        const e = t[0];
        return [e, e.offsetX, e.offsetY]
      }));
    return function (t, e, i) {
      t.addEventListener(e, i, is)
    }(s, e, n), n
  }
  class fs extends Ji {
    acquireContext(t, e) {
      const i = t && t.getContext && t.getContext("2d");
      return i && i.canvas === t ? (function (t, e) {
        const i = t.style
          // s = t.getAttribute("height"),
          // n = t.getAttribute("width");
        if (t.$chartjs = {
            initial: {
              height: s,
              width: n,
              style: {
                display: i.display,
                height: i.height,
                width: i.width
              }
            }
          }, i.display = i.display || "block", i.boxSizing = i.boxSizing || "border-box", es(n)) {
          const e = be(t, "width");
          void 0 !== e && (t.width = e)
        }
        if (es(s))
          if ("" === t.style.height) t.height = t.width / (e || 2);
          else {
            const e = be(t, "height");
            void 0 !== e && (t.height = e)
          }
      }(t, e), i) : null
    }
    releaseContext(t) {
      const e = t.canvas;
      if (!e.$chartjs) return !1;
      const s = e.$chartjs.initial;
      ["height", "width"].forEach((t => {
        const n = s[t];
        i(n) ? e.removeAttribute(t) : e.setAttribute(t, n)
      }));
      const n = s.style || {};
      return Object.keys(n).forEach((t => {
        e.style[t] = n[t]
      })), e.width = e.width, delete e.$chartjs, !0
    }
    addEventListener(t, e, i) {
      this.removeEventListener(t, e);
      const s = t.$proxies || (t.$proxies = {}),
        n = {
          attach: os,
          detach: as,
          resize: cs
        } [e] || us;
      s[e] = n(t, e, i)
    }
    removeEventListener(t, e) {
      const i = t.$proxies || (t.$proxies = {}),
        s = i[e];
      if (!s) return;
      ({
        attach: ds,
        detach: ds,
        resize: ds
      } [e] || ss)(t, e, s), i[e] = void 0
    }
    getDevicePixelRatio() {
      return window.devicePixelRatio
    }
    getMaximumSize(t, e, i, s) {
      return ge(t, e, i, s)
    }
    isAttached(t) {
      const e = ae(t);
      return !(!e || !e.isConnected)
    }
  }

  function gs(t) {
    return !oe() || "undefined" != typeof OffscreenCanvas && t instanceof OffscreenCanvas ? Qi : fs
  }
  var ps = Object.freeze({
    __proto__: null,
    _detectPlatform: gs,
    BasePlatform: Ji,
    BasicPlatform: Qi,
    DomPlatform: fs
  });
  const ms = "transparent",
    bs = {
      boolean: (t, e, i) => i > .5 ? e : t,
      color(t, e, i) {
        const s = Jt(t || ms),
          n = s.valid && Jt(e || ms);
        return n && n.valid ? n.mix(s, i).hexString() : e
      },
      number: (t, e, i) => t + (e - t) * i
    };
  class xs {
    constructor(t, e, i, s) {
      const n = e[i];
      s = bi([t.to, s, n, t.from]);
      const o = bi([t.from, n, s]);
      this._active = !0, this._fn = t.fn || bs[t.type || typeof o], this._easing = si[t.easing] || si.linear, this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = this._total = Math.floor(t.duration), this._loop = !!t.loop, this._target = e, this._prop = i, this._from = o, this._to = s, this._promises = void 0
    }
    active() {
      return this._active
    }
    update(t, e, i) {
      if (this._active) {
        this._notify(!1);
        const s = this._target[this._prop],
          n = i - this._start,
          o = this._duration - n;
        this._start = i, this._duration = Math.floor(Math.max(o, t.duration)), this._total += n, this._loop = !!t.loop, this._to = bi([t.to, e, s, t.from]), this._from = bi([t.from, s, e])
      }
    }
    cancel() {
      this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1))
    }
    tick(t) {
      const e = t - this._start,
        i = this._duration,
        s = this._prop,
        n = this._from,
        o = this._loop,
        a = this._to;
      let r;
      if (this._active = n !== a && (o || e < i), !this._active) return this._target[s] = a, void this._notify(!0);
      e < 0 ? this._target[s] = n : (r = e / i % 2, r = o && r > 1 ? 2 - r : r, r = this._easing(Math.min(1, Math.max(0, r))), this._target[s] = this._fn(n, a, r))
    }
    wait() {
      const t = this._promises || (this._promises = []);
      return new Promise(((e, i) => {
        t.push({
          res: e,
          rej: i
        })
      }))
    }
    _notify(t) {
      const e = t ? "res" : "rej",
        i = this._promises || [];
      for (let t = 0; t < i.length; t++) i[t][e]()
    }
  }
  ne.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  });
  const _s = Object.keys(ne.animation);
  ne.describe("animation", {
    _fallback: !1,
    _indexable: !1,
    _scriptable: t => "onProgress" !== t && "onComplete" !== t && "fn" !== t
  }), ne.set("animations", {
    colors: {
      type: "color",
      properties: ["color", "borderColor", "backgroundColor"]
    },
    numbers: {
      type: "number",
      properties: ["x", "y", "borderWidth", "radius", "tension"]
    }
  }), ne.describe("animations", {
    _fallback: "animation"
  }), ne.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: t => 0 | t
        }
      }
    }
  });
  class ys {
    constructor(t, e) {
      this._chart = t, this._properties = new Map, this.configure(e)
    }
    configure(t) {
      if (!n(t)) return;
      const e = this._properties;
      Object.getOwnPropertyNames(t).forEach((i => {
        const o = t[i];
        if (!n(o)) return;
        const a = {};
        for (const t of _s) a[t] = o[t];
        (s(o.properties) && o.properties || [i]).forEach((t => {
          t !== i && e.has(t) || e.set(t, a)
        }))
      }))
    }
    _animateOptions(t, e) {
      const i = e.options,
        s = function (t, e) {
          if (!e) return;
          let i = t.options;
          if (!i) return void(t.options = e);
          i.$shared && (t.options = i = Object.assign({}, i, {
            $shared: !1,
            $animations: {}
          }));
          return i
        }(t, i);
      if (!s) return [];
      const n = this._createAnimations(s, i);
      return i.$shared && function (t, e) {
        const i = [],
          s = Object.keys(e);
        for (let e = 0; e < s.length; e++) {
          const n = t[s[e]];
          n && n.active() && i.push(n.wait())
        }
        return Promise.all(i)
      }(t.options.$animations, i).then((() => {
        t.options = i
      }), (() => {})), n
    }
    _createAnimations(t, e) {
      const i = this._properties,
        s = [],
        n = t.$animations || (t.$animations = {}),
        o = Object.keys(e),
        a = Date.now();
      let r;
      for (r = o.length - 1; r >= 0; --r) {
        const l = o[r];
        if ("$" === l.charAt(0)) continue;
        if ("options" === l) {
          s.push(...this._animateOptions(t, e));
          continue
        }
        const h = e[l];
        let c = n[l];
        const d = i.get(l);
        if (c) {
          if (d && c.active()) {
            c.update(d, h, a);
            continue
          }
          c.cancel()
        }
        d && d.duration ? (n[l] = c = new xs(d, t, l, h), s.push(c)) : t[l] = h
      }
      return s
    }
    update(t, e) {
      if (0 === this._properties.size) return void Object.assign(t, e);
      const i = this._createAnimations(t, e);
      return i.length ? (mt.add(this._chart, i), !0) : void 0
    }
  }

  function vs(t, e) {
    const i = t && t.options || {},
      s = i.reverse,
      n = void 0 === i.min ? e : 0,
      o = void 0 === i.max ? e : 0;
    return {
      start: s ? o : n,
      end: s ? n : o
    }
  }

  function ws(t, e) {
    const i = [],
      s = t._getSortedDatasetMetas(e);
    let n, o;
    for (n = 0, o = s.length; n < o; ++n) i.push(s[n].index);
    return i
  }

  function Ms(t, e, i, s = {}) {
    const n = t.keys,
      a = "single" === s.mode;
    let r, l, h, c;
    if (null !== e) {
      for (r = 0, l = n.length; r < l; ++r) {
        if (h = +n[r], h === i) {
          if (s.all) continue;
          break
        }
        c = t.values[h], o(c) && (a || 0 === e || z(e) === z(c)) && (e += c)
      }
      return e
    }
  }

  function ks(t, e) {
    const i = t && t.options.stacked;
    return i || void 0 === i && void 0 !== e.stack
  }

  function Ss(t, e, i) {
    const s = t[e] || (t[e] = {});
    return s[i] || (s[i] = {})
  }

  function Ps(t, e, i, s) {
    for (const n of e.getMatchingVisibleMetas(s).reverse()) {
      const e = t[n.index];
      if (i && e > 0 || !i && e < 0) return n.index
    }
    return null
  }

  function Ds(t, e) {
    const {
      chart: i,
      _cachedMeta: s
    } = t, n = i._stacks || (i._stacks = {}), {
      iScale: o,
      vScale: a,
      index: r
    } = s, l = o.axis, h = a.axis, c = function (t, e, i) {
      return `${t.id}.${e.id}.${i.stack||i.type}`
    }(o, a, s), d = e.length;
    let u;
    for (let t = 0; t < d; ++t) {
      const i = e[t],
        {
          [l]: o,
          [h]: d
        } = i;
      u = (i._stacks || (i._stacks = {}))[h] = Ss(n, c, o), u[r] = d, u._top = Ps(u, a, !0, s.type), u._bottom = Ps(u, a, !1, s.type)
    }
  }

  function Os(t, e) {
    const i = t.scales;
    return Object.keys(i).filter((t => i[t].axis === e)).shift()
  }

  function Cs(t, e) {
    const i = t.controller.index,
      s = t.vScale && t.vScale.axis;
    if (s) {
      e = e || t._parsed;
      for (const t of e) {
        const e = t._stacks;
        if (!e || void 0 === e[s] || void 0 === e[s][i]) return;
        delete e[s][i]
      }
    }
  }
  const As = t => "reset" === t || "none" === t,
    Ts = (t, e) => e ? t : Object.assign({}, t);
  class Ls {
    constructor(t, e) {
      this.chart = t, this._ctx = t.ctx, this.index = e, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.initialize()
    }
    initialize() {
      const t = this._cachedMeta;
      this.configure(), this.linkScales(), t._stacked = ks(t.vScale, t), this.addElements()
    }
    updateIndex(t) {
      this.index !== t && Cs(this._cachedMeta), this.index = t
    }
    linkScales() {
      const t = this.chart,
        e = this._cachedMeta,
        i = this.getDataset(),
        s = (t, e, i, s) => "x" === t ? e : "r" === t ? s : i,
        n = e.xAxisID = r(i.xAxisID, Os(t, "x")),
        o = e.yAxisID = r(i.yAxisID, Os(t, "y")),
        a = e.rAxisID = r(i.rAxisID, Os(t, "r")),
        l = e.indexAxis,
        h = e.iAxisID = s(l, n, o, a),
        c = e.vAxisID = s(l, o, n, a);
      e.xScale = this.getScaleForId(n), e.yScale = this.getScaleForId(o), e.rScale = this.getScaleForId(a), e.iScale = this.getScaleForId(h), e.vScale = this.getScaleForId(c)
    }
    getDataset() {
      return this.chart.data.datasets[this.index]
    }
    getMeta() {
      return this.chart.getDatasetMeta(this.index)
    }
    getScaleForId(t) {
      return this.chart.scales[t]
    }
    _getOtherScale(t) {
      const e = this._cachedMeta;
      return t === e.iScale ? e.vScale : e.iScale
    }
    reset() {
      this._update("reset")
    }
    _destroy() {
      const t = this._cachedMeta;
      this._data && at(this._data, this), t._stacked && Cs(t)
    }
    _dataCheck() {
      const t = this.getDataset(),
        e = t.data || (t.data = []),
        i = this._data;
      if (n(e)) this._data = function (t) {
        const e = Object.keys(t),
          i = new Array(e.length);
        let s, n, o;
        for (s = 0, n = e.length; s < n; ++s) o = e[s], i[s] = {
          x: o,
          y: t[o]
        };
        return i
      }(e);
      else if (i !== e) {
        if (i) {
          at(i, this);
          const t = this._cachedMeta;
          Cs(t), t._parsed = []
        }
        e && Object.isExtensible(e) && ot(e, this), this._syncList = [], this._data = e
      }
    }
    addElements() {
      const t = this._cachedMeta;
      this._dataCheck(), this.datasetElementType && (t.dataset = new this.datasetElementType)
    }
    buildOrUpdateElements(t) {
      const e = this._cachedMeta,
        i = this.getDataset();
      let s = !1;
      this._dataCheck();
      const n = e._stacked;
      e._stacked = ks(e.vScale, e), e.stack !== i.stack && (s = !0, Cs(e), e.stack = i.stack), this._resyncElements(t), (s || n !== e._stacked) && Ds(this, e._parsed)
    }
    configure() {
      const t = this.chart.config,
        e = t.datasetScopeKeys(this._type),
        i = t.getOptionScopes(this.getDataset(), e, !0);
      this.options = t.createResolver(i, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {}
    }
    parse(t, e) {
      const {
        _cachedMeta: i,
        _data: o
      } = this, {
        iScale: a,
        _stacked: r
      } = i, l = a.axis;
      let h, c, d, u = 0 === t && e === o.length || i._sorted,
        f = t > 0 && i._parsed[t - 1];
      if (!1 === this._parsing) i._parsed = o, i._sorted = !0, d = o;
      else {
        d = s(o[t]) ? this.parseArrayData(i, o, t, e) : n(o[t]) ? this.parseObjectData(i, o, t, e) : this.parsePrimitiveData(i, o, t, e);
        const a = () => null === c[l] || f && c[l] < f[l];
        for (h = 0; h < e; ++h) i._parsed[h + t] = c = d[h], u && (a() && (u = !1), f = c);
        i._sorted = u
      }
      r && Ds(this, d)
    }
    parsePrimitiveData(t, e, i, s) {
      const {
        iScale: n,
        vScale: o
      } = t, a = n.axis, r = o.axis, l = n.getLabels(), h = n === o, c = new Array(s);
      let d, u, f;
      for (d = 0, u = s; d < u; ++d) f = d + i, c[d] = {
        [a]: h || n.parse(l[f], f),
        [r]: o.parse(e[f], f)
      };
      return c
    }
    parseArrayData(t, e, i, s) {
      const {
        xScale: n,
        yScale: o
      } = t, a = new Array(s);
      let r, l, h, c;
      for (r = 0, l = s; r < l; ++r) h = r + i, c = e[h], a[r] = {
        x: n.parse(c[0], h),
        y: o.parse(c[1], h)
      };
      return a
    }
    parseObjectData(t, e, i, s) {
      const {
        xScale: n,
        yScale: o
      } = t, {
        xAxisKey: a = "x",
        yAxisKey: r = "y"
      } = this._parsing, l = new Array(s);
      let h, c, d, u;
      for (h = 0, c = s; h < c; ++h) d = h + i, u = e[d], l[h] = {
        x: n.parse(y(u, a), d),
        y: o.parse(y(u, r), d)
      };
      return l
    }
    getParsed(t) {
      return this._cachedMeta._parsed[t]
    }
    getDataElement(t) {
      return this._cachedMeta.data[t]
    }
    applyStack(t, e, i) {
      const s = this.chart,
        n = this._cachedMeta,
        o = e[t.axis];
      return Ms({
        keys: ws(s, !0),
        values: e._stacks[t.axis]
      }, o, n.index, {
        mode: i
      })
    }
    updateRangeFromParsed(t, e, i, s) {
      const n = i[e.axis];
      let o = null === n ? NaN : n;
      const a = s && i._stacks[e.axis];
      s && a && (s.values = a, o = Ms(s, n, this._cachedMeta.index)), t.min = Math.min(t.min, o), t.max = Math.max(t.max, o)
    }
    getMinMax(t, e) {
      const i = this._cachedMeta,
        s = i._parsed,
        n = i._sorted && t === i.iScale,
        a = s.length,
        r = this._getOtherScale(t),
        l = ((t, e, i) => t && !e.hidden && e._stacked && {
          keys: ws(i, !0),
          values: null
        })(e, i, this.chart),
        h = {
          min: Number.POSITIVE_INFINITY,
          max: Number.NEGATIVE_INFINITY
        },
        {
          min: c,
          max: d
        } = function (t) {
          const {
            min: e,
            max: i,
            minDefined: s,
            maxDefined: n
          } = t.getUserBounds();
          return {
            min: s ? e : Number.NEGATIVE_INFINITY,
            max: n ? i : Number.POSITIVE_INFINITY
          }
        }(r);
      let u, f;

      function g() {
        f = s[u];
        const e = f[r.axis];
        return !o(f[t.axis]) || c > e || d < e
      }
      for (u = 0; u < a && (g() || (this.updateRangeFromParsed(h, t, f, l), !n)); ++u);
      if (n)
        for (u = a - 1; u >= 0; --u)
          if (!g()) {
            this.updateRangeFromParsed(h, t, f, l);
            break
          } return h
    }
    getAllParsedValues(t) {
      const e = this._cachedMeta._parsed,
        i = [];
      let s, n, a;
      for (s = 0, n = e.length; s < n; ++s) a = e[s][t.axis], o(a) && i.push(a);
      return i
    }
    getMaxOverflow() {
      return !1
    }
    getLabelAndValue(t) {
      const e = this._cachedMeta,
        i = e.iScale,
        s = e.vScale,
        n = this.getParsed(t);
      return {
        label: i ? "" + i.getLabelForValue(n[i.axis]) : "",
        value: s ? "" + s.getLabelForValue(n[s.axis]) : ""
      }
    }
    _update(t) {
      const e = this._cachedMeta;
      this.update(t || "default"), e._clip = function (t) {
        let e, i, s, o;
        return n(t) ? (e = t.top, i = t.right, s = t.bottom, o = t.left) : e = i = s = o = t, {
          top: e,
          right: i,
          bottom: s,
          left: o,
          disabled: !1 === t
        }
      }(r(this.options.clip, function (t, e, i) {
        if (!1 === i) return !1;
        const s = vs(t, i),
          n = vs(e, i);
        return {
          top: n.end,
          right: s.end,
          bottom: n.start,
          left: s.start
        }
      }(e.xScale, e.yScale, this.getMaxOverflow())))
    }
    update(t) {}
    draw() {
      const t = this._ctx,
        e = this.chart,
        i = this._cachedMeta,
        s = i.data || [],
        n = e.chartArea,
        o = [],
        a = this._drawStart || 0,
        r = this._drawCount || s.length - a,
        l = this.options.drawActiveElementsOnTop;
      let h;
      for (i.dataset && i.dataset.draw(t, n, a, r), h = a; h < a + r; ++h) {
        const e = s[h];
        e.hidden || (e.active && l ? o.push(e) : e.draw(t, n))
      }
      for (h = 0; h < o.length; ++h) o[h].draw(t, n)
    }
    getStyle(t, e) {
      const i = e ? "active" : "default";
      return void 0 === t && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(i) : this.resolveDataElementOptions(t || 0, i)
    }
    getContext(t, e, i) {
      const s = this.getDataset();
      let n;
      if (t >= 0 && t < this._cachedMeta.data.length) {
        const e = this._cachedMeta.data[t];
        n = e.$context || (e.$context = function (t, e, i) {
          return _i(t, {
            active: !1,
            dataIndex: e,
            parsed: void 0,
            raw: void 0,
            element: i,
            index: e,
            mode: "default",
            type: "data"
          })
        }(this.getContext(), t, e)), n.parsed = this.getParsed(t), n.raw = s.data[t], n.index = n.dataIndex = t
      } else n = this.$context || (this.$context = function (t, e) {
        return _i(t, {
          active: !1,
          dataset: void 0,
          datasetIndex: e,
          index: e,
          mode: "default",
          type: "dataset"
        })
      }(this.chart.getContext(), this.index)), n.dataset = s, n.index = n.datasetIndex = this.index;
      return n.active = !!e, n.mode = i, n
    }
    resolveDatasetElementOptions(t) {
      return this._resolveElementOptions(this.datasetElementType.id, t)
    }
    resolveDataElementOptions(t, e) {
      return this._resolveElementOptions(this.dataElementType.id, e, t)
    }
    _resolveElementOptions(t, e = "default", i) {
      const s = "active" === e,
        n = this._cachedDataOpts,
        o = t + "-" + e,
        a = n[o],
        r = this.enableOptionSharing && M(i);
      if (a) return Ts(a, r);
      const l = this.chart.config,
        h = l.datasetElementScopeKeys(this._type, t),
        c = s ? [`${t}Hover`, "hover", t, ""] : [t, ""],
        d = l.getOptionScopes(this.getDataset(), h),
        u = Object.keys(ne.elements[t]),
        f = l.resolveNamedOptions(d, u, (() => this.getContext(i, s)), c);
      return f.$shared && (f.$shared = r, n[o] = Object.freeze(Ts(f, r))), f
    }
    _resolveAnimations(t, e, i) {
      const s = this.chart,
        n = this._cachedDataOpts,
        o = `animation-${e}`,
        a = n[o];
      if (a) return a;
      let r;
      if (!1 !== s.options.animation) {
        const s = this.chart.config,
          n = s.datasetAnimationScopeKeys(this._type, e),
          o = s.getOptionScopes(this.getDataset(), n);
        r = s.createResolver(o, this.getContext(t, i, e))
      }
      const l = new ys(s, r && r.animations);
      return r && r._cacheable && (n[o] = Object.freeze(l)), l
    }
    getSharedOptions(t) {
      if (t.$shared) return this._sharedOptions || (this._sharedOptions = Object.assign({}, t))
    }
    includeOptions(t, e) {
      return !e || As(t) || this.chart._animationsDisabled
    }
    _getSharedOptions(t, e) {
      const i = this.resolveDataElementOptions(t, e),
        s = this._sharedOptions,
        n = this.getSharedOptions(i),
        o = this.includeOptions(e, n) || n !== s;
      return this.updateSharedOptions(n, e, i), {
        sharedOptions: n,
        includeOptions: o
      }
    }
    updateElement(t, e, i, s) {
      As(s) ? Object.assign(t, i) : this._resolveAnimations(e, s).update(t, i)
    }
    updateSharedOptions(t, e, i) {
      t && !As(e) && this._resolveAnimations(void 0, e).update(t, i)
    }
    _setStyle(t, e, i, s) {
      t.active = s;
      const n = this.getStyle(e, s);
      this._resolveAnimations(e, i, s).update(t, {
        options: !s && this.getSharedOptions(n) || n
      })
    }
    removeHoverStyle(t, e, i) {
      this._setStyle(t, i, "active", !1)
    }
    setHoverStyle(t, e, i) {
      this._setStyle(t, i, "active", !0)
    }
    _removeDatasetHoverStyle() {
      const t = this._cachedMeta.dataset;
      t && this._setStyle(t, void 0, "active", !1)
    }
    _setDatasetHoverStyle() {
      const t = this._cachedMeta.dataset;
      t && this._setStyle(t, void 0, "active", !0)
    }
    _resyncElements(t) {
      const e = this._data,
        i = this._cachedMeta.data;
      for (const [t, e, i] of this._syncList) this[t](e, i);
      this._syncList = [];
      const s = i.length,
        n = e.length,
        o = Math.min(n, s);
      o && this.parse(0, o), n > s ? this._insertElements(s, n - s, t) : n < s && this._removeElements(n, s - n)
    }
    _insertElements(t, e, i = !0) {
      const s = this._cachedMeta,
        n = s.data,
        o = t + e;
      let a;
      const r = t => {
        for (t.length += e, a = t.length - 1; a >= o; a--) t[a] = t[a - e]
      };
      for (r(n), a = t; a < o; ++a) n[a] = new this.dataElementType;
      this._parsing && r(s._parsed), this.parse(t, e), i && this.updateElements(n, t, e, "reset")
    }
    updateElements(t, e, i, s) {}
    _removeElements(t, e) {
      const i = this._cachedMeta;
      if (this._parsing) {
        const s = i._parsed.splice(t, e);
        i._stacked && Cs(i, s)
      }
      i.data.splice(t, e)
    }
    _sync(t) {
      if (this._parsing) this._syncList.push(t);
      else {
        const [e, i, s] = t;
        this[e](i, s)
      }
      this.chart._dataChanges.push([this.index, ...t])
    }
    _onDataPush() {
      const t = arguments.length;
      this._sync(["_insertElements", this.getDataset().data.length - t, t])
    }
    _onDataPop() {
      this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1])
    }
    _onDataShift() {
      this._sync(["_removeElements", 0, 1])
    }
    _onDataSplice(t, e) {
      e && this._sync(["_removeElements", t, e]);
      const i = arguments.length - 2;
      i && this._sync(["_insertElements", t, i])
    }
    _onDataUnshift() {
      this._sync(["_insertElements", 0, arguments.length])
    }
  }
  Ls.defaults = {}, Ls.prototype.datasetElementType = null, Ls.prototype.dataElementType = null;
  class Es {
    constructor() {
      this.x = void 0, this.y = void 0, this.active = !1, this.options = void 0, this.$animations = void 0
    }
    tooltipPosition(t) {
      const {
        x: e,
        y: i
      } = this.getProps(["x", "y"], t);
      return {
        x: e,
        y: i
      }
    }
    hasValue() {
      return B(this.x) && B(this.y)
    }
    getProps(t, e) {
      const i = this.$animations;
      if (!e || !i) return this;
      const s = {};
      return t.forEach((t => {
        s[t] = i[t] && i[t].active() ? i[t]._to : this[t]
      })), s
    }
  }
  Es.defaults = {}, Es.defaultRoutes = void 0;
  const Rs = {
    values: t => s(t) ? t : "" + t,
    numeric(t, e, i) {
      if (0 === t) return "0";
      const s = this.chart.options.locale;
      let n, o = t;
      if (i.length > 1) {
        const e = Math.max(Math.abs(i[0].value), Math.abs(i[i.length - 1].value));
        (e < 1e-4 || e > 1e15) && (n = "scientific"), o = function (t, e) {
          let i = e.length > 3 ? e[2].value - e[1].value : e[1].value - e[0].value;
          Math.abs(i) >= 1 && t !== Math.floor(t) && (i = t - Math.floor(t));
          return i
        }(t, i)
      }
      const a = I(Math.abs(o)),
        r = Math.max(Math.min(-1 * Math.floor(a), 20), 0),
        l = {
          notation: n,
          minimumFractionDigits: r,
          maximumFractionDigits: r
        };
      return Object.assign(l, this.options.ticks.format), li(t, s, l)
    },
    logarithmic(t, e, i) {
      if (0 === t) return "0";
      const s = t / Math.pow(10, Math.floor(I(t)));
      return 1 === s || 2 === s || 5 === s ? Rs.numeric.call(this, t, e, i) : ""
    }
  };
  var Is = {
    formatters: Rs
  };

  function zs(t, e) {
    const s = t.options.ticks,
      n = s.maxTicksLimit || function (t) {
        const e = t.options.offset,
          i = t._tickSize(),
          s = t._length / i + (e ? 0 : 1),
          n = t._maxLength / i;
        return Math.floor(Math.min(s, n))
      }(t),
      o = s.major.enabled ? function (t) {
        const e = [];
        let i, s;
        for (i = 0, s = t.length; i < s; i++) t[i].major && e.push(i);
        return e
      }(e) : [],
      a = o.length,
      r = o[0],
      l = o[a - 1],
      h = [];
    if (a > n) return function (t, e, i, s) {
      let n, o = 0,
        a = i[0];
      for (s = Math.ceil(s), n = 0; n < t.length; n++) n === a && (e.push(t[n]), o++, a = i[o * s])
    }(e, h, o, a / n), h;
    const c = function (t, e, i) {
      const s = function (t) {
          const e = t.length;
          let i, s;
          if (e < 2) return !1;
          for (s = t[0], i = 1; i < e; ++i)
            if (t[i] - t[i - 1] !== s) return !1;
          return s
        }(t),
        n = e.length / i;
      if (!s) return Math.max(n, 1);
      const o = V(s);
      for (let t = 0, e = o.length - 1; t < e; t++) {
        const e = o[t];
        if (e > n) return e
      }
      return Math.max(n, 1)
    }(o, e, n);
    if (a > 0) {
      let t, s;
      const n = a > 1 ? Math.round((l - r) / (a - 1)) : null;
      for (Fs(e, h, c, i(n) ? 0 : r - n, r), t = 0, s = a - 1; t < s; t++) Fs(e, h, c, o[t], o[t + 1]);
      return Fs(e, h, c, l, i(n) ? e.length : l + n), h
    }
    return Fs(e, h, c), h
  }

  function Fs(t, e, i, s, n) {
    const o = r(s, 0),
      a = Math.min(r(n, t.length), t.length);
    let l, h, c, d = 0;
    for (i = Math.ceil(i), n && (l = n - s, i = l / Math.floor(l / i)), c = o; c < 0;) d++, c = Math.round(o + d * i);
    for (h = Math.max(o, 0); h < a; h++) h === c && (e.push(t[h]), d++, c = Math.round(o + d * i))
  }
  ne.set("scale", {
    display: !0,
    offset: !1,
    reverse: !1,
    beginAtZero: !1,
    bounds: "ticks",
    grace: 0,
    grid: {
      display: !0,
      lineWidth: 1,
      drawBorder: !0,
      drawOnChartArea: !0,
      drawTicks: !0,
      tickLength: 8,
      tickWidth: (t, e) => e.lineWidth,
      tickColor: (t, e) => e.color,
      offset: !1,
      borderDash: [],
      borderDashOffset: 0,
      borderWidth: 1
    },
    title: {
      display: !1,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: !1,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: !0,
      autoSkip: !0,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: Is.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: !1,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  }), ne.route("scale.ticks", "color", "", "color"), ne.route("scale.grid", "color", "", "borderColor"), ne.route("scale.grid", "borderColor", "", "borderColor"), ne.route("scale.title", "color", "", "color"), ne.describe("scale", {
    _fallback: !1,
    _scriptable: t => !t.startsWith("before") && !t.startsWith("after") && "callback" !== t && "parser" !== t,
    _indexable: t => "borderDash" !== t && "tickBorderDash" !== t
  }), ne.describe("scales", {
    _fallback: "scale"
  }), ne.describe("scale.ticks", {
    _scriptable: t => "backdropPadding" !== t && "callback" !== t,
    _indexable: t => "backdropPadding" !== t
  });
  const Vs = (t, e, i) => "top" === e || "left" === e ? t[e] + i : t[e] - i;

  function Bs(t, e) {
    const i = [],
      s = t.length / e,
      n = t.length;
    let o = 0;
    for (; o < n; o += s) i.push(t[Math.floor(o)]);
    return i
  }

  function Ns(t, e, i) {
    const s = t.ticks.length,
      n = Math.min(e, s - 1),
      o = t._startPixel,
      a = t._endPixel,
      r = 1e-6;
    let l, h = t.getPixelForTick(n);
    if (!(i && (l = 1 === s ? Math.max(h - o, a - h) : 0 === e ? (t.getPixelForTick(1) - h) / 2 : (h - t.getPixelForTick(n - 1)) / 2, h += n < e ? l : -l, h < o - r || h > a + r))) return h
  }

  function Ws(t) {
    return t.drawTicks ? t.tickLength : 0
  }

  function js(t, e) {
    if (!t.display) return 0;
    const i = mi(t.font, e),
      n = pi(t.padding);
    return (s(t.text) ? t.text.length : 1) * i.lineHeight + n.height
  }

  function Hs(t, e, i) {
    let s = dt(t);
    return (i && "right" !== e || !i && "right" === e) && (s = (t => "left" === t ? "right" : "right" === t ? "left" : t)(s)), s
  }
  class $s extends Es {
    constructor(t) {
      super(), this.id = t.id, this.type = t.type, this.options = void 0, this.ctx = t.ctx, this.chart = t.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0
    }
    init(t) {
      this.options = t.setContext(this.getContext()), this.axis = t.axis, this._userMin = this.parse(t.min), this._userMax = this.parse(t.max), this._suggestedMin = this.parse(t.suggestedMin), this._suggestedMax = this.parse(t.suggestedMax)
    }
    parse(t, e) {
      return t
    }
    getUserBounds() {
      let {
        _userMin: t,
        _userMax: e,
        _suggestedMin: i,
        _suggestedMax: s
      } = this;
      return t = a(t, Number.POSITIVE_INFINITY), e = a(e, Number.NEGATIVE_INFINITY), i = a(i, Number.POSITIVE_INFINITY), s = a(s, Number.NEGATIVE_INFINITY), {
        min: a(t, i),
        max: a(e, s),
        minDefined: o(t),
        maxDefined: o(e)
      }
    }
    getMinMax(t) {
      let e, {
        min: i,
        max: s,
        minDefined: n,
        maxDefined: o
      } = this.getUserBounds();
      if (n && o) return {
        min: i,
        max: s
      };
      const r = this.getMatchingVisibleMetas();
      for (let a = 0, l = r.length; a < l; ++a) e = r[a].controller.getMinMax(this, t), n || (i = Math.min(i, e.min)), o || (s = Math.max(s, e.max));
      return i = o && i > s ? s : i, s = n && i > s ? i : s, {
        min: a(i, a(s, i)),
        max: a(s, a(i, s))
      }
    }
    getPadding() {
      return {
        left: this.paddingLeft || 0,
        top: this.paddingTop || 0,
        right: this.paddingRight || 0,
        bottom: this.paddingBottom || 0
      }
    }
    getTicks() {
      return this.ticks
    }
    getLabels() {
      const t = this.chart.data;
      return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || []
    }
    beforeLayout() {
      this._cache = {}, this._dataLimitsCached = !1
    }
    beforeUpdate() {
      c(this.options.beforeUpdate, [this])
    }
    update(t, e, i) {
      const {
        beginAtZero: s,
        grace: n,
        ticks: o
      } = this.options, a = o.sampleSize;
      this.beforeUpdate(), this.maxWidth = t, this.maxHeight = e, this._margins = i = Object.assign({
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      }, i), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + i.left + i.right : this.height + i.top + i.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = xi(this, n, s), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();
      const r = a < this.ticks.length;
      this._convertTicksToLabels(r ? Bs(this.ticks, a) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), o.display && (o.autoSkip || "auto" === o.source) && (this.ticks = zs(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), r && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate()
    }
    configure() {
      let t, e, i = this.options.reverse;
      this.isHorizontal() ? (t = this.left, e = this.right) : (t = this.top, e = this.bottom, i = !i), this._startPixel = t, this._endPixel = e, this._reversePixels = i, this._length = e - t, this._alignToPixels = this.options.alignToPixels
    }
    afterUpdate() {
      c(this.options.afterUpdate, [this])
    }
    beforeSetDimensions() {
      c(this.options.beforeSetDimensions, [this])
    }
    setDimensions() {
      this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0
    }
    afterSetDimensions() {
      c(this.options.afterSetDimensions, [this])
    }
    _callHooks(t) {
      this.chart.notifyPlugins(t, this.getContext()), c(this.options[t], [this])
    }
    beforeDataLimits() {
      this._callHooks("beforeDataLimits")
    }
    determineDataLimits() {}
    afterDataLimits() {
      this._callHooks("afterDataLimits")
    }
    beforeBuildTicks() {
      this._callHooks("beforeBuildTicks")
    }
    buildTicks() {
      return []
    }
    afterBuildTicks() {
      this._callHooks("afterBuildTicks")
    }
    beforeTickToLabelConversion() {
      c(this.options.beforeTickToLabelConversion, [this])
    }
    generateTickLabels(t) {
      const e = this.options.ticks;
      let i, s, n;
      for (i = 0, s = t.length; i < s; i++) n = t[i], n.label = c(e.callback, [n.value, i, t], this)
    }
    afterTickToLabelConversion() {
      c(this.options.afterTickToLabelConversion, [this])
    }
    beforeCalculateLabelRotation() {
      c(this.options.beforeCalculateLabelRotation, [this])
    }
    calculateLabelRotation() {
      const t = this.options,
        e = t.ticks,
        i = this.ticks.length,
        s = e.minRotation || 0,
        n = e.maxRotation;
      let o, a, r, l = s;
      if (!this._isVisible() || !e.display || s >= n || i <= 1 || !this.isHorizontal()) return void(this.labelRotation = s);
      const h = this._getLabelSizes(),
        c = h.widest.width,
        d = h.highest.height,
        u = Z(this.chart.width - c, 0, this.maxWidth);
      o = t.offset ? this.maxWidth / i : u / (i - 1), c + 6 > o && (o = u / (i - (t.offset ? .5 : 1)), a = this.maxHeight - Ws(t.grid) - e.padding - js(t.title, this.chart.options.font), r = Math.sqrt(c * c + d * d), l = $(Math.min(Math.asin(Z((h.highest.height + 6) / o, -1, 1)), Math.asin(Z(a / r, -1, 1)) - Math.asin(Z(d / r, -1, 1)))), l = Math.max(s, Math.min(n, l))), this.labelRotation = l
    }
    afterCalculateLabelRotation() {
      c(this.options.afterCalculateLabelRotation, [this])
    }
    afterAutoSkip() {}
    beforeFit() {
      c(this.options.beforeFit, [this])
    }
    fit() {
      const t = {
          width: 0,
          height: 0
        },
        {
          chart: e,
          options: {
            ticks: i,
            title: s,
            grid: n
          }
        } = this,
        o = this._isVisible(),
        a = this.isHorizontal();
      if (o) {
        const o = js(s, e.options.font);
        if (a ? (t.width = this.maxWidth, t.height = Ws(n) + o) : (t.height = this.maxHeight, t.width = Ws(n) + o), i.display && this.ticks.length) {
          const {
            first: e,
            last: s,
            widest: n,
            highest: o
          } = this._getLabelSizes(), r = 2 * i.padding, l = H(this.labelRotation), h = Math.cos(l), c = Math.sin(l);
          if (a) {
            const e = i.mirror ? 0 : c * n.width + h * o.height;
            t.height = Math.min(this.maxHeight, t.height + e + r)
          } else {
            const e = i.mirror ? 0 : h * n.width + c * o.height;
            t.width = Math.min(this.maxWidth, t.width + e + r)
          }
          this._calculatePadding(e, s, c, h)
        }
      }
      this._handleMargins(), a ? (this.width = this._length = e.width - this._margins.left - this._margins.right, this.height = t.height) : (this.width = t.width, this.height = this._length = e.height - this._margins.top - this._margins.bottom)
    }
    _calculatePadding(t, e, i, s) {
      const {
        ticks: {
          align: n,
          padding: o
        },
        position: a
      } = this.options, r = 0 !== this.labelRotation, l = "top" !== a && "x" === this.axis;
      if (this.isHorizontal()) {
        const a = this.getPixelForTick(0) - this.left,
          h = this.right - this.getPixelForTick(this.ticks.length - 1);
        let c = 0,
          d = 0;
        r ? l ? (c = s * t.width, d = i * e.height) : (c = i * t.height, d = s * e.width) : "start" === n ? d = e.width : "end" === n ? c = t.width : "inner" !== n && (c = t.width / 2, d = e.width / 2), this.paddingLeft = Math.max((c - a + o) * this.width / (this.width - a), 0), this.paddingRight = Math.max((d - h + o) * this.width / (this.width - h), 0)
      } else {
        let i = e.height / 2,
          s = t.height / 2;
        "start" === n ? (i = 0, s = t.height) : "end" === n && (i = e.height, s = 0), this.paddingTop = i + o, this.paddingBottom = s + o
      }
    }
    _handleMargins() {
      this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom))
    }
    afterFit() {
      c(this.options.afterFit, [this])
    }
    isHorizontal() {
      const {
        axis: t,
        position: e
      } = this.options;
      return "top" === e || "bottom" === e || "x" === t
    }
    isFullSize() {
      return this.options.fullSize
    }
    _convertTicksToLabels(t) {
      let e, s;
      for (this.beforeTickToLabelConversion(), this.generateTickLabels(t), e = 0, s = t.length; e < s; e++) i(t[e].label) && (t.splice(e, 1), s--, e--);
      this.afterTickToLabelConversion()
    }
    _getLabelSizes() {
      let t = this._labelSizes;
      if (!t) {
        const e = this.options.ticks.sampleSize;
        let i = this.ticks;
        e < i.length && (i = Bs(i, e)), this._labelSizes = t = this._computeLabelSizes(i, i.length)
      }
      return t
    }
    _computeLabelSizes(t, e) {
      const {
        ctx: n,
        _longestTextCache: o
      } = this, a = [], r = [];
      let l, h, c, u, f, g, p, m, b, x, _, y = 0,
        v = 0;
      for (l = 0; l < e; ++l) {
        if (u = t[l].label, f = this._resolveTickFontOptions(l), n.font = g = f.string, p = o[g] = o[g] || {
            data: {},
            gc: []
          }, m = f.lineHeight, b = x = 0, i(u) || s(u)) {
          if (s(u))
            for (h = 0, c = u.length; h < c; ++h) _ = u[h], i(_) || s(_) || (b = _e(n, p.data, p.gc, b, _), x += m)
        } else b = _e(n, p.data, p.gc, b, u), x = m;
        a.push(b), r.push(x), y = Math.max(b, y), v = Math.max(x, v)
      }! function (t, e) {
        d(t, (t => {
          const i = t.gc,
            s = i.length / 2;
          let n;
          if (s > e) {
            for (n = 0; n < s; ++n) delete t.data[i[n]];
            i.splice(0, s)
          }
        }))
      }(o, e);
      const w = a.indexOf(y),
        M = r.indexOf(v),
        k = t => ({
          width: a[t] || 0,
          height: r[t] || 0
        });
      return {
        first: k(0),
        last: k(e - 1),
        widest: k(w),
        highest: k(M),
        widths: a,
        heights: r
      }
    }
    getLabelForValue(t) {
      return t
    }
    getPixelForValue(t, e) {
      return NaN
    }
    getValueForPixel(t) {}
    getPixelForTick(t) {
      const e = this.ticks;
      return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value)
    }
    getPixelForDecimal(t) {
      this._reversePixels && (t = 1 - t);
      const e = this._startPixel + t * this._length;
      return J(this._alignToPixels ? ve(this.chart, e, 0) : e)
    }
    getDecimalForPixel(t) {
      const e = (t - this._startPixel) / this._length;
      return this._reversePixels ? 1 - e : e
    }
    getBasePixel() {
      return this.getPixelForValue(this.getBaseValue())
    }
    getBaseValue() {
      const {
        min: t,
        max: e
      } = this;
      return t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0
    }
    getContext(t) {
      const e = this.ticks || [];
      if (t >= 0 && t < e.length) {
        const i = e[t];
        return i.$context || (i.$context = function (t, e, i) {
          return _i(t, {
            tick: i,
            index: e,
            type: "tick"
          })
        }(this.getContext(), t, i))
      }
      return this.$context || (this.$context = _i(this.chart.getContext(), {
        scale: this,
        type: "scale"
      }))
    }
    _tickSize() {
      const t = this.options.ticks,
        e = H(this.labelRotation),
        i = Math.abs(Math.cos(e)),
        s = Math.abs(Math.sin(e)),
        n = this._getLabelSizes(),
        o = t.autoSkipPadding || 0,
        a = n ? n.widest.width + o : 0,
        r = n ? n.highest.height + o : 0;
      return this.isHorizontal() ? r * i > a * s ? a / i : r / s : r * s < a * i ? r / i : a / s
    }
    _isVisible() {
      const t = this.options.display;
      return "auto" !== t ? !!t : this.getMatchingVisibleMetas().length > 0
    }
    _computeGridLineItems(t) {
      const e = this.axis,
        i = this.chart,
        s = this.options,
        {
          grid: o,
          position: a
        } = s,
        l = o.offset,
        h = this.isHorizontal(),
        c = this.ticks.length + (l ? 1 : 0),
        d = Ws(o),
        u = [],
        f = o.setContext(this.getContext()),
        g = f.drawBorder ? f.borderWidth : 0,
        p = g / 2,
        m = function (t) {
          return ve(i, t, g)
        };
      let b, x, _, y, v, w, M, k, S, P, D, O;
      if ("top" === a) b = m(this.bottom), w = this.bottom - d, k = b - p, P = m(t.top) + p, O = t.bottom;
      else if ("bottom" === a) b = m(this.top), P = t.top, O = m(t.bottom) - p, w = b + p, k = this.top + d;
      else if ("left" === a) b = m(this.right), v = this.right - d, M = b - p, S = m(t.left) + p, D = t.right;
      else if ("right" === a) b = m(this.left), S = t.left, D = m(t.right) - p, v = b + p, M = this.left + d;
      else if ("x" === e) {
        if ("center" === a) b = m((t.top + t.bottom) / 2 + .5);
        else if (n(a)) {
          const t = Object.keys(a)[0],
            e = a[t];
          b = m(this.chart.scales[t].getPixelForValue(e))
        }
        P = t.top, O = t.bottom, w = b + p, k = w + d
      } else if ("y" === e) {
        if ("center" === a) b = m((t.left + t.right) / 2);
        else if (n(a)) {
          const t = Object.keys(a)[0],
            e = a[t];
          b = m(this.chart.scales[t].getPixelForValue(e))
        }
        v = b - p, M = v - d, S = t.left, D = t.right
      }
      const C = r(s.ticks.maxTicksLimit, c),
        A = Math.max(1, Math.ceil(c / C));
      for (x = 0; x < c; x += A) {
        const t = o.setContext(this.getContext(x)),
          e = t.lineWidth,
          s = t.color,
          n = t.borderDash || [],
          a = t.borderDashOffset,
          r = t.tickWidth,
          c = t.tickColor,
          d = t.tickBorderDash || [],
          f = t.tickBorderDashOffset;
        _ = Ns(this, x, l), void 0 !== _ && (y = ve(i, _, e), h ? v = M = S = D = y : w = k = P = O = y, u.push({
          tx1: v,
          ty1: w,
          tx2: M,
          ty2: k,
          x1: S,
          y1: P,
          x2: D,
          y2: O,
          width: e,
          color: s,
          borderDash: n,
          borderDashOffset: a,
          tickWidth: r,
          tickColor: c,
          tickBorderDash: d,
          tickBorderDashOffset: f
        }))
      }
      return this._ticksLength = c, this._borderValue = b, u
    }
    _computeLabelItems(t) {
      const e = this.axis,
        i = this.options,
        {
          position: o,
          ticks: a
        } = i,
        r = this.isHorizontal(),
        l = this.ticks,
        {
          align: h,
          crossAlign: c,
          padding: d,
          mirror: u
        } = a,
        f = Ws(i.grid),
        g = f + d,
        p = u ? -d : g,
        m = -H(this.labelRotation),
        b = [];
      let x, _, y, v, w, M, k, S, P, D, O, C, A = "middle";
      if ("top" === o) M = this.bottom - p, k = this._getXAxisLabelAlignment();
      else if ("bottom" === o) M = this.top + p, k = this._getXAxisLabelAlignment();
      else if ("left" === o) {
        const t = this._getYAxisLabelAlignment(f);
        k = t.textAlign, w = t.x
      } else if ("right" === o) {
        const t = this._getYAxisLabelAlignment(f);
        k = t.textAlign, w = t.x
      } else if ("x" === e) {
        if ("center" === o) M = (t.top + t.bottom) / 2 + g;
        else if (n(o)) {
          const t = Object.keys(o)[0],
            e = o[t];
          M = this.chart.scales[t].getPixelForValue(e) + g
        }
        k = this._getXAxisLabelAlignment()
      } else if ("y" === e) {
        if ("center" === o) w = (t.left + t.right) / 2 - g;
        else if (n(o)) {
          const t = Object.keys(o)[0],
            e = o[t];
          w = this.chart.scales[t].getPixelForValue(e)
        }
        k = this._getYAxisLabelAlignment(f).textAlign
      }
      "y" === e && ("start" === h ? A = "top" : "end" === h && (A = "bottom"));
      const T = this._getLabelSizes();
      for (x = 0, _ = l.length; x < _; ++x) {
        y = l[x], v = y.label;
        const t = a.setContext(this.getContext(x));
        S = this.getPixelForTick(x) + a.labelOffset, P = this._resolveTickFontOptions(x), D = P.lineHeight, O = s(v) ? v.length : 1;
        const e = O / 2,
          i = t.color,
          n = t.textStrokeColor,
          h = t.textStrokeWidth;
        let d, f = k;
        if (r ? (w = S, "inner" === k && (f = x === _ - 1 ? this.options.reverse ? "left" : "right" : 0 === x ? this.options.reverse ? "right" : "left" : "center"), C = "top" === o ? "near" === c || 0 !== m ? -O * D + D / 2 : "center" === c ? -T.highest.height / 2 - e * D + D : -T.highest.height + D / 2 : "near" === c || 0 !== m ? D / 2 : "center" === c ? T.highest.height / 2 - e * D : T.highest.height - O * D, u && (C *= -1)) : (M = S, C = (1 - O) * D / 2), t.showLabelBackdrop) {
          const e = pi(t.backdropPadding),
            i = T.heights[x],
            s = T.widths[x];
          let n = M + C - e.top,
            o = w - e.left;
          switch (A) {
            case "middle":
              n -= i / 2;
              break;
            case "bottom":
              n -= i
          }
          switch (k) {
            case "center":
              o -= s / 2;
              break;
            case "right":
              o -= s
          }
          d = {
            left: o,
            top: n,
            width: s + e.width,
            height: i + e.height,
            color: t.backdropColor
          }
        }
        b.push({
          rotation: m,
          label: v,
          font: P,
          color: i,
          strokeColor: n,
          strokeWidth: h,
          textOffset: C,
          textAlign: f,
          textBaseline: A,
          translation: [w, M],
          backdrop: d
        })
      }
      return b
    }
    _getXAxisLabelAlignment() {
      const {
        position: t,
        ticks: e
      } = this.options;
      if (-H(this.labelRotation)) return "top" === t ? "left" : "right";
      let i = "center";
      return "start" === e.align ? i = "left" : "end" === e.align ? i = "right" : "inner" === e.align && (i = "inner"), i
    }
    _getYAxisLabelAlignment(t) {
      const {
        position: e,
        ticks: {
          crossAlign: i,
          mirror: s,
          padding: n
        }
      } = this.options, o = t + n, a = this._getLabelSizes().widest.width;
      let r, l;
      return "left" === e ? s ? (l = this.right + n, "near" === i ? r = "left" : "center" === i ? (r = "center", l += a / 2) : (r = "right", l += a)) : (l = this.right - o, "near" === i ? r = "right" : "center" === i ? (r = "center", l -= a / 2) : (r = "left", l = this.left)) : "right" === e ? s ? (l = this.left + n, "near" === i ? r = "right" : "center" === i ? (r = "center", l -= a / 2) : (r = "left", l -= a)) : (l = this.left + o, "near" === i ? r = "left" : "center" === i ? (r = "center", l += a / 2) : (r = "right", l = this.right)) : r = "right", {
        textAlign: r,
        x: l
      }
    }
    _computeLabelArea() {
      if (this.options.ticks.mirror) return;
      const t = this.chart,
        e = this.options.position;
      return "left" === e || "right" === e ? {
        top: 0,
        left: this.left,
        bottom: t.height,
        right: this.right
      } : "top" === e || "bottom" === e ? {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: t.width
      } : void 0
    }
    drawBackground() {
      const {
        ctx: t,
        options: {
          backgroundColor: e
        },
        left: i,
        top: s,
        width: n,
        height: o
      } = this;
      e && (t.save(), t.fillStyle = e, t.fillRect(i, s, n, o), t.restore())
    }
    getLineWidthForValue(t) {
      const e = this.options.grid;
      if (!this._isVisible() || !e.display) return 0;
      const i = this.ticks.findIndex((e => e.value === t));
      if (i >= 0) {
        return e.setContext(this.getContext(i)).lineWidth
      }
      return 0
    }
    drawGrid(t) {
      const e = this.options.grid,
        i = this.ctx,
        s = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t));
      let n, o;
      const a = (t, e, s) => {
        s.width && s.color && (i.save(), i.lineWidth = s.width, i.strokeStyle = s.color, i.setLineDash(s.borderDash || []), i.lineDashOffset = s.borderDashOffset, i.beginPath(), i.moveTo(t.x, t.y), i.lineTo(e.x, e.y), i.stroke(), i.restore())
      };
      if (e.display)
        for (n = 0, o = s.length; n < o; ++n) {
          const t = s[n];
          e.drawOnChartArea && a({
            x: t.x1,
            y: t.y1
          }, {
            x: t.x2,
            y: t.y2
          }, t), e.drawTicks && a({
            x: t.tx1,
            y: t.ty1
          }, {
            x: t.tx2,
            y: t.ty2
          }, {
            color: t.tickColor,
            width: t.tickWidth,
            borderDash: t.tickBorderDash,
            borderDashOffset: t.tickBorderDashOffset
          })
        }
    }
    drawBorder() {
      const {
        chart: t,
        ctx: e,
        options: {
          grid: i
        }
      } = this, s = i.setContext(this.getContext()), n = i.drawBorder ? s.borderWidth : 0;
      if (!n) return;
      const o = i.setContext(this.getContext(0)).lineWidth,
        a = this._borderValue;
      let r, l, h, c;
      this.isHorizontal() ? (r = ve(t, this.left, n) - n / 2, l = ve(t, this.right, o) + o / 2, h = c = a) : (h = ve(t, this.top, n) - n / 2, c = ve(t, this.bottom, o) + o / 2, r = l = a), e.save(), e.lineWidth = s.borderWidth, e.strokeStyle = s.borderColor, e.beginPath(), e.moveTo(r, h), e.lineTo(l, c), e.stroke(), e.restore()
    }
    drawLabels(t) {
      if (!this.options.ticks.display) return;
      const e = this.ctx,
        i = this._computeLabelArea();
      i && Pe(e, i);
      const s = this._labelItems || (this._labelItems = this._computeLabelItems(t));
      let n, o;
      for (n = 0, o = s.length; n < o; ++n) {
        const t = s[n],
          i = t.font,
          o = t.label;
        t.backdrop && (e.fillStyle = t.backdrop.color, e.fillRect(t.backdrop.left, t.backdrop.top, t.backdrop.width, t.backdrop.height)), Ae(e, o, 0, t.textOffset, i, t)
      }
      i && De(e)
    }
    drawTitle() {
      const {
        ctx: t,
        options: {
          position: e,
          title: i,
          reverse: o
        }
      } = this;
      if (!i.display) return;
      const a = mi(i.font),
        r = pi(i.padding),
        l = i.align;
      let h = a.lineHeight / 2;
      "bottom" === e || "center" === e || n(e) ? (h += r.bottom, s(i.text) && (h += a.lineHeight * (i.text.length - 1))) : h += r.top;
      const {
        titleX: c,
        titleY: d,
        maxWidth: u,
        rotation: f
      } = function (t, e, i, s) {
        const {
          top: o,
          left: a,
          bottom: r,
          right: l,
          chart: h
        } = t, {
          chartArea: c,
          scales: d
        } = h;
        let u, f, g, p = 0;
        const m = r - o,
          b = l - a;
        if (t.isHorizontal()) {
          if (f = ut(s, a, l), n(i)) {
            const t = Object.keys(i)[0],
              s = i[t];
            g = d[t].getPixelForValue(s) + m - e
          } else g = "center" === i ? (c.bottom + c.top) / 2 + m - e : Vs(t, i, e);
          u = l - a
        } else {
          if (n(i)) {
            const t = Object.keys(i)[0],
              s = i[t];
            f = d[t].getPixelForValue(s) - b + e
          } else f = "center" === i ? (c.left + c.right) / 2 - b + e : Vs(t, i, e);
          g = ut(s, r, o), p = "left" === i ? -L : L
        }
        return {
          titleX: f,
          titleY: g,
          maxWidth: u,
          rotation: p
        }
      }(this, h, e, l);
      Ae(t, i.text, 0, 0, a, {
        color: i.color,
        maxWidth: u,
        rotation: f,
        textAlign: Hs(l, e, o),
        textBaseline: "middle",
        translation: [c, d]
      })
    }
    draw(t) {
      this._isVisible() && (this.drawBackground(), this.drawGrid(t), this.drawBorder(), this.drawTitle(), this.drawLabels(t))
    }
    _layers() {
      const t = this.options,
        e = t.ticks && t.ticks.z || 0,
        i = r(t.grid && t.grid.z, -1);
      return this._isVisible() && this.draw === $s.prototype.draw ? [{
        z: i,
        draw: t => {
          this.drawBackground(), this.drawGrid(t), this.drawTitle()
        }
      }, {
        z: i + 1,
        draw: () => {
          this.drawBorder()
        }
      }, {
        z: e,
        draw: t => {
          this.drawLabels(t)
        }
      }] : [{
        z: e,
        draw: t => {
          this.draw(t)
        }
      }]
    }
    getMatchingVisibleMetas(t) {
      const e = this.chart.getSortedVisibleDatasetMetas(),
        i = this.axis + "AxisID",
        s = [];
      let n, o;
      for (n = 0, o = e.length; n < o; ++n) {
        const o = e[n];
        o[i] !== this.id || t && o.type !== t || s.push(o)
      }
      return s
    }
    _resolveTickFontOptions(t) {
      return mi(this.options.ticks.setContext(this.getContext(t)).font)
    }
    _maxDigits() {
      const t = this._resolveTickFontOptions(0).lineHeight;
      return (this.isHorizontal() ? this.width : this.height) / t
    }
  }
  class Ys {
    constructor(t, e, i) {
      this.type = t, this.scope = e, this.override = i, this.items = Object.create(null)
    }
    isForType(t) {
      return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype)
    }
    register(t) {
      const e = Object.getPrototypeOf(t);
      let i;
      (function (t) {
        return "id" in t && "defaults" in t
      })(e) && (i = this.register(e));
      const s = this.items,
        n = t.id,
        o = this.scope + "." + n;
      if (!n) throw new Error("class does not have id: " + t);
      return n in s || (s[n] = t, function (t, e, i) {
        const s = m(Object.create(null), [i ? ne.get(i) : {}, ne.get(e), t.defaults]);
        ne.set(e, s), t.defaultRoutes && function (t, e) {
          Object.keys(e).forEach((i => {
            const s = i.split("."),
              n = s.pop(),
              o = [t].concat(s).join("."),
              a = e[i].split("."),
              r = a.pop(),
              l = a.join(".");
            ne.route(o, n, l, r)
          }))
        }(e, t.defaultRoutes);
        t.descriptors && ne.describe(e, t.descriptors)
      }(t, o, i), this.override && ne.override(t.id, t.overrides)), o
    }
    get(t) {
      return this.items[t]
    }
    unregister(t) {
      const e = this.items,
        i = t.id,
        s = this.scope;
      i in e && delete e[i], s && i in ne[s] && (delete ne[s][i], this.override && delete te[i])
    }
  }
  var Us = new class {
    constructor() {
      this.controllers = new Ys(Ls, "datasets", !0), this.elements = new Ys(Es, "elements"), this.plugins = new Ys(Object, "plugins"), this.scales = new Ys($s, "scales"), this._typedRegistries = [this.controllers, this.scales, this.elements]
    }
    add(...t) {
      this._each("register", t)
    }
    remove(...t) {
      this._each("unregister", t)
    }
    addControllers(...t) {
      this._each("register", t, this.controllers)
    }
    addElements(...t) {
      this._each("register", t, this.elements)
    }
    addPlugins(...t) {
      this._each("register", t, this.plugins)
    }
    addScales(...t) {
      this._each("register", t, this.scales)
    }
    getController(t) {
      return this._get(t, this.controllers, "controller")
    }
    getElement(t) {
      return this._get(t, this.elements, "element")
    }
    getPlugin(t) {
      return this._get(t, this.plugins, "plugin")
    }
    getScale(t) {
      return this._get(t, this.scales, "scale")
    }
    removeControllers(...t) {
      this._each("unregister", t, this.controllers)
    }
    removeElements(...t) {
      this._each("unregister", t, this.elements)
    }
    removePlugins(...t) {
      this._each("unregister", t, this.plugins)
    }
    removeScales(...t) {
      this._each("unregister", t, this.scales)
    }
    _each(t, e, i) {
      [...e].forEach((e => {
        const s = i || this._getRegistryForType(e);
        i || s.isForType(e) || s === this.plugins && e.id ? this._exec(t, s, e) : d(e, (e => {
          const s = i || this._getRegistryForType(e);
          this._exec(t, s, e)
        }))
      }))
    }
    _exec(t, e, i) {
      const s = w(t);
      c(i["before" + s], [], i), e[t](i), c(i["after" + s], [], i)
    }
    _getRegistryForType(t) {
      for (let e = 0; e < this._typedRegistries.length; e++) {
        const i = this._typedRegistries[e];
        if (i.isForType(t)) return i
      }
      return this.plugins
    }
    _get(t, e, i) {
      const s = e.get(t);
      if (void 0 === s) throw new Error('"' + t + '" is not a registered ' + i + ".");
      return s
    }
  };
  class Xs {
    constructor() {
      this._init = []
    }
    notify(t, e, i, s) {
      "beforeInit" === e && (this._init = this._createDescriptors(t, !0), this._notify(this._init, t, "install"));
      const n = s ? this._descriptors(t).filter(s) : this._descriptors(t),
        o = this._notify(n, t, e, i);
      return "afterDestroy" === e && (this._notify(n, t, "stop"), this._notify(this._init, t, "uninstall")), o
    }
    _notify(t, e, i, s) {
      s = s || {};
      for (const n of t) {
        const t = n.plugin;
        if (!1 === c(t[i], [e, s, n.options], t) && s.cancelable) return !1
      }
      return !0
    }
    invalidate() {
      i(this._cache) || (this._oldCache = this._cache, this._cache = void 0)
    }
    _descriptors(t) {
      if (this._cache) return this._cache;
      const e = this._cache = this._createDescriptors(t);
      return this._notifyStateChanges(t), e
    }
    _createDescriptors(t, e) {
      const i = t && t.config,
        s = r(i.options && i.options.plugins, {}),
        n = function (t) {
          const e = {},
            i = [],
            s = Object.keys(Us.plugins.items);
          for (let t = 0; t < s.length; t++) i.push(Us.getPlugin(s[t]));
          const n = t.plugins || [];
          for (let t = 0; t < n.length; t++) {
            const s = n[t]; - 1 === i.indexOf(s) && (i.push(s), e[s.id] = !0)
          }
          return {
            plugins: i,
            localIds: e
          }
        }(i);
      return !1 !== s || e ? function (t, {
        plugins: e,
        localIds: i
      }, s, n) {
        const o = [],
          a = t.getContext();
        for (const r of e) {
          const e = r.id,
            l = qs(s[e], n);
          null !== l && o.push({
            plugin: r,
            options: Ks(t.config, {
              plugin: r,
              local: i[e]
            }, l, a)
          })
        }
        return o
      }(t, n, s, e) : []
    }
    _notifyStateChanges(t) {
      const e = this._oldCache || [],
        i = this._cache,
        s = (t, e) => t.filter((t => !e.some((e => t.plugin.id === e.plugin.id))));
      this._notify(s(e, i), t, "stop"), this._notify(s(i, e), t, "start")
    }
  }

  function qs(t, e) {
    return e || !1 !== t ? !0 === t ? {} : t : null
  }

  function Ks(t, {
    plugin: e,
    local: i
  }, s, n) {
    const o = t.pluginScopeKeys(e),
      a = t.getOptionScopes(s, o);
    return i && e.defaults && a.push(e.defaults), t.createResolver(a, n, [""], {
      scriptable: !1,
      indexable: !1,
      allKeys: !0
    })
  }

  function Gs(t, e) {
    const i = ne.datasets[t] || {};
    return ((e.datasets || {})[t] || {}).indexAxis || e.indexAxis || i.indexAxis || "x"
  }

  function Zs(t, e) {
    return "x" === t || "y" === t ? t : e.axis || ("top" === (i = e.position) || "bottom" === i ? "x" : "left" === i || "right" === i ? "y" : void 0) || t.charAt(0).toLowerCase();
    var i
  }

  function Js(t) {
    const e = t.options || (t.options = {});
    e.plugins = r(e.plugins, {}), e.scales = function (t, e) {
      const i = te[t.type] || {
          scales: {}
        },
        s = e.scales || {},
        o = Gs(t.type, e),
        a = Object.create(null),
        r = Object.create(null);
      return Object.keys(s).forEach((t => {
        const e = s[t];
        if (!n(e)) return console.error(`Invalid scale configuration for scale: ${t}`);
        if (e._proxy) return console.warn(`Ignoring resolver passed as options for scale: ${t}`);
        const l = Zs(t, e),
          h = function (t, e) {
            return t === e ? "_index_" : "_value_"
          }(l, o),
          c = i.scales || {};
        a[l] = a[l] || t, r[t] = b(Object.create(null), [{
          axis: l
        }, e, c[l], c[h]])
      })), t.data.datasets.forEach((i => {
        const n = i.type || t.type,
          o = i.indexAxis || Gs(n, e),
          l = (te[n] || {}).scales || {};
        Object.keys(l).forEach((t => {
          const e = function (t, e) {
              let i = t;
              return "_index_" === t ? i = e : "_value_" === t && (i = "x" === e ? "y" : "x"), i
            }(t, o),
            n = i[e + "AxisID"] || a[e] || e;
          r[n] = r[n] || Object.create(null), b(r[n], [{
            axis: e
          }, s[n], l[t]])
        }))
      })), Object.keys(r).forEach((t => {
        const e = r[t];
        b(e, [ne.scales[e.type], ne.scale])
      })), r
    }(t, e)
  }

  function Qs(t) {
    return (t = t || {}).datasets = t.datasets || [], t.labels = t.labels || [], t
  }
  const tn = new Map,
    en = new Set;

  function sn(t, e) {
    let i = tn.get(t);
    return i || (i = e(), tn.set(t, i), en.add(i)), i
  }
  const nn = (t, e, i) => {
    const s = y(e, i);
    void 0 !== s && t.add(s)
  };
  class on {
    constructor(t) {
      this._config = function (t) {
        return (t = t || {}).data = Qs(t.data), Js(t), t
      }(t), this._scopeCache = new Map, this._resolverCache = new Map
    }
    get platform() {
      return this._config.platform
    }
    get type() {
      return this._config.type
    }
    set type(t) {
      this._config.type = t
    }
    get data() {
      return this._config.data
    }
    set data(t) {
      this._config.data = Qs(t)
    }
    get options() {
      return this._config.options
    }
    set options(t) {
      this._config.options = t
    }
    get plugins() {
      return this._config.plugins
    }
    update() {
      const t = this._config;
      this.clearCache(), Js(t)
    }
    clearCache() {
      this._scopeCache.clear(), this._resolverCache.clear()
    }
    datasetScopeKeys(t) {
      return sn(t, (() => [
        [`datasets.${t}`, ""]
      ]))
    }
    datasetAnimationScopeKeys(t, e) {
      return sn(`${t}.transition.${e}`, (() => [
        [`datasets.${t}.transitions.${e}`, `transitions.${e}`],
        [`datasets.${t}`, ""]
      ]))
    }
    datasetElementScopeKeys(t, e) {
      return sn(`${t}-${e}`, (() => [
        [`datasets.${t}.elements.${e}`, `datasets.${t}`, `elements.${e}`, ""]
      ]))
    }
    pluginScopeKeys(t) {
      const e = t.id;
      return sn(`${this.type}-plugin-${e}`, (() => [
        [`plugins.${e}`, ...t.additionalOptionScopes || []]
      ]))
    }
    _cachedScopes(t, e) {
      const i = this._scopeCache;
      let s = i.get(t);
      return s && !e || (s = new Map, i.set(t, s)), s
    }
    getOptionScopes(t, e, i) {
      const {
        options: s,
        type: n
      } = this, o = this._cachedScopes(t, i), a = o.get(e);
      if (a) return a;
      const r = new Set;
      e.forEach((e => {
        t && (r.add(t), e.forEach((e => nn(r, t, e)))), e.forEach((t => nn(r, s, t))), e.forEach((t => nn(r, te[n] || {}, t))), e.forEach((t => nn(r, ne, t))), e.forEach((t => nn(r, ee, t)))
      }));
      const l = Array.from(r);
      return 0 === l.length && l.push(Object.create(null)), en.has(e) && o.set(e, l), l
    }
    chartOptionScopes() {
      const {
        options: t,
        type: e
      } = this;
      return [t, te[e] || {}, ne.datasets[e] || {}, {
        type: e
      }, ne, ee]
    }
    resolveNamedOptions(t, e, i, n = [""]) {
      const o = {
          $shared: !0
        },
        {
          resolver: a,
          subPrefixes: r
        } = an(this._resolverCache, t, n);
      let l = a;
      if (function (t, e) {
          const {
            isScriptable: i,
            isIndexable: n
          } = Ie(t);
          for (const o of e) {
            const e = i(o),
              a = n(o),
              r = (a || e) && t[o];
            if (e && (k(r) || rn(r)) || a && s(r)) return !0
          }
          return !1
        }(a, e)) {
        o.$shared = !1;
        l = Re(a, i = k(i) ? i() : i, this.createResolver(t, i, r))
      }
      for (const t of e) o[t] = l[t];
      return o
    }
    createResolver(t, e, i = [""], s) {
      const {
        resolver: o
      } = an(this._resolverCache, t, i);
      return n(e) ? Re(o, e, void 0, s) : o
    }
  }

  function an(t, e, i) {
    let s = t.get(e);
    s || (s = new Map, t.set(e, s));
    const n = i.join();
    let o = s.get(n);
    if (!o) {
      o = {
        resolver: Ee(e, i),
        subPrefixes: i.filter((t => !t.toLowerCase().includes("hover")))
      }, s.set(n, o)
    }
    return o
  }
  const rn = t => n(t) && Object.getOwnPropertyNames(t).reduce(((e, i) => e || k(t[i])), !1);
  const ln = ["top", "bottom", "left", "right", "chartArea"];

  function hn(t, e) {
    return "top" === t || "bottom" === t || -1 === ln.indexOf(t) && "x" === e
  }

  function cn(t, e) {
    return function (i, s) {
      return i[t] === s[t] ? i[e] - s[e] : i[t] - s[t]
    }
  }

  function dn(t) {
    const e = t.chart,
      i = e.options.animation;
    e.notifyPlugins("afterRender"), c(i && i.onComplete, [t], e)
  }

  function un(t) {
    const e = t.chart,
      i = e.options.animation;
    c(i && i.onProgress, [t], e)
  }

  function fn(t) {
    return oe() && "string" == typeof t ? t = document.getElementById(t) : t && t.length && (t = t[0]), t && t.canvas && (t = t.canvas), t
  }
  const gn = {},
    pn = t => {
      const e = fn(t);
      return Object.values(gn).filter((t => t.canvas === e)).pop()
    };

  function mn(t, e, i) {
    const s = Object.keys(t);
    for (const n of s) {
      const s = +n;
      if (s >= e) {
        const o = t[n];
        delete t[n], (i > 0 || s > e) && (t[s + i] = o)
      }
    }
  }
  class bn {
    constructor(t, i) {
      const s = this.config = new on(i),
        n = fn(t),
        o = pn(n);
      if (o) throw new Error("Canvas is already in use. Chart with ID '" + o.id + "' must be destroyed before the canvas with ID '" + o.canvas.id + "' can be reused.");
      const a = s.createResolver(s.chartOptionScopes(), this.getContext());
      this.platform = new(s.platform || gs(n)), this.platform.updateConfig(s);
      const r = this.platform.acquireContext(n, a.aspectRatio),
        l = r && r.canvas,
        h = l && l.height,
        c = l && l.width;
      this.id = e(), this.ctx = r, this.canvas = l, this.width = c, this.height = h, this._options = a, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new Xs, this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = ct((t => this.update(t)), a.resizeDelay || 0), this._dataChanges = [], gn[this.id] = this, r && l ? (mt.listen(this, "complete", dn), mt.listen(this, "progress", un), this._initialize(), this.attached && this.update()) : console.error("Failed to create chart: can't acquire context from the given item")
    }
    get aspectRatio() {
      const {
        options: {
          aspectRatio: t,
          maintainAspectRatio: e
        },
        width: s,
        height: n,
        _aspectRatio: o
      } = this;
      return i(t) ? e && o ? o : n ? s / n : null : t
    }
    get data() {
      return this.config.data
    }
    set data(t) {
      this.config.data = t
    }
    get options() {
      return this._options
    }
    set options(t) {
      this.config.options = t
    }
    _initialize() {
      return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : pe(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this
    }
    clear() {
      return we(this.canvas, this.ctx), this
    }
    stop() {
      return mt.stop(this), this
    }
    resize(t, e) {
      mt.running(this) ? this._resizeBeforeDraw = {
        width: t,
        height: e
      } : this._resize(t, e)
    }
    _resize(t, e) {
      const i = this.options,
        s = this.canvas,
        n = i.maintainAspectRatio && this.aspectRatio,
        o = this.platform.getMaximumSize(s, t, e, n),
        a = i.devicePixelRatio || this.platform.getDevicePixelRatio(),
        r = this.width ? "resize" : "attach";
      this.width = o.width, this.height = o.height, this._aspectRatio = this.aspectRatio, pe(this, a, !0) && (this.notifyPlugins("resize", {
        size: o
      }), c(i.onResize, [this, o], this), this.attached && this._doResize(r) && this.render())
    }
    ensureScalesHaveIDs() {
      d(this.options.scales || {}, ((t, e) => {
        t.id = e
      }))
    }
    buildOrUpdateScales() {
      const t = this.options,
        e = t.scales,
        i = this.scales,
        s = Object.keys(i).reduce(((t, e) => (t[e] = !1, t)), {});
      let n = [];
      e && (n = n.concat(Object.keys(e).map((t => {
        const i = e[t],
          s = Zs(t, i),
          n = "r" === s,
          o = "x" === s;
        return {
          options: i,
          dposition: n ? "chartArea" : o ? "bottom" : "left",
          dtype: n ? "radialLinear" : o ? "category" : "linear"
        }
      })))), d(n, (e => {
        const n = e.options,
          o = n.id,
          a = Zs(o, n),
          l = r(n.type, e.dtype);
        void 0 !== n.position && hn(n.position, a) === hn(e.dposition) || (n.position = e.dposition), s[o] = !0;
        let h = null;
        if (o in i && i[o].type === l) h = i[o];
        else {
          h = new(Us.getScale(l))({
            id: o,
            type: l,
            ctx: this.ctx,
            chart: this
          }), i[h.id] = h
        }
        h.init(n, t)
      })), d(s, ((t, e) => {
        t || delete i[e]
      })), d(i, (t => {
        Zi.configure(this, t, t.options), Zi.addBox(this, t)
      }))
    }
    _updateMetasets() {
      const t = this._metasets,
        e = this.data.datasets.length,
        i = t.length;
      if (t.sort(((t, e) => t.index - e.index)), i > e) {
        for (let t = e; t < i; ++t) this._destroyDatasetMeta(t);
        t.splice(e, i - e)
      }
      this._sortedMetasets = t.slice(0).sort(cn("order", "index"))
    }
    _removeUnreferencedMetasets() {
      const {
        _metasets: t,
        data: {
          datasets: e
        }
      } = this;
      t.length > e.length && delete this._stacks, t.forEach(((t, i) => {
        0 === e.filter((e => e === t._dataset)).length && this._destroyDatasetMeta(i)
      }))
    }
    buildOrUpdateControllers() {
      const t = [],
        e = this.data.datasets;
      let i, s;
      for (this._removeUnreferencedMetasets(), i = 0, s = e.length; i < s; i++) {
        const s = e[i];
        let n = this.getDatasetMeta(i);
        const o = s.type || this.config.type;
        if (n.type && n.type !== o && (this._destroyDatasetMeta(i), n = this.getDatasetMeta(i)), n.type = o, n.indexAxis = s.indexAxis || Gs(o, this.options), n.order = s.order || 0, n.index = i, n.label = "" + s.label, n.visible = this.isDatasetVisible(i), n.controller) n.controller.updateIndex(i), n.controller.linkScales();
        else {
          const e = Us.getController(o),
            {
              datasetElementType: s,
              dataElementType: a
            } = ne.datasets[o];
          Object.assign(e.prototype, {
            dataElementType: Us.getElement(a),
            datasetElementType: s && Us.getElement(s)
          }), n.controller = new e(this, i), t.push(n.controller)
        }
      }
      return this._updateMetasets(), t
    }
    _resetElements() {
      d(this.data.datasets, ((t, e) => {
        this.getDatasetMeta(e).controller.reset()
      }), this)
    }
    reset() {
      this._resetElements(), this.notifyPlugins("reset")
    }
    update(t) {
      const e = this.config;
      e.update();
      const i = this._options = e.createResolver(e.chartOptionScopes(), this.getContext()),
        s = this._animationsDisabled = !i.animation;
      if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), !1 === this.notifyPlugins("beforeUpdate", {
          mode: t,
          cancelable: !0
        })) return;
      const n = this.buildOrUpdateControllers();
      this.notifyPlugins("beforeElementsUpdate");
      let o = 0;
      for (let t = 0, e = this.data.datasets.length; t < e; t++) {
        const {
          controller: e
        } = this.getDatasetMeta(t), i = !s && -1 === n.indexOf(e);
        e.buildOrUpdateElements(i), o = Math.max(+e.getMaxOverflow(), o)
      }
      o = this._minPadding = i.layout.autoPadding ? o : 0, this._updateLayout(o), s || d(n, (t => {
        t.reset()
      })), this._updateDatasets(t), this.notifyPlugins("afterUpdate", {
        mode: t
      }), this._layers.sort(cn("z", "_idx"));
      const {
        _active: a,
        _lastEvent: r
      } = this;
      r ? this._eventHandler(r, !0) : a.length && this._updateHoverStyles(a, a, !0), this.render()
    }
    _updateScales() {
      d(this.scales, (t => {
        Zi.removeBox(this, t)
      })), this.ensureScalesHaveIDs(), this.buildOrUpdateScales()
    }
    _checkEventBindings() {
      const t = this.options,
        e = new Set(Object.keys(this._listeners)),
        i = new Set(t.events);
      S(e, i) && !!this._responsiveListeners === t.responsive || (this.unbindEvents(), this.bindEvents())
    }
    _updateHiddenIndices() {
      const {
        _hiddenIndices: t
      } = this, e = this._getUniformDataChanges() || [];
      for (const {
          method: i,
          start: s,
          count: n
        } of e) {
        mn(t, s, "_removeElements" === i ? -n : n)
      }
    }
    _getUniformDataChanges() {
      const t = this._dataChanges;
      if (!t || !t.length) return;
      this._dataChanges = [];
      const e = this.data.datasets.length,
        i = e => new Set(t.filter((t => t[0] === e)).map(((t, e) => e + "," + t.splice(1).join(",")))),
        s = i(0);
      for (let t = 1; t < e; t++)
        if (!S(s, i(t))) return;
      return Array.from(s).map((t => t.split(","))).map((t => ({
        method: t[1],
        start: +t[2],
        count: +t[3]
      })))
    }
    _updateLayout(t) {
      if (!1 === this.notifyPlugins("beforeLayout", {
          cancelable: !0
        })) return;
      Zi.update(this, this.width, this.height, t);
      const e = this.chartArea,
        i = e.width <= 0 || e.height <= 0;
      this._layers = [], d(this.boxes, (t => {
        i && "chartArea" === t.position || (t.configure && t.configure(), this._layers.push(...t._layers()))
      }), this), this._layers.forEach(((t, e) => {
        t._idx = e
      })), this.notifyPlugins("afterLayout")
    }
    _updateDatasets(t) {
      if (!1 !== this.notifyPlugins("beforeDatasetsUpdate", {
          mode: t,
          cancelable: !0
        })) {
        for (let t = 0, e = this.data.datasets.length; t < e; ++t) this.getDatasetMeta(t).controller.configure();
        for (let e = 0, i = this.data.datasets.length; e < i; ++e) this._updateDataset(e, k(t) ? t({
          datasetIndex: e
        }) : t);
        this.notifyPlugins("afterDatasetsUpdate", {
          mode: t
        })
      }
    }
    _updateDataset(t, e) {
      const i = this.getDatasetMeta(t),
        s = {
          meta: i,
          index: t,
          mode: e,
          cancelable: !0
        };
      !1 !== this.notifyPlugins("beforeDatasetUpdate", s) && (i.controller._update(e), s.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", s))
    }
    render() {
      !1 !== this.notifyPlugins("beforeRender", {
        cancelable: !0
      }) && (mt.has(this) ? this.attached && !mt.running(this) && mt.start(this) : (this.draw(), dn({
        chart: this
      })))
    }
    draw() {
      let t;
      if (this._resizeBeforeDraw) {
        const {
          width: t,
          height: e
        } = this._resizeBeforeDraw;
        this._resize(t, e), this._resizeBeforeDraw = null
      }
      if (this.clear(), this.width <= 0 || this.height <= 0) return;
      if (!1 === this.notifyPlugins("beforeDraw", {
          cancelable: !0
        })) return;
      const e = this._layers;
      for (t = 0; t < e.length && e[t].z <= 0; ++t) e[t].draw(this.chartArea);
      for (this._drawDatasets(); t < e.length; ++t) e[t].draw(this.chartArea);
      this.notifyPlugins("afterDraw")
    }
    _getSortedDatasetMetas(t) {
      const e = this._sortedMetasets,
        i = [];
      let s, n;
      for (s = 0, n = e.length; s < n; ++s) {
        const n = e[s];
        t && !n.visible || i.push(n)
      }
      return i
    }
    getSortedVisibleDatasetMetas() {
      return this._getSortedDatasetMetas(!0)
    }
    _drawDatasets() {
      if (!1 === this.notifyPlugins("beforeDatasetsDraw", {
          cancelable: !0
        })) return;
      const t = this.getSortedVisibleDatasetMetas();
      for (let e = t.length - 1; e >= 0; --e) this._drawDataset(t[e]);
      this.notifyPlugins("afterDatasetsDraw")
    }
    _drawDataset(t) {
      const e = this.ctx,
        i = t._clip,
        s = !i.disabled,
        n = this.chartArea,
        o = {
          meta: t,
          index: t.index,
          cancelable: !0
        };
      !1 !== this.notifyPlugins("beforeDatasetDraw", o) && (s && Pe(e, {
        left: !1 === i.left ? 0 : n.left - i.left,
        right: !1 === i.right ? this.width : n.right + i.right,
        top: !1 === i.top ? 0 : n.top - i.top,
        bottom: !1 === i.bottom ? this.height : n.bottom + i.bottom
      }), t.controller.draw(), s && De(e), o.cancelable = !1, this.notifyPlugins("afterDatasetDraw", o))
    }
    isPointInArea(t) {
      return Se(t, this.chartArea, this._minPadding)
    }
    getElementsAtEventForMode(t, e, i, s) {
      const n = Vi.modes[e];
      return "function" == typeof n ? n(this, t, i, s) : []
    }
    getDatasetMeta(t) {
      const e = this.data.datasets[t],
        i = this._metasets;
      let s = i.filter((t => t && t._dataset === e)).pop();
      return s || (s = {
        type: null,
        data: [],
        dataset: null,
        controller: null,
        hidden: null,
        xAxisID: null,
        yAxisID: null,
        order: e && e.order || 0,
        index: t,
        _dataset: e,
        _parsed: [],
        _sorted: !1
      }, i.push(s)), s
    }
    getContext() {
      return this.$context || (this.$context = _i(null, {
        chart: this,
        type: "chart"
      }))
    }
    getVisibleDatasetCount() {
      return this.getSortedVisibleDatasetMetas().length
    }
    isDatasetVisible(t) {
      const e = this.data.datasets[t];
      if (!e) return !1;
      const i = this.getDatasetMeta(t);
      return "boolean" == typeof i.hidden ? !i.hidden : !e.hidden
    }
    setDatasetVisibility(t, e) {
      this.getDatasetMeta(t).hidden = !e
    }
    toggleDataVisibility(t) {
      this._hiddenIndices[t] = !this._hiddenIndices[t]
    }
    getDataVisibility(t) {
      return !this._hiddenIndices[t]
    }
    _updateVisibility(t, e, i) {
      const s = i ? "show" : "hide",
        n = this.getDatasetMeta(t),
        o = n.controller._resolveAnimations(void 0, s);
      M(e) ? (n.data[e].hidden = !i, this.update()) : (this.setDatasetVisibility(t, i), o.update(n, {
        visible: i
      }), this.update((e => e.datasetIndex === t ? s : void 0)))
    }
    hide(t, e) {
      this._updateVisibility(t, e, !1)
    }
    show(t, e) {
      this._updateVisibility(t, e, !0)
    }
    _destroyDatasetMeta(t) {
      const e = this._metasets[t];
      e && e.controller && e.controller._destroy(), delete this._metasets[t]
    }
    _stop() {
      let t, e;
      for (this.stop(), mt.remove(this), t = 0, e = this.data.datasets.length; t < e; ++t) this._destroyDatasetMeta(t)
    }
    destroy() {
      this.notifyPlugins("beforeDestroy");
      const {
        canvas: t,
        ctx: e
      } = this;
      this._stop(), this.config.clearCache(), t && (this.unbindEvents(), we(t, e), this.platform.releaseContext(e), this.canvas = null, this.ctx = null), this.notifyPlugins("destroy"), delete gn[this.id], this.notifyPlugins("afterDestroy")
    }
    toBase64Image(...t) {
      return this.canvas.toDataURL(...t)
    }
    bindEvents() {
      this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0
    }
    bindUserEvents() {
      const t = this._listeners,
        e = this.platform,
        i = (i, s) => {
          e.addEventListener(this, i, s), t[i] = s
        },
        s = (t, e, i) => {
          t.offsetX = e, t.offsetY = i, this._eventHandler(t)
        };
      d(this.options.events, (t => i(t, s)))
    }
    bindResponsiveEvents() {
      this._responsiveListeners || (this._responsiveListeners = {});
      const t = this._responsiveListeners,
        e = this.platform,
        i = (i, s) => {
          e.addEventListener(this, i, s), t[i] = s
        },
        s = (i, s) => {
          t[i] && (e.removeEventListener(this, i, s), delete t[i])
        },
        n = (t, e) => {
          this.canvas && this.resize(t, e)
        };
      let o;
      const a = () => {
        s("attach", a), this.attached = !0, this.resize(), i("resize", n), i("detach", o)
      };
      o = () => {
        this.attached = !1, s("resize", n), this._stop(), this._resize(0, 0), i("attach", a)
      }, e.isAttached(this.canvas) ? a() : o()
    }
    unbindEvents() {
      d(this._listeners, ((t, e) => {
        this.platform.removeEventListener(this, e, t)
      })), this._listeners = {}, d(this._responsiveListeners, ((t, e) => {
        this.platform.removeEventListener(this, e, t)
      })), this._responsiveListeners = void 0
    }
    updateHoverStyle(t, e, i) {
      const s = i ? "set" : "remove";
      let n, o, a, r;
      for ("dataset" === e && (n = this.getDatasetMeta(t[0].datasetIndex), n.controller["_" + s + "DatasetHoverStyle"]()), a = 0, r = t.length; a < r; ++a) {
        o = t[a];
        const e = o && this.getDatasetMeta(o.datasetIndex).controller;
        e && e[s + "HoverStyle"](o.element, o.datasetIndex, o.index)
      }
    }
    getActiveElements() {
      return this._active || []
    }
    setActiveElements(t) {
      const e = this._active || [],
        i = t.map((({
          datasetIndex: t,
          index: e
        }) => {
          const i = this.getDatasetMeta(t);
          if (!i) throw new Error("No dataset found at index " + t);
          return {
            datasetIndex: t,
            element: i.data[e],
            index: e
          }
        }));
      !u(i, e) && (this._active = i, this._lastEvent = null, this._updateHoverStyles(i, e))
    }
    notifyPlugins(t, e, i) {
      return this._plugins.notify(this, t, e, i)
    }
    _updateHoverStyles(t, e, i) {
      const s = this.options.hover,
        n = (t, e) => t.filter((t => !e.some((e => t.datasetIndex === e.datasetIndex && t.index === e.index)))),
        o = n(e, t),
        a = i ? t : n(t, e);
      o.length && this.updateHoverStyle(o, s.mode, !1), a.length && s.mode && this.updateHoverStyle(a, s.mode, !0)
    }
    _eventHandler(t, e) {
      const i = {
          event: t,
          replay: e,
          cancelable: !0,
          inChartArea: this.isPointInArea(t)
        },
        s = e => (e.options.events || this.options.events).includes(t.native.type);
      if (!1 === this.notifyPlugins("beforeEvent", i, s)) return;
      const n = this._handleEvent(t, e, i.inChartArea);
      return i.cancelable = !1, this.notifyPlugins("afterEvent", i, s), (n || i.changed) && this.render(), this
    }
    _handleEvent(t, e, i) {
      const {
        _active: s = [],
        options: n
      } = this, o = e, a = this._getActiveElements(t, s, i, o), r = P(t), l = function (t, e, i, s) {
        return i && "mouseout" !== t.type ? s ? e : t : null
      }(t, this._lastEvent, i, r);
      i && (this._lastEvent = null, c(n.onHover, [t, a, this], this), r && c(n.onClick, [t, a, this], this));
      const h = !u(a, s);
      return (h || e) && (this._active = a, this._updateHoverStyles(a, s, e)), this._lastEvent = l, h
    }
    _getActiveElements(t, e, i, s) {
      if ("mouseout" === t.type) return [];
      if (!i) return e;
      const n = this.options.hover;
      return this.getElementsAtEventForMode(t, n.mode, n, s)
    }
  }
  const xn = () => d(bn.instances, (t => t._plugins.invalidate())),
    _n = !0;

  function yn() {
    throw new Error("This method is not implemented: Check that a complete date adapter is provided.")
  }
  Object.defineProperties(bn, {
    defaults: {
      enumerable: _n,
      value: ne
    },
    instances: {
      enumerable: _n,
      value: gn
    },
    overrides: {
      enumerable: _n,
      value: te
    },
    registry: {
      enumerable: _n,
      value: Us
    },
    version: {
      enumerable: _n,
      value: "3.9.1"
    },
    getChart: {
      enumerable: _n,
      value: pn
    },
    register: {
      enumerable: _n,
      value: (...t) => {
        Us.add(...t), xn()
      }
    },
    unregister: {
      enumerable: _n,
      value: (...t) => {
        Us.remove(...t), xn()
      }
    }
  });
  class vn {
    constructor(t) {
      this.options = t || {}
    }
    init(t) {}
    formats() {
      return yn()
    }
    parse(t, e) {
      return yn()
    }
    format(t, e) {
      return yn()
    }
    add(t, e, i) {
      return yn()
    }
    diff(t, e, i) {
      return yn()
    }
    startOf(t, e, i) {
      return yn()
    }
    endOf(t, e) {
      return yn()
    }
  }
  vn.override = function (t) {
    Object.assign(vn.prototype, t)
  };
  var wn = {
    _date: vn
  };

  function Mn(t) {
    const e = t.iScale,
      i = function (t, e) {
        if (!t._cache.$bar) {
          const i = t.getMatchingVisibleMetas(e);
          let s = [];
          for (let e = 0, n = i.length; e < n; e++) s = s.concat(i[e].controller.getAllParsedValues(t));
          t._cache.$bar = rt(s.sort(((t, e) => t - e)))
        }
        return t._cache.$bar
      }(e, t.type);
    let s, n, o, a, r = e._length;
    const l = () => {
      32767 !== o && -32768 !== o && (M(a) && (r = Math.min(r, Math.abs(o - a) || r)), a = o)
    };
    for (s = 0, n = i.length; s < n; ++s) o = e.getPixelForValue(i[s]), l();
    for (a = void 0, s = 0, n = e.ticks.length; s < n; ++s) o = e.getPixelForTick(s), l();
    return r
  }

  function kn(t, e, i, n) {
    return s(t) ? function (t, e, i, s) {
      const n = i.parse(t[0], s),
        o = i.parse(t[1], s),
        a = Math.min(n, o),
        r = Math.max(n, o);
      let l = a,
        h = r;
      Math.abs(a) > Math.abs(r) && (l = r, h = a), e[i.axis] = h, e._custom = {
        barStart: l,
        barEnd: h,
        start: n,
        end: o,
        min: a,
        max: r
      }
    }(t, e, i, n) : e[i.axis] = i.parse(t, n), e
  }

  function Sn(t, e, i, s) {
    const n = t.iScale,
      o = t.vScale,
      a = n.getLabels(),
      r = n === o,
      l = [];
    let h, c, d, u;
    for (h = i, c = i + s; h < c; ++h) u = e[h], d = {}, d[n.axis] = r || n.parse(a[h], h), l.push(kn(u, d, o, h));
    return l
  }

  function Pn(t) {
    return t && void 0 !== t.barStart && void 0 !== t.barEnd
  }

  function Dn(t, e, i, s) {
    let n = e.borderSkipped;
    const o = {};
    if (!n) return void(t.borderSkipped = o);
    if (!0 === n) return void(t.borderSkipped = {
      top: !0,
      right: !0,
      bottom: !0,
      left: !0
    });
    const {
      start: a,
      end: r,
      reverse: l,
      top: h,
      bottom: c
    } = function (t) {
      let e, i, s, n, o;
      return t.horizontal ? (e = t.base > t.x, i = "left", s = "right") : (e = t.base < t.y, i = "bottom", s = "top"), e ? (n = "end", o = "start") : (n = "start", o = "end"), {
        start: i,
        end: s,
        reverse: e,
        top: n,
        bottom: o
      }
    }(t);
    "middle" === n && i && (t.enableBorderRadius = !0, (i._top || 0) === s ? n = h : (i._bottom || 0) === s ? n = c : (o[On(c, a, r, l)] = !0, n = h)), o[On(n, a, r, l)] = !0, t.borderSkipped = o
  }

  function On(t, e, i, s) {
    var n, o, a;
    return s ? (a = i, t = Cn(t = (n = t) === (o = e) ? a : n === a ? o : n, i, e)) : t = Cn(t, e, i), t
  }

  function Cn(t, e, i) {
    return "start" === t ? e : "end" === t ? i : t
  }

  function An(t, {
    inflateAmount: e
  }, i) {
    t.inflateAmount = "auto" === e ? 1 === i ? .33 : 0 : e
  }
  class Tn extends Ls {
    parsePrimitiveData(t, e, i, s) {
      return Sn(t, e, i, s)
    }
    parseArrayData(t, e, i, s) {
      return Sn(t, e, i, s)
    }
    parseObjectData(t, e, i, s) {
      const {
        iScale: n,
        vScale: o
      } = t, {
        xAxisKey: a = "x",
        yAxisKey: r = "y"
      } = this._parsing, l = "x" === n.axis ? a : r, h = "x" === o.axis ? a : r, c = [];
      let d, u, f, g;
      for (d = i, u = i + s; d < u; ++d) g = e[d], f = {}, f[n.axis] = n.parse(y(g, l), d), c.push(kn(y(g, h), f, o, d));
      return c
    }
    updateRangeFromParsed(t, e, i, s) {
      super.updateRangeFromParsed(t, e, i, s);
      const n = i._custom;
      n && e === this._cachedMeta.vScale && (t.min = Math.min(t.min, n.min), t.max = Math.max(t.max, n.max))
    }
    getMaxOverflow() {
      return 0
    }
    getLabelAndValue(t) {
      const e = this._cachedMeta,
        {
          iScale: i,
          vScale: s
        } = e,
        n = this.getParsed(t),
        o = n._custom,
        a = Pn(o) ? "[" + o.start + ", " + o.end + "]" : "" + s.getLabelForValue(n[s.axis]);
      return {
        label: "" + i.getLabelForValue(n[i.axis]),
        value: a
      }
    }
    initialize() {
      this.enableOptionSharing = !0, super.initialize();
      this._cachedMeta.stack = this.getDataset().stack
    }
    update(t) {
      const e = this._cachedMeta;
      this.updateElements(e.data, 0, e.data.length, t)
    }
    updateElements(t, e, s, n) {
      const o = "reset" === n,
        {
          index: a,
          _cachedMeta: {
            vScale: r
          }
        } = this,
        l = r.getBasePixel(),
        h = r.isHorizontal(),
        c = this._getRuler(),
        {
          sharedOptions: d,
          includeOptions: u
        } = this._getSharedOptions(e, n);
      for (let f = e; f < e + s; f++) {
        const e = this.getParsed(f),
          s = o || i(e[r.axis]) ? {
            base: l,
            head: l
          } : this._calculateBarValuePixels(f),
          g = this._calculateBarIndexPixels(f, c),
          p = (e._stacks || {})[r.axis],
          m = {
            horizontal: h,
            base: s.base,
            enableBorderRadius: !p || Pn(e._custom) || a === p._top || a === p._bottom,
            x: h ? s.head : g.center,
            y: h ? g.center : s.head,
            height: h ? g.size : Math.abs(s.size),
            width: h ? Math.abs(s.size) : g.size
          };
        u && (m.options = d || this.resolveDataElementOptions(f, t[f].active ? "active" : n));
        const b = m.options || t[f].options;
        Dn(m, b, p, a), An(m, b, c.ratio), this.updateElement(t[f], f, m, n)
      }
    }
    _getStacks(t, e) {
      const {
        iScale: s
      } = this._cachedMeta, n = s.getMatchingVisibleMetas(this._type).filter((t => t.controller.options.grouped)), o = s.options.stacked, a = [], r = t => {
        const s = t.controller.getParsed(e),
          n = s && s[t.vScale.axis];
        if (i(n) || isNaN(n)) return !0
      };
      for (const i of n)
        if ((void 0 === e || !r(i)) && ((!1 === o || -1 === a.indexOf(i.stack) || void 0 === o && void 0 === i.stack) && a.push(i.stack), i.index === t)) break;
      return a.length || a.push(void 0), a
    }
    _getStackCount(t) {
      return this._getStacks(void 0, t).length
    }
    _getStackIndex(t, e, i) {
      const s = this._getStacks(t, i),
        n = void 0 !== e ? s.indexOf(e) : -1;
      return -1 === n ? s.length - 1 : n
    }
    _getRuler() {
      const t = this.options,
        e = this._cachedMeta,
        i = e.iScale,
        s = [];
      let n, o;
      for (n = 0, o = e.data.length; n < o; ++n) s.push(i.getPixelForValue(this.getParsed(n)[i.axis], n));
      const a = t.barThickness;
      return {
        min: a || Mn(e),
        pixels: s,
        start: i._startPixel,
        end: i._endPixel,
        stackCount: this._getStackCount(),
        scale: i,
        grouped: t.grouped,
        ratio: a ? 1 : t.categoryPercentage * t.barPercentage
      }
    }
    _calculateBarValuePixels(t) {
      const {
        _cachedMeta: {
          vScale: e,
          _stacked: s
        },
        options: {
          base: n,
          minBarLength: o
        }
      } = this, a = n || 0, r = this.getParsed(t), l = r._custom, h = Pn(l);
      let c, d, u = r[e.axis],
        f = 0,
        g = s ? this.applyStack(e, r, s) : u;
      g !== u && (f = g - u, g = u), h && (u = l.barStart, g = l.barEnd - l.barStart, 0 !== u && z(u) !== z(l.barEnd) && (f = 0), f += u);
      const p = i(n) || h ? f : n;
      let m = e.getPixelForValue(p);
      if (c = this.chart.getDataVisibility(t) ? e.getPixelForValue(f + g) : m, d = c - m, Math.abs(d) < o) {
        d = function (t, e, i) {
          return 0 !== t ? z(t) : (e.isHorizontal() ? 1 : -1) * (e.min >= i ? 1 : -1)
        }(d, e, a) * o, u === a && (m -= d / 2);
        const t = e.getPixelForDecimal(0),
          i = e.getPixelForDecimal(1),
          s = Math.min(t, i),
          n = Math.max(t, i);
        m = Math.max(Math.min(m, n), s), c = m + d
      }
      if (m === e.getPixelForValue(a)) {
        const t = z(d) * e.getLineWidthForValue(a) / 2;
        m += t, d -= t
      }
      return {
        size: d,
        base: m,
        head: c,
        center: c + d / 2
      }
    }
    _calculateBarIndexPixels(t, e) {
      const s = e.scale,
        n = this.options,
        o = n.skipNull,
        a = r(n.maxBarThickness, 1 / 0);
      let l, h;
      if (e.grouped) {
        const s = o ? this._getStackCount(t) : e.stackCount,
          r = "flex" === n.barThickness ? function (t, e, i, s) {
            const n = e.pixels,
              o = n[t];
            let a = t > 0 ? n[t - 1] : null,
              r = t < n.length - 1 ? n[t + 1] : null;
            const l = i.categoryPercentage;
            null === a && (a = o - (null === r ? e.end - e.start : r - o)), null === r && (r = o + o - a);
            const h = o - (o - Math.min(a, r)) / 2 * l;
            return {
              chunk: Math.abs(r - a) / 2 * l / s,
              ratio: i.barPercentage,
              start: h
            }
          }(t, e, n, s) : function (t, e, s, n) {
            const o = s.barThickness;
            let a, r;
            return i(o) ? (a = e.min * s.categoryPercentage, r = s.barPercentage) : (a = o * n, r = 1), {
              chunk: a / n,
              ratio: r,
              start: e.pixels[t] - a / 2
            }
          }(t, e, n, s),
          c = this._getStackIndex(this.index, this._cachedMeta.stack, o ? t : void 0);
        l = r.start + r.chunk * c + r.chunk / 2, h = Math.min(a, r.chunk * r.ratio)
      } else l = s.getPixelForValue(this.getParsed(t)[s.axis], t), h = Math.min(a, e.min * e.ratio);
      return {
        base: l - h / 2,
        head: l + h / 2,
        center: l,
        size: h
      }
    }
    draw() {
      const t = this._cachedMeta,
        e = t.vScale,
        i = t.data,
        s = i.length;
      let n = 0;
      for (; n < s; ++n) null !== this.getParsed(n)[e.axis] && i[n].draw(this._ctx)
    }
  }
  Tn.id = "bar", Tn.defaults = {
    datasetElementType: !1,
    dataElementType: "bar",
    categoryPercentage: .8,
    barPercentage: .9,
    grouped: !0,
    animations: {
      numbers: {
        type: "number",
        properties: ["x", "y", "base", "width", "height"]
      }
    }
  }, Tn.overrides = {
    scales: {
      _index_: {
        type: "category",
        offset: !0,
        grid: {
          offset: !0
        }
      },
      _value_: {
        type: "linear",
        beginAtZero: !0
      }
    }
  };
  class Ln extends Ls {
    initialize() {
      this.enableOptionSharing = !0, super.initialize()
    }
    parsePrimitiveData(t, e, i, s) {
      const n = super.parsePrimitiveData(t, e, i, s);
      for (let t = 0; t < n.length; t++) n[t]._custom = this.resolveDataElementOptions(t + i).radius;
      return n
    }
    parseArrayData(t, e, i, s) {
      const n = super.parseArrayData(t, e, i, s);
      for (let t = 0; t < n.length; t++) {
        const s = e[i + t];
        n[t]._custom = r(s[2], this.resolveDataElementOptions(t + i).radius)
      }
      return n
    }
    parseObjectData(t, e, i, s) {
      const n = super.parseObjectData(t, e, i, s);
      for (let t = 0; t < n.length; t++) {
        const s = e[i + t];
        n[t]._custom = r(s && s.r && +s.r, this.resolveDataElementOptions(t + i).radius)
      }
      return n
    }
    getMaxOverflow() {
      const t = this._cachedMeta.data;
      let e = 0;
      for (let i = t.length - 1; i >= 0; --i) e = Math.max(e, t[i].size(this.resolveDataElementOptions(i)) / 2);
      return e > 0 && e
    }
    getLabelAndValue(t) {
      const e = this._cachedMeta,
        {
          xScale: i,
          yScale: s
        } = e,
        n = this.getParsed(t),
        o = i.getLabelForValue(n.x),
        a = s.getLabelForValue(n.y),
        r = n._custom;
      return {
        label: e.label,
        value: "(" + o + ", " + a + (r ? ", " + r : "") + ")"
      }
    }
    update(t) {
      const e = this._cachedMeta.data;
      this.updateElements(e, 0, e.length, t)
    }
    updateElements(t, e, i, s) {
      const n = "reset" === s,
        {
          iScale: o,
          vScale: a
        } = this._cachedMeta,
        {
          sharedOptions: r,
          includeOptions: l
        } = this._getSharedOptions(e, s),
        h = o.axis,
        c = a.axis;
      for (let d = e; d < e + i; d++) {
        const e = t[d],
          i = !n && this.getParsed(d),
          u = {},
          f = u[h] = n ? o.getPixelForDecimal(.5) : o.getPixelForValue(i[h]),
          g = u[c] = n ? a.getBasePixel() : a.getPixelForValue(i[c]);
        u.skip = isNaN(f) || isNaN(g), l && (u.options = r || this.resolveDataElementOptions(d, e.active ? "active" : s), n && (u.options.radius = 0)), this.updateElement(e, d, u, s)
      }
    }
    resolveDataElementOptions(t, e) {
      const i = this.getParsed(t);
      let s = super.resolveDataElementOptions(t, e);
      s.$shared && (s = Object.assign({}, s, {
        $shared: !1
      }));
      const n = s.radius;
      return "active" !== e && (s.radius = 0), s.radius += r(i && i._custom, n), s
    }
  }
  Ln.id = "bubble", Ln.defaults = {
    datasetElementType: !1,
    dataElementType: "point",
    animations: {
      numbers: {
        type: "number",
        properties: ["x", "y", "borderWidth", "radius"]
      }
    }
  }, Ln.overrides = {
    scales: {
      x: {
        type: "linear"
      },
      y: {
        type: "linear"
      }
    },
    plugins: {
      tooltip: {
        callbacks: {
          title: () => ""
        }
      }
    }
  };
  class En extends Ls {
    constructor(t, e) {
      super(t, e), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0
    }
    linkScales() {}
    parse(t, e) {
      const i = this.getDataset().data,
        s = this._cachedMeta;
      if (!1 === this._parsing) s._parsed = i;
      else {
        let o, a, r = t => +i[t];
        if (n(i[t])) {
          const {
            key: t = "value"
          } = this._parsing;
          r = e => +y(i[e], t)
        }
        for (o = t, a = t + e; o < a; ++o) s._parsed[o] = r(o)
      }
    }
    _getRotation() {
      return H(this.options.rotation - 90)
    }
    _getCircumference() {
      return H(this.options.circumference)
    }
    _getRotationExtents() {
      let t = O,
        e = -O;
      for (let i = 0; i < this.chart.data.datasets.length; ++i)
        if (this.chart.isDatasetVisible(i)) {
          const s = this.chart.getDatasetMeta(i).controller,
            n = s._getRotation(),
            o = s._getCircumference();
          t = Math.min(t, n), e = Math.max(e, n + o)
        } return {
        rotation: t,
        circumference: e - t
      }
    }
    update(t) {
      const e = this.chart,
        {
          chartArea: i
        } = e,
        s = this._cachedMeta,
        n = s.data,
        o = this.getMaxBorderWidth() + this.getMaxOffset(n) + this.options.spacing,
        a = Math.max((Math.min(i.width, i.height) - o) / 2, 0),
        r = Math.min(l(this.options.cutout, a), 1),
        c = this._getRingWeight(this.index),
        {
          circumference: d,
          rotation: u
        } = this._getRotationExtents(),
        {
          ratioX: f,
          ratioY: g,
          offsetX: p,
          offsetY: m
        } = function (t, e, i) {
          let s = 1,
            n = 1,
            o = 0,
            a = 0;
          if (e < O) {
            const r = t,
              l = r + e,
              h = Math.cos(r),
              c = Math.sin(r),
              d = Math.cos(l),
              u = Math.sin(l),
              f = (t, e, s) => G(t, r, l, !0) ? 1 : Math.max(e, e * i, s, s * i),
              g = (t, e, s) => G(t, r, l, !0) ? -1 : Math.min(e, e * i, s, s * i),
              p = f(0, h, d),
              m = f(L, c, u),
              b = g(D, h, d),
              x = g(D + L, c, u);
            s = (p - b) / 2, n = (m - x) / 2, o = -(p + b) / 2, a = -(m + x) / 2
          }
          return {
            ratioX: s,
            ratioY: n,
            offsetX: o,
            offsetY: a
          }
        }(u, d, r),
        b = (i.width - o) / f,
        x = (i.height - o) / g,
        _ = Math.max(Math.min(b, x) / 2, 0),
        y = h(this.options.radius, _),
        v = (y - Math.max(y * r, 0)) / this._getVisibleDatasetWeightTotal();
      this.offsetX = p * y, this.offsetY = m * y, s.total = this.calculateTotal(), this.outerRadius = y - v * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - v * c, 0), this.updateElements(n, 0, n.length, t)
    }
    _circumference(t, e) {
      const i = this.options,
        s = this._cachedMeta,
        n = this._getCircumference();
      return e && i.animation.animateRotate || !this.chart.getDataVisibility(t) || null === s._parsed[t] || s.data[t].hidden ? 0 : this.calculateCircumference(s._parsed[t] * n / O)
    }
    updateElements(t, e, i, s) {
      const n = "reset" === s,
        o = this.chart,
        a = o.chartArea,
        r = o.options.animation,
        l = (a.left + a.right) / 2,
        h = (a.top + a.bottom) / 2,
        c = n && r.animateScale,
        d = c ? 0 : this.innerRadius,
        u = c ? 0 : this.outerRadius,
        {
          sharedOptions: f,
          includeOptions: g
        } = this._getSharedOptions(e, s);
      let p, m = this._getRotation();
      for (p = 0; p < e; ++p) m += this._circumference(p, n);
      for (p = e; p < e + i; ++p) {
        const e = this._circumference(p, n),
          i = t[p],
          o = {
            x: l + this.offsetX,
            y: h + this.offsetY,
            startAngle: m,
            endAngle: m + e,
            circumference: e,
            outerRadius: u,
            innerRadius: d
          };
        g && (o.options = f || this.resolveDataElementOptions(p, i.active ? "active" : s)), m += e, this.updateElement(i, p, o, s)
      }
    }
    calculateTotal() {
      const t = this._cachedMeta,
        e = t.data;
      let i, s = 0;
      for (i = 0; i < e.length; i++) {
        const n = t._parsed[i];
        null === n || isNaN(n) || !this.chart.getDataVisibility(i) || e[i].hidden || (s += Math.abs(n))
      }
      return s
    }
    calculateCircumference(t) {
      const e = this._cachedMeta.total;
      return e > 0 && !isNaN(t) ? O * (Math.abs(t) / e) : 0
    }
    getLabelAndValue(t) {
      const e = this._cachedMeta,
        i = this.chart,
        s = i.data.labels || [],
        n = li(e._parsed[t], i.options.locale);
      return {
        label: s[t] || "",
        value: n
      }
    }
    getMaxBorderWidth(t) {
      let e = 0;
      const i = this.chart;
      let s, n, o, a, r;
      if (!t)
        for (s = 0, n = i.data.datasets.length; s < n; ++s)
          if (i.isDatasetVisible(s)) {
            o = i.getDatasetMeta(s), t = o.data, a = o.controller;
            break
          } if (!t) return 0;
      for (s = 0, n = t.length; s < n; ++s) r = a.resolveDataElementOptions(s), "inner" !== r.borderAlign && (e = Math.max(e, r.borderWidth || 0, r.hoverBorderWidth || 0));
      return e
    }
    getMaxOffset(t) {
      let e = 0;
      for (let i = 0, s = t.length; i < s; ++i) {
        const t = this.resolveDataElementOptions(i);
        e = Math.max(e, t.offset || 0, t.hoverOffset || 0)
      }
      return e
    }
    _getRingWeightOffset(t) {
      let e = 0;
      for (let i = 0; i < t; ++i) this.chart.isDatasetVisible(i) && (e += this._getRingWeight(i));
      return e
    }
    _getRingWeight(t) {
      return Math.max(r(this.chart.data.datasets[t].weight, 1), 0)
    }
    _getVisibleDatasetWeightTotal() {
      return this._getRingWeightOffset(this.chart.data.datasets.length) || 1
    }
  }
  En.id = "doughnut", En.defaults = {
    datasetElementType: !1,
    dataElementType: "arc",
    animation: {
      animateRotate: !0,
      animateScale: !1
    },
    animations: {
      numbers: {
        type: "number",
        properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"]
      }
    },
    cutout: "50%",
    rotation: 0,
    circumference: 360,
    radius: "100%",
    spacing: 0,
    indexAxis: "r"
  }, En.descriptors = {
    _scriptable: t => "spacing" !== t,
    _indexable: t => "spacing" !== t
  }, En.overrides = {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(t) {
            const e = t.data;
            if (e.labels.length && e.datasets.length) {
              const {
                labels: {
                  pointStyle: i
                }
              } = t.legend.options;
              return e.labels.map(((e, s) => {
                const n = t.getDatasetMeta(0).controller.getStyle(s);
                return {
                  text: e,
                  fillStyle: n.backgroundColor,
                  strokeStyle: n.borderColor,
                  lineWidth: n.borderWidth,
                  pointStyle: i,
                  hidden: !t.getDataVisibility(s),
                  index: s
                }
              }))
            }
            return []
          }
        },
        onClick(t, e, i) {
          i.chart.toggleDataVisibility(e.index), i.chart.update()
        }
      },
      tooltip: {
        callbacks: {
          title: () => "",
          label(t) {
            let e = t.label;
            const i = ": " + t.formattedValue;
            return s(e) ? (e = e.slice(), e[0] += i) : e += i, e
          }
        }
      }
    }
  };
  class Rn extends Ls {
    initialize() {
      this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize()
    }
    update(t) {
      const e = this._cachedMeta,
        {
          dataset: i,
          data: s = [],
          _dataset: n
        } = e,
        o = this.chart._animationsDisabled;
      let {
        start: a,
        count: r
      } = gt(e, s, o);
      this._drawStart = a, this._drawCount = r, pt(e) && (a = 0, r = s.length), i._chart = this.chart, i._datasetIndex = this.index, i._decimated = !!n._decimated, i.points = s;
      const l = this.resolveDatasetElementOptions(t);
      this.options.showLine || (l.borderWidth = 0), l.segment = this.options.segment, this.updateElement(i, void 0, {
        animated: !o,
        options: l
      }, t), this.updateElements(s, a, r, t)
    }
    updateElements(t, e, s, n) {
      const o = "reset" === n,
        {
          iScale: a,
          vScale: r,
          _stacked: l,
          _dataset: h
        } = this._cachedMeta,
        {
          sharedOptions: c,
          includeOptions: d
        } = this._getSharedOptions(e, n),
        u = a.axis,
        f = r.axis,
        {
          spanGaps: g,
          segment: p
        } = this.options,
        m = B(g) ? g : Number.POSITIVE_INFINITY,
        b = this.chart._animationsDisabled || o || "none" === n;
      let x = e > 0 && this.getParsed(e - 1);
      for (let g = e; g < e + s; ++g) {
        const e = t[g],
          s = this.getParsed(g),
          _ = b ? e : {},
          y = i(s[f]),
          v = _[u] = a.getPixelForValue(s[u], g),
          w = _[f] = o || y ? r.getBasePixel() : r.getPixelForValue(l ? this.applyStack(r, s, l) : s[f], g);
        _.skip = isNaN(v) || isNaN(w) || y, _.stop = g > 0 && Math.abs(s[u] - x[u]) > m, p && (_.parsed = s, _.raw = h.data[g]), d && (_.options = c || this.resolveDataElementOptions(g, e.active ? "active" : n)), b || this.updateElement(e, g, _, n), x = s
      }
    }
    getMaxOverflow() {
      const t = this._cachedMeta,
        e = t.dataset,
        i = e.options && e.options.borderWidth || 0,
        s = t.data || [];
      if (!s.length) return i;
      const n = s[0].size(this.resolveDataElementOptions(0)),
        o = s[s.length - 1].size(this.resolveDataElementOptions(s.length - 1));
      return Math.max(i, n, o) / 2
    }
    draw() {
      const t = this._cachedMeta;
      t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis), super.draw()
    }
  }
  Rn.id = "line", Rn.defaults = {
    datasetElementType: "line",
    dataElementType: "point",
    showLine: !0,
    spanGaps: !1
  }, Rn.overrides = {
    scales: {
      _index_: {
        type: "category"
      },
      _value_: {
        type: "linear"
      }
    }
  };
  class In extends Ls {
    constructor(t, e) {
      super(t, e), this.innerRadius = void 0, this.outerRadius = void 0
    }
    getLabelAndValue(t) {
      const e = this._cachedMeta,
        i = this.chart,
        s = i.data.labels || [],
        n = li(e._parsed[t].r, i.options.locale);
      return {
        label: s[t] || "",
        value: n
      }
    }
    parseObjectData(t, e, i, s) {
      return Ue.bind(this)(t, e, i, s)
    }
    update(t) {
      const e = this._cachedMeta.data;
      this._updateRadius(), this.updateElements(e, 0, e.length, t)
    }
    getMinMax() {
      const t = this._cachedMeta,
        e = {
          min: Number.POSITIVE_INFINITY,
          max: Number.NEGATIVE_INFINITY
        };
      return t.data.forEach(((t, i) => {
        const s = this.getParsed(i).r;
        !isNaN(s) && this.chart.getDataVisibility(i) && (s < e.min && (e.min = s), s > e.max && (e.max = s))
      })), e
    }
    _updateRadius() {
      const t = this.chart,
        e = t.chartArea,
        i = t.options,
        s = Math.min(e.right - e.left, e.bottom - e.top),
        n = Math.max(s / 2, 0),
        o = (n - Math.max(i.cutoutPercentage ? n / 100 * i.cutoutPercentage : 1, 0)) / t.getVisibleDatasetCount();
      this.outerRadius = n - o * this.index, this.innerRadius = this.outerRadius - o
    }
    updateElements(t, e, i, s) {
      const n = "reset" === s,
        o = this.chart,
        a = o.options.animation,
        r = this._cachedMeta.rScale,
        l = r.xCenter,
        h = r.yCenter,
        c = r.getIndexAngle(0) - .5 * D;
      let d, u = c;
      const f = 360 / this.countVisibleElements();
      for (d = 0; d < e; ++d) u += this._computeAngle(d, s, f);
      for (d = e; d < e + i; d++) {
        const e = t[d];
        let i = u,
          g = u + this._computeAngle(d, s, f),
          p = o.getDataVisibility(d) ? r.getDistanceFromCenterForValue(this.getParsed(d).r) : 0;
        u = g, n && (a.animateScale && (p = 0), a.animateRotate && (i = g = c));
        const m = {
          x: l,
          y: h,
          innerRadius: 0,
          outerRadius: p,
          startAngle: i,
          endAngle: g,
          options: this.resolveDataElementOptions(d, e.active ? "active" : s)
        };
        this.updateElement(e, d, m, s)
      }
    }
    countVisibleElements() {
      const t = this._cachedMeta;
      let e = 0;
      return t.data.forEach(((t, i) => {
        !isNaN(this.getParsed(i).r) && this.chart.getDataVisibility(i) && e++
      })), e
    }
    _computeAngle(t, e, i) {
      return this.chart.getDataVisibility(t) ? H(this.resolveDataElementOptions(t, e).angle || i) : 0
    }
  }
  In.id = "polarArea", In.defaults = {
    dataElementType: "arc",
    animation: {
      animateRotate: !0,
      animateScale: !0
    },
    animations: {
      numbers: {
        type: "number",
        properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"]
      }
    },
    indexAxis: "r",
    startAngle: 0
  }, In.overrides = {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(t) {
            const e = t.data;
            if (e.labels.length && e.datasets.length) {
              const {
                labels: {
                  pointStyle: i
                }
              } = t.legend.options;
              return e.labels.map(((e, s) => {
                const n = t.getDatasetMeta(0).controller.getStyle(s);
                return {
                  text: e,
                  fillStyle: n.backgroundColor,
                  strokeStyle: n.borderColor,
                  lineWidth: n.borderWidth,
                  pointStyle: i,
                  hidden: !t.getDataVisibility(s),
                  index: s
                }
              }))
            }
            return []
          }
        },
        onClick(t, e, i) {
          i.chart.toggleDataVisibility(e.index), i.chart.update()
        }
      },
      tooltip: {
        callbacks: {
          title: () => "",
          label: t => t.chart.data.labels[t.dataIndex] + ": " + t.formattedValue
        }
      }
    },
    scales: {
      r: {
        type: "radialLinear",
        angleLines: {
          display: !1
        },
        beginAtZero: !0,
        grid: {
          circular: !0
        },
        pointLabels: {
          display: !1
        },
        startAngle: 0
      }
    }
  };
  class zn extends En {}
  zn.id = "pie", zn.defaults = {
    cutout: 0,
    rotation: 0,
    circumference: 360,
    radius: "100%"
  };
  class Fn extends Ls {
    getLabelAndValue(t) {
      const e = this._cachedMeta.vScale,
        i = this.getParsed(t);
      return {
        label: e.getLabels()[t],
        value: "" + e.getLabelForValue(i[e.axis])
      }
    }
    parseObjectData(t, e, i, s) {
      return Ue.bind(this)(t, e, i, s)
    }
    update(t) {
      const e = this._cachedMeta,
        i = e.dataset,
        s = e.data || [],
        n = e.iScale.getLabels();
      if (i.points = s, "resize" !== t) {
        const e = this.resolveDatasetElementOptions(t);
        this.options.showLine || (e.borderWidth = 0);
        const o = {
          _loop: !0,
          _fullLoop: n.length === s.length,
          options: e
        };
        this.updateElement(i, void 0, o, t)
      }
      this.updateElements(s, 0, s.length, t)
    }
    updateElements(t, e, i, s) {
      const n = this._cachedMeta.rScale,
        o = "reset" === s;
      for (let a = e; a < e + i; a++) {
        const e = t[a],
          i = this.resolveDataElementOptions(a, e.active ? "active" : s),
          r = n.getPointPositionForValue(a, this.getParsed(a).r),
          l = o ? n.xCenter : r.x,
          h = o ? n.yCenter : r.y,
          c = {
            x: l,
            y: h,
            angle: r.angle,
            skip: isNaN(l) || isNaN(h),
            options: i
          };
        this.updateElement(e, a, c, s)
      }
    }
  }
  Fn.id = "radar", Fn.defaults = {
    datasetElementType: "line",
    dataElementType: "point",
    indexAxis: "r",
    showLine: !0,
    elements: {
      line: {
        fill: "start"
      }
    }
  }, Fn.overrides = {
    aspectRatio: 1,
    scales: {
      r: {
        type: "radialLinear"
      }
    }
  };
  class Vn extends Ls {
    update(t) {
      const e = this._cachedMeta,
        {
          data: i = []
        } = e,
        s = this.chart._animationsDisabled;
      let {
        start: n,
        count: o
      } = gt(e, i, s);
      if (this._drawStart = n, this._drawCount = o, pt(e) && (n = 0, o = i.length), this.options.showLine) {
        const {
          dataset: n,
          _dataset: o
        } = e;
        n._chart = this.chart, n._datasetIndex = this.index, n._decimated = !!o._decimated, n.points = i;
        const a = this.resolveDatasetElementOptions(t);
        a.segment = this.options.segment, this.updateElement(n, void 0, {
          animated: !s,
          options: a
        }, t)
      }
      this.updateElements(i, n, o, t)
    }
    addElements() {
      const {
        showLine: t
      } = this.options;
      !this.datasetElementType && t && (this.datasetElementType = Us.getElement("line")), super.addElements()
    }
    updateElements(t, e, s, n) {
      const o = "reset" === n,
        {
          iScale: a,
          vScale: r,
          _stacked: l,
          _dataset: h
        } = this._cachedMeta,
        c = this.resolveDataElementOptions(e, n),
        d = this.getSharedOptions(c),
        u = this.includeOptions(n, d),
        f = a.axis,
        g = r.axis,
        {
          spanGaps: p,
          segment: m
        } = this.options,
        b = B(p) ? p : Number.POSITIVE_INFINITY,
        x = this.chart._animationsDisabled || o || "none" === n;
      let _ = e > 0 && this.getParsed(e - 1);
      for (let c = e; c < e + s; ++c) {
        const e = t[c],
          s = this.getParsed(c),
          p = x ? e : {},
          y = i(s[g]),
          v = p[f] = a.getPixelForValue(s[f], c),
          w = p[g] = o || y ? r.getBasePixel() : r.getPixelForValue(l ? this.applyStack(r, s, l) : s[g], c);
        p.skip = isNaN(v) || isNaN(w) || y, p.stop = c > 0 && Math.abs(s[f] - _[f]) > b, m && (p.parsed = s, p.raw = h.data[c]), u && (p.options = d || this.resolveDataElementOptions(c, e.active ? "active" : n)), x || this.updateElement(e, c, p, n), _ = s
      }
      this.updateSharedOptions(d, n, c)
    }
    getMaxOverflow() {
      const t = this._cachedMeta,
        e = t.data || [];
      if (!this.options.showLine) {
        let t = 0;
        for (let i = e.length - 1; i >= 0; --i) t = Math.max(t, e[i].size(this.resolveDataElementOptions(i)) / 2);
        return t > 0 && t
      }
      const i = t.dataset,
        s = i.options && i.options.borderWidth || 0;
      if (!e.length) return s;
      const n = e[0].size(this.resolveDataElementOptions(0)),
        o = e[e.length - 1].size(this.resolveDataElementOptions(e.length - 1));
      return Math.max(s, n, o) / 2
    }
  }
  Vn.id = "scatter", Vn.defaults = {
    datasetElementType: !1,
    dataElementType: "point",
    showLine: !1,
    fill: !1
  }, Vn.overrides = {
    interaction: {
      mode: "point"
    },
    plugins: {
      tooltip: {
        callbacks: {
          title: () => "",
          label: t => "(" + t.label + ", " + t.formattedValue + ")"
        }
      }
    },
    scales: {
      x: {
        type: "linear"
      },
      y: {
        type: "linear"
      }
    }
  };
  var Bn = Object.freeze({
    __proto__: null,
    BarController: Tn,
    BubbleController: Ln,
    DoughnutController: En,
    LineController: Rn,
    PolarAreaController: In,
    PieController: zn,
    RadarController: Fn,
    ScatterController: Vn
  });

  function Nn(t, e, i) {
    const {
      startAngle: s,
      pixelMargin: n,
      x: o,
      y: a,
      outerRadius: r,
      innerRadius: l
    } = e;
    let h = n / r;
    t.beginPath(), t.arc(o, a, r, s - h, i + h), l > n ? (h = n / l, t.arc(o, a, l, i + h, s - h, !0)) : t.arc(o, a, n, i + L, s - L), t.closePath(), t.clip()
  }

  function Wn(t, e, i, s) {
    const n = ui(t.options.borderRadius, ["outerStart", "outerEnd", "innerStart", "innerEnd"]);
    const o = (i - e) / 2,
      a = Math.min(o, s * e / 2),
      r = t => {
        const e = (i - Math.min(o, t)) * s / 2;
        return Z(t, 0, Math.min(o, e))
      };
    return {
      outerStart: r(n.outerStart),
      outerEnd: r(n.outerEnd),
      innerStart: Z(n.innerStart, 0, a),
      innerEnd: Z(n.innerEnd, 0, a)
    }
  }

  function jn(t, e, i, s) {
    return {
      x: i + t * Math.cos(e),
      y: s + t * Math.sin(e)
    }
  }

  function Hn(t, e, i, s, n, o) {
    const {
      x: a,
      y: r,
      startAngle: l,
      pixelMargin: h,
      innerRadius: c
    } = e, d = Math.max(e.outerRadius + s + i - h, 0), u = c > 0 ? c + s + i + h : 0;
    let f = 0;
    const g = n - l;
    if (s) {
      const t = ((c > 0 ? c - s : 0) + (d > 0 ? d - s : 0)) / 2;
      f = (g - (0 !== t ? g * t / (t + s) : g)) / 2
    }
    const p = (g - Math.max(.001, g * d - i / D) / d) / 2,
      m = l + p + f,
      b = n - p - f,
      {
        outerStart: x,
        outerEnd: _,
        innerStart: y,
        innerEnd: v
      } = Wn(e, u, d, b - m),
      w = d - x,
      M = d - _,
      k = m + x / w,
      S = b - _ / M,
      P = u + y,
      O = u + v,
      C = m + y / P,
      A = b - v / O;
    if (t.beginPath(), o) {
      if (t.arc(a, r, d, k, S), _ > 0) {
        const e = jn(M, S, a, r);
        t.arc(e.x, e.y, _, S, b + L)
      }
      const e = jn(O, b, a, r);
      if (t.lineTo(e.x, e.y), v > 0) {
        const e = jn(O, A, a, r);
        t.arc(e.x, e.y, v, b + L, A + Math.PI)
      }
      if (t.arc(a, r, u, b - v / u, m + y / u, !0), y > 0) {
        const e = jn(P, C, a, r);
        t.arc(e.x, e.y, y, C + Math.PI, m - L)
      }
      const i = jn(w, m, a, r);
      if (t.lineTo(i.x, i.y), x > 0) {
        const e = jn(w, k, a, r);
        t.arc(e.x, e.y, x, m - L, k)
      }
    } else {
      t.moveTo(a, r);
      const e = Math.cos(k) * d + a,
        i = Math.sin(k) * d + r;
      t.lineTo(e, i);
      const s = Math.cos(S) * d + a,
        n = Math.sin(S) * d + r;
      t.lineTo(s, n)
    }
    t.closePath()
  }

  function $n(t, e, i, s, n, o) {
    const {
      options: a
    } = e, {
      borderWidth: r,
      borderJoinStyle: l
    } = a, h = "inner" === a.borderAlign;
    r && (h ? (t.lineWidth = 2 * r, t.lineJoin = l || "round") : (t.lineWidth = r, t.lineJoin = l || "bevel"), e.fullCircles && function (t, e, i) {
      const {
        x: s,
        y: n,
        startAngle: o,
        pixelMargin: a,
        fullCircles: r
      } = e, l = Math.max(e.outerRadius - a, 0), h = e.innerRadius + a;
      let c;
      for (i && Nn(t, e, o + O), t.beginPath(), t.arc(s, n, h, o + O, o, !0), c = 0; c < r; ++c) t.stroke();
      for (t.beginPath(), t.arc(s, n, l, o, o + O), c = 0; c < r; ++c) t.stroke()
    }(t, e, h), h && Nn(t, e, n), Hn(t, e, i, s, n, o), t.stroke())
  }
  class Yn extends Es {
    constructor(t) {
      super(), this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, t && Object.assign(this, t)
    }
    inRange(t, e, i) {
      const s = this.getProps(["x", "y"], i),
        {
          angle: n,
          distance: o
        } = U(s, {
          x: t,
          y: e
        }),
        {
          startAngle: a,
          endAngle: l,
          innerRadius: h,
          outerRadius: c,
          circumference: d
        } = this.getProps(["startAngle", "endAngle", "innerRadius", "outerRadius", "circumference"], i),
        u = this.options.spacing / 2,
        f = r(d, l - a) >= O || G(n, a, l),
        g = Q(o, h + u, c + u);
      return f && g
    }
    getCenterPoint(t) {
      const {
        x: e,
        y: i,
        startAngle: s,
        endAngle: n,
        innerRadius: o,
        outerRadius: a
      } = this.getProps(["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius", "circumference"], t), {
        offset: r,
        spacing: l
      } = this.options, h = (s + n) / 2, c = (o + a + l + r) / 2;
      return {
        x: e + Math.cos(h) * c,
        y: i + Math.sin(h) * c
      }
    }
    tooltipPosition(t) {
      return this.getCenterPoint(t)
    }
    draw(t) {
      const {
        options: e,
        circumference: i
      } = this, s = (e.offset || 0) / 2, n = (e.spacing || 0) / 2, o = e.circular;
      if (this.pixelMargin = "inner" === e.borderAlign ? .33 : 0, this.fullCircles = i > O ? Math.floor(i / O) : 0, 0 === i || this.innerRadius < 0 || this.outerRadius < 0) return;
      t.save();
      let a = 0;
      if (s) {
        a = s / 2;
        const e = (this.startAngle + this.endAngle) / 2;
        t.translate(Math.cos(e) * a, Math.sin(e) * a), this.circumference >= D && (a = s)
      }
      t.fillStyle = e.backgroundColor, t.strokeStyle = e.borderColor;
      const r = function (t, e, i, s, n) {
        const {
          fullCircles: o,
          startAngle: a,
          circumference: r
        } = e;
        let l = e.endAngle;
        if (o) {
          Hn(t, e, i, s, a + O, n);
          for (let e = 0; e < o; ++e) t.fill();
          isNaN(r) || (l = a + r % O, r % O == 0 && (l += O))
        }
        return Hn(t, e, i, s, l, n), t.fill(), l
      }(t, this, a, n, o);
      $n(t, this, a, n, r, o), t.restore()
    }
  }

  function Un(t, e, i = e) {
    t.lineCap = r(i.borderCapStyle, e.borderCapStyle), t.setLineDash(r(i.borderDash, e.borderDash)), t.lineDashOffset = r(i.borderDashOffset, e.borderDashOffset), t.lineJoin = r(i.borderJoinStyle, e.borderJoinStyle), t.lineWidth = r(i.borderWidth, e.borderWidth), t.strokeStyle = r(i.borderColor, e.borderColor)
  }

  function Xn(t, e, i) {
    t.lineTo(i.x, i.y)
  }

  function qn(t, e, i = {}) {
    const s = t.length,
      {
        start: n = 0,
        end: o = s - 1
      } = i,
      {
        start: a,
        end: r
      } = e,
      l = Math.max(n, a),
      h = Math.min(o, r),
      c = n < a && o < a || n > r && o > r;
    return {
      count: s,
      start: l,
      loop: e.loop,
      ilen: h < l && !c ? s + h - l : h - l
    }
  }

  function Kn(t, e, i, s) {
    const {
      points: n,
      options: o
    } = e, {
      count: a,
      start: r,
      loop: l,
      ilen: h
    } = qn(n, i, s), c = function (t) {
      return t.stepped ? Oe : t.tension || "monotone" === t.cubicInterpolationMode ? Ce : Xn
    }(o);
    let d, u, f, {
      move: g = !0,
      reverse: p
    } = s || {};
    for (d = 0; d <= h; ++d) u = n[(r + (p ? h - d : d)) % a], u.skip || (g ? (t.moveTo(u.x, u.y), g = !1) : c(t, f, u, p, o.stepped), f = u);
    return l && (u = n[(r + (p ? h : 0)) % a], c(t, f, u, p, o.stepped)), !!l
  }

  function Gn(t, e, i, s) {
    const n = e.points,
      {
        count: o,
        start: a,
        ilen: r
      } = qn(n, i, s),
      {
        move: l = !0,
        reverse: h
      } = s || {};
    let c, d, u, f, g, p, m = 0,
      b = 0;
    const x = t => (a + (h ? r - t : t)) % o,
      _ = () => {
        f !== g && (t.lineTo(m, g), t.lineTo(m, f), t.lineTo(m, p))
      };
    for (l && (d = n[x(0)], t.moveTo(d.x, d.y)), c = 0; c <= r; ++c) {
      if (d = n[x(c)], d.skip) continue;
      const e = d.x,
        i = d.y,
        s = 0 | e;
      s === u ? (i < f ? f = i : i > g && (g = i), m = (b * m + e) / ++b) : (_(), t.lineTo(e, i), u = s, b = 0, f = g = i), p = i
    }
    _()
  }

  function Zn(t) {
    const e = t.options,
      i = e.borderDash && e.borderDash.length;
    return !(t._decimated || t._loop || e.tension || "monotone" === e.cubicInterpolationMode || e.stepped || i) ? Gn : Kn
  }
  Yn.id = "arc", Yn.defaults = {
    borderAlign: "center",
    borderColor: "#fff",
    borderJoinStyle: void 0,
    borderRadius: 0,
    borderWidth: 2,
    offset: 0,
    spacing: 0,
    angle: void 0,
    circular: !0
  }, Yn.defaultRoutes = {
    backgroundColor: "backgroundColor"
  };
  const Jn = "function" == typeof Path2D;

  function Qn(t, e, i, s) {
    Jn && !e.options.segment ? function (t, e, i, s) {
      let n = e._path;
      n || (n = e._path = new Path2D, e.path(n, i, s) && n.closePath()), Un(t, e.options), t.stroke(n)
    }(t, e, i, s) : function (t, e, i, s) {
      const {
        segments: n,
        options: o
      } = e, a = Zn(e);
      for (const r of n) Un(t, o, r.style), t.beginPath(), a(t, e, r, {
        start: i,
        end: i + s - 1
      }) && t.closePath(), t.stroke()
    }(t, e, i, s)
  }
  class to extends Es {
    constructor(t) {
      super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, t && Object.assign(this, t)
    }
    updateControlPoints(t, e) {
      const i = this.options;
      if ((i.tension || "monotone" === i.cubicInterpolationMode) && !i.stepped && !this._pointsUpdated) {
        const s = i.spanGaps ? this._loop : this._fullLoop;
        Qe(this._points, i, t, s, e), this._pointsUpdated = !0
      }
    }
    set points(t) {
      this._points = t, delete this._segments, delete this._path, this._pointsUpdated = !1
    }
    get points() {
      return this._points
    }
    get segments() {
      return this._segments || (this._segments = Di(this, this.options.segment))
    }
    first() {
      const t = this.segments,
        e = this.points;
      return t.length && e[t[0].start]
    }
    last() {
      const t = this.segments,
        e = this.points,
        i = t.length;
      return i && e[t[i - 1].end]
    }
    interpolate(t, e) {
      const i = this.options,
        s = t[e],
        n = this.points,
        o = Pi(this, {
          property: e,
          start: s,
          end: s
        });
      if (!o.length) return;
      const a = [],
        r = function (t) {
          return t.stepped ? oi : t.tension || "monotone" === t.cubicInterpolationMode ? ai : ni
        }(i);
      let l, h;
      for (l = 0, h = o.length; l < h; ++l) {
        const {
          start: h,
          end: c
        } = o[l], d = n[h], u = n[c];
        if (d === u) {
          a.push(d);
          continue
        }
        const f = r(d, u, Math.abs((s - d[e]) / (u[e] - d[e])), i.stepped);
        f[e] = t[e], a.push(f)
      }
      return 1 === a.length ? a[0] : a
    }
    pathSegment(t, e, i) {
      return Zn(this)(t, this, e, i)
    }
    path(t, e, i) {
      const s = this.segments,
        n = Zn(this);
      let o = this._loop;
      e = e || 0, i = i || this.points.length - e;
      for (const a of s) o &= n(t, this, a, {
        start: e,
        end: e + i - 1
      });
      return !!o
    }
    draw(t, e, i, s) {
      const n = this.options || {};
      (this.points || []).length && n.borderWidth && (t.save(), Qn(t, this, i, s), t.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0)
    }
  }

  function eo(t, e, i, s) {
    const n = t.options,
      {
        [i]: o
      } = t.getProps([i], s);
    return Math.abs(e - o) < n.radius + n.hitRadius
  }
  to.id = "line", to.defaults = {
    borderCapStyle: "butt",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: "miter",
    borderWidth: 3,
    capBezierPoints: !0,
    cubicInterpolationMode: "default",
    fill: !1,
    spanGaps: !1,
    stepped: !1,
    tension: 0
  }, to.defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  }, to.descriptors = {
    _scriptable: !0,
    _indexable: t => "borderDash" !== t && "fill" !== t
  };
  class io extends Es {
    constructor(t) {
      super(), this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, t && Object.assign(this, t)
    }
    inRange(t, e, i) {
      const s = this.options,
        {
          x: n,
          y: o
        } = this.getProps(["x", "y"], i);
      return Math.pow(t - n, 2) + Math.pow(e - o, 2) < Math.pow(s.hitRadius + s.radius, 2)
    }
    inXRange(t, e) {
      return eo(this, t, "x", e)
    }
    inYRange(t, e) {
      return eo(this, t, "y", e)
    }
    getCenterPoint(t) {
      const {
        x: e,
        y: i
      } = this.getProps(["x", "y"], t);
      return {
        x: e,
        y: i
      }
    }
    size(t) {
      let e = (t = t || this.options || {}).radius || 0;
      e = Math.max(e, e && t.hoverRadius || 0);
      return 2 * (e + (e && t.borderWidth || 0))
    }
    draw(t, e) {
      const i = this.options;
      this.skip || i.radius < .1 || !Se(this, e, this.size(i) / 2) || (t.strokeStyle = i.borderColor, t.lineWidth = i.borderWidth, t.fillStyle = i.backgroundColor, Me(t, i, this.x, this.y))
    }
    getRange() {
      const t = this.options || {};
      return t.radius + t.hitRadius
    }
  }

  function so(t, e) {
    const {
      x: i,
      y: s,
      base: n,
      width: o,
      height: a
    } = t.getProps(["x", "y", "base", "width", "height"], e);
    let r, l, h, c, d;
    return t.horizontal ? (d = a / 2, r = Math.min(i, n), l = Math.max(i, n), h = s - d, c = s + d) : (d = o / 2, r = i - d, l = i + d, h = Math.min(s, n), c = Math.max(s, n)), {
      left: r,
      top: h,
      right: l,
      bottom: c
    }
  }

  function no(t, e, i, s) {
    return t ? 0 : Z(e, i, s)
  }

  function oo(t) {
    const e = so(t),
      i = e.right - e.left,
      s = e.bottom - e.top,
      o = function (t, e, i) {
        const s = t.options.borderWidth,
          n = t.borderSkipped,
          o = fi(s);
        return {
          t: no(n.top, o.top, 0, i),
          r: no(n.right, o.right, 0, e),
          b: no(n.bottom, o.bottom, 0, i),
          l: no(n.left, o.left, 0, e)
        }
      }(t, i / 2, s / 2),
      a = function (t, e, i) {
        const {
          enableBorderRadius: s
        } = t.getProps(["enableBorderRadius"]), o = t.options.borderRadius, a = gi(o), r = Math.min(e, i), l = t.borderSkipped, h = s || n(o);
        return {
          topLeft: no(!h || l.top || l.left, a.topLeft, 0, r),
          topRight: no(!h || l.top || l.right, a.topRight, 0, r),
          bottomLeft: no(!h || l.bottom || l.left, a.bottomLeft, 0, r),
          bottomRight: no(!h || l.bottom || l.right, a.bottomRight, 0, r)
        }
      }(t, i / 2, s / 2);
    return {
      outer: {
        x: e.left,
        y: e.top,
        w: i,
        h: s,
        radius: a
      },
      inner: {
        x: e.left + o.l,
        y: e.top + o.t,
        w: i - o.l - o.r,
        h: s - o.t - o.b,
        radius: {
          topLeft: Math.max(0, a.topLeft - Math.max(o.t, o.l)),
          topRight: Math.max(0, a.topRight - Math.max(o.t, o.r)),
          bottomLeft: Math.max(0, a.bottomLeft - Math.max(o.b, o.l)),
          bottomRight: Math.max(0, a.bottomRight - Math.max(o.b, o.r))
        }
      }
    }
  }

  function ao(t, e, i, s) {
    const n = null === e,
      o = null === i,
      a = t && !(n && o) && so(t, s);
    return a && (n || Q(e, a.left, a.right)) && (o || Q(i, a.top, a.bottom))
  }

  function ro(t, e) {
    t.rect(e.x, e.y, e.w, e.h)
  }

  function lo(t, e, i = {}) {
    const s = t.x !== i.x ? -e : 0,
      n = t.y !== i.y ? -e : 0,
      o = (t.x + t.w !== i.x + i.w ? e : 0) - s,
      a = (t.y + t.h !== i.y + i.h ? e : 0) - n;
    return {
      x: t.x + s,
      y: t.y + n,
      w: t.w + o,
      h: t.h + a,
      radius: t.radius
    }
  }
  io.id = "point", io.defaults = {
    borderWidth: 1,
    hitRadius: 1,
    hoverBorderWidth: 1,
    hoverRadius: 4,
    pointStyle: "circle",
    radius: 3,
    rotation: 0
  }, io.defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  class ho extends Es {
    constructor(t) {
      super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, t && Object.assign(this, t)
    }
    draw(t) {
      const {
        inflateAmount: e,
        options: {
          borderColor: i,
          backgroundColor: s
        }
      } = this, {
        inner: n,
        outer: o
      } = oo(this), a = (r = o.radius).topLeft || r.topRight || r.bottomLeft || r.bottomRight ? Le : ro;
      var r;
      t.save(), o.w === n.w && o.h === n.h || (t.beginPath(), a(t, lo(o, e, n)), t.clip(), a(t, lo(n, -e, o)), t.fillStyle = i, t.fill("evenodd")), t.beginPath(), a(t, lo(n, e)), t.fillStyle = s, t.fill(), t.restore()
    }
    inRange(t, e, i) {
      return ao(this, t, e, i)
    }
    inXRange(t, e) {
      return ao(this, t, null, e)
    }
    inYRange(t, e) {
      return ao(this, null, t, e)
    }
    getCenterPoint(t) {
      const {
        x: e,
        y: i,
        base: s,
        horizontal: n
      } = this.getProps(["x", "y", "base", "horizontal"], t);
      return {
        x: n ? (e + s) / 2 : e,
        y: n ? i : (i + s) / 2
      }
    }
    getRange(t) {
      return "x" === t ? this.width / 2 : this.height / 2
    }
  }
  ho.id = "bar", ho.defaults = {
    borderSkipped: "start",
    borderWidth: 0,
    borderRadius: 0,
    inflateAmount: "auto",
    pointStyle: void 0
  }, ho.defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  var co = Object.freeze({
    __proto__: null,
    ArcElement: Yn,
    LineElement: to,
    PointElement: io,
    BarElement: ho
  });

  function uo(t) {
    if (t._decimated) {
      const e = t._data;
      delete t._decimated, delete t._data, Object.defineProperty(t, "data", {
        value: e
      })
    }
  }

  function fo(t) {
    t.data.datasets.forEach((t => {
      uo(t)
    }))
  }
  var go = {
    id: "decimation",
    defaults: {
      algorithm: "min-max",
      enabled: !1
    },
    beforeElementsUpdate: (t, e, s) => {
      if (!s.enabled) return void fo(t);
      const n = t.width;
      t.data.datasets.forEach(((e, o) => {
        const {
          _data: a,
          indexAxis: r
        } = e, l = t.getDatasetMeta(o), h = a || e.data;
        if ("y" === bi([r, t.options.indexAxis])) return;
        if (!l.controller.supportsDecimation) return;
        const c = t.scales[l.xAxisID];
        if ("linear" !== c.type && "time" !== c.type) return;
        if (t.options.parsing) return;
        let {
          start: d,
          count: u
        } = function (t, e) {
          const i = e.length;
          let s, n = 0;
          const {
            iScale: o
          } = t, {
            min: a,
            max: r,
            minDefined: l,
            maxDefined: h
          } = o.getUserBounds();
          return l && (n = Z(et(e, o.axis, a).lo, 0, i - 1)), s = h ? Z(et(e, o.axis, r).hi + 1, n, i) - n : i - n, {
            start: n,
            count: s
          }
        }(l, h);
        if (u <= (s.threshold || 4 * n)) return void uo(e);
        let f;
        switch (i(a) && (e._data = h, delete e.data, Object.defineProperty(e, "data", {
          configurable: !0,
          enumerable: !0,
          get: function () {
            return this._decimated
          },
          set: function (t) {
            this._data = t
          }
        })), s.algorithm) {
          case "lttb":
            f = function (t, e, i, s, n) {
              const o = n.samples || s;
              if (o >= i) return t.slice(e, e + i);
              const a = [],
                r = (i - 2) / (o - 2);
              let l = 0;
              const h = e + i - 1;
              let c, d, u, f, g, p = e;
              for (a[l++] = t[p], c = 0; c < o - 2; c++) {
                let s, n = 0,
                  o = 0;
                const h = Math.floor((c + 1) * r) + 1 + e,
                  m = Math.min(Math.floor((c + 2) * r) + 1, i) + e,
                  b = m - h;
                for (s = h; s < m; s++) n += t[s].x, o += t[s].y;
                n /= b, o /= b;
                const x = Math.floor(c * r) + 1 + e,
                  _ = Math.min(Math.floor((c + 1) * r) + 1, i) + e,
                  {
                    x: y,
                    y: v
                  } = t[p];
                for (u = f = -1, s = x; s < _; s++) f = .5 * Math.abs((y - n) * (t[s].y - v) - (y - t[s].x) * (o - v)), f > u && (u = f, d = t[s], g = s);
                a[l++] = d, p = g
              }
              return a[l++] = t[h], a
            }(h, d, u, n, s);
            break;
          case "min-max":
            f = function (t, e, s, n) {
              let o, a, r, l, h, c, d, u, f, g, p = 0,
                m = 0;
              const b = [],
                x = e + s - 1,
                _ = t[e].x,
                y = t[x].x - _;
              for (o = e; o < e + s; ++o) {
                a = t[o], r = (a.x - _) / y * n, l = a.y;
                const e = 0 | r;
                if (e === h) l < f ? (f = l, c = o) : l > g && (g = l, d = o), p = (m * p + a.x) / ++m;
                else {
                  const s = o - 1;
                  if (!i(c) && !i(d)) {
                    const e = Math.min(c, d),
                      i = Math.max(c, d);
                    e !== u && e !== s && b.push({
                      ...t[e],
                      x: p
                    }), i !== u && i !== s && b.push({
                      ...t[i],
                      x: p
                    })
                  }
                  o > 0 && s !== u && b.push(t[s]), b.push(a), h = e, m = 0, f = g = l, c = d = u = o
                }
              }
              return b
            }(h, d, u, n);
            break;
          default:
            throw new Error(`Unsupported decimation algorithm '${s.algorithm}'`)
        }
        e._decimated = f
      }))
    },
    destroy(t) {
      fo(t)
    }
  };

  function po(t, e, i, s) {
    if (s) return;
    let n = e[t],
      o = i[t];
    return "angle" === t && (n = K(n), o = K(o)), {
      property: t,
      start: n,
      end: o
    }
  }

  function mo(t, e, i) {
    for (; e > t; e--) {
      const t = i[e];
      if (!isNaN(t.x) && !isNaN(t.y)) break
    }
    return e
  }

  function bo(t, e, i, s) {
    return t && e ? s(t[i], e[i]) : t ? t[i] : e ? e[i] : 0
  }

  function xo(t, e) {
    let i = [],
      n = !1;
    return s(t) ? (n = !0, i = t) : i = function (t, e) {
      const {
        x: i = null,
        y: s = null
      } = t || {}, n = e.points, o = [];
      return e.segments.forEach((({
        start: t,
        end: e
      }) => {
        e = mo(t, e, n);
        const a = n[t],
          r = n[e];
        null !== s ? (o.push({
          x: a.x,
          y: s
        }), o.push({
          x: r.x,
          y: s
        })) : null !== i && (o.push({
          x: i,
          y: a.y
        }), o.push({
          x: i,
          y: r.y
        }))
      })), o
    }(t, e), i.length ? new to({
      points: i,
      options: {
        tension: 0
      },
      _loop: n,
      _fullLoop: n
    }) : null
  }

  function _o(t) {
    return t && !1 !== t.fill
  }

  function yo(t, e, i) {
    let s = t[e].fill;
    const n = [e];
    let a;
    if (!i) return s;
    for (; !1 !== s && -1 === n.indexOf(s);) {
      if (!o(s)) return s;
      if (a = t[s], !a) return !1;
      if (a.visible) return s;
      n.push(s), s = a.fill
    }
    return !1
  }

  function vo(t, e, i) {
    const s = function (t) {
      const e = t.options,
        i = e.fill;
      let s = r(i && i.target, i);
      void 0 === s && (s = !!e.backgroundColor);
      if (!1 === s || null === s) return !1;
      if (!0 === s) return "origin";
      return s
    }(t);
    if (n(s)) return !isNaN(s.value) && s;
    let a = parseFloat(s);
    return o(a) && Math.floor(a) === a ? function (t, e, i, s) {
      "-" !== t && "+" !== t || (i = e + i);
      if (i === e || i < 0 || i >= s) return !1;
      return i
    }(s[0], e, a, i) : ["origin", "start", "end", "stack", "shape"].indexOf(s) >= 0 && s
  }

  function wo(t, e, i) {
    const s = [];
    for (let n = 0; n < i.length; n++) {
      const o = i[n],
        {
          first: a,
          last: r,
          point: l
        } = Mo(o, e, "x");
      if (!(!l || a && r))
        if (a) s.unshift(l);
        else if (t.push(l), !r) break
    }
    t.push(...s)
  }

  function Mo(t, e, i) {
    const s = t.interpolate(e, i);
    if (!s) return {};
    const n = s[i],
      o = t.segments,
      a = t.points;
    let r = !1,
      l = !1;
    for (let t = 0; t < o.length; t++) {
      const e = o[t],
        s = a[e.start][i],
        h = a[e.end][i];
      if (Q(n, s, h)) {
        r = n === s, l = n === h;
        break
      }
    }
    return {
      first: r,
      last: l,
      point: s
    }
  }
  class ko {
    constructor(t) {
      this.x = t.x, this.y = t.y, this.radius = t.radius
    }
    pathSegment(t, e, i) {
      const {
        x: s,
        y: n,
        radius: o
      } = this;
      return e = e || {
        start: 0,
        end: O
      }, t.arc(s, n, o, e.end, e.start, !0), !i.bounds
    }
    interpolate(t) {
      const {
        x: e,
        y: i,
        radius: s
      } = this, n = t.angle;
      return {
        x: e + Math.cos(n) * s,
        y: i + Math.sin(n) * s,
        angle: n
      }
    }
  }

  function So(t) {
    const {
      chart: e,
      fill: i,
      line: s
    } = t;
    if (o(i)) return function (t, e) {
      const i = t.getDatasetMeta(e);
      return i && t.isDatasetVisible(e) ? i.dataset : null
    }(e, i);
    if ("stack" === i) return function (t) {
      const {
        scale: e,
        index: i,
        line: s
      } = t, n = [], o = s.segments, a = s.points, r = function (t, e) {
        const i = [],
          s = t.getMatchingVisibleMetas("line");
        for (let t = 0; t < s.length; t++) {
          const n = s[t];
          if (n.index === e) break;
          n.hidden || i.unshift(n.dataset)
        }
        return i
      }(e, i);
      r.push(xo({
        x: null,
        y: e.bottom
      }, s));
      for (let t = 0; t < o.length; t++) {
        const e = o[t];
        for (let t = e.start; t <= e.end; t++) wo(n, a[t], r)
      }
      return new to({
        points: n,
        options: {}
      })
    }(t);
    if ("shape" === i) return !0;
    const a = function (t) {
      if ((t.scale || {}).getPointPositionForValue) return function (t) {
        const {
          scale: e,
          fill: i
        } = t, s = e.options, o = e.getLabels().length, a = s.reverse ? e.max : e.min, r = function (t, e, i) {
          let s;
          return s = "start" === t ? i : "end" === t ? e.options.reverse ? e.min : e.max : n(t) ? t.value : e.getBaseValue(), s
        }(i, e, a), l = [];
        if (s.grid.circular) {
          const t = e.getPointPositionForValue(0, a);
          return new ko({
            x: t.x,
            y: t.y,
            radius: e.getDistanceFromCenterForValue(r)
          })
        }
        for (let t = 0; t < o; ++t) l.push(e.getPointPositionForValue(t, r));
        return l
      }(t);
      return function (t) {
        const {
          scale: e = {},
          fill: i
        } = t, s = function (t, e) {
          let i = null;
          return "start" === t ? i = e.bottom : "end" === t ? i = e.top : n(t) ? i = e.getPixelForValue(t.value) : e.getBasePixel && (i = e.getBasePixel()), i
        }(i, e);
        if (o(s)) {
          const t = e.isHorizontal();
          return {
            x: t ? s : null,
            y: t ? null : s
          }
        }
        return null
      }(t)
    }(t);
    return a instanceof ko ? a : xo(a, s)
  }

  function Po(t, e, i) {
    const s = So(e),
      {
        line: n,
        scale: o,
        axis: a
      } = e,
      r = n.options,
      l = r.fill,
      h = r.backgroundColor,
      {
        above: c = h,
        below: d = h
      } = l || {};
    s && n.points.length && (Pe(t, i), function (t, e) {
      const {
        line: i,
        target: s,
        above: n,
        below: o,
        area: a,
        scale: r
      } = e, l = i._loop ? "angle" : e.axis;
      t.save(), "x" === l && o !== n && (Do(t, s, a.top), Oo(t, {
        line: i,
        target: s,
        color: n,
        scale: r,
        property: l
      }), t.restore(), t.save(), Do(t, s, a.bottom));
      Oo(t, {
        line: i,
        target: s,
        color: o,
        scale: r,
        property: l
      }), t.restore()
    }(t, {
      line: n,
      target: s,
      above: c,
      below: d,
      area: i,
      scale: o,
      axis: a
    }), De(t))
  }

  function Do(t, e, i) {
    const {
      segments: s,
      points: n
    } = e;
    let o = !0,
      a = !1;
    t.beginPath();
    for (const r of s) {
      const {
        start: s,
        end: l
      } = r, h = n[s], c = n[mo(s, l, n)];
      o ? (t.moveTo(h.x, h.y), o = !1) : (t.lineTo(h.x, i), t.lineTo(h.x, h.y)), a = !!e.pathSegment(t, r, {
        move: a
      }), a ? t.closePath() : t.lineTo(c.x, i)
    }
    t.lineTo(e.first().x, i), t.closePath(), t.clip()
  }

  function Oo(t, e) {
    const {
      line: i,
      target: s,
      property: n,
      color: o,
      scale: a
    } = e, r = function (t, e, i) {
      const s = t.segments,
        n = t.points,
        o = e.points,
        a = [];
      for (const t of s) {
        let {
          start: s,
          end: r
        } = t;
        r = mo(s, r, n);
        const l = po(i, n[s], n[r], t.loop);
        if (!e.segments) {
          a.push({
            source: t,
            target: l,
            start: n[s],
            end: n[r]
          });
          continue
        }
        const h = Pi(e, l);
        for (const e of h) {
          const s = po(i, o[e.start], o[e.end], e.loop),
            r = Si(t, n, s);
          for (const t of r) a.push({
            source: t,
            target: e,
            start: {
              [i]: bo(l, s, "start", Math.max)
            },
            end: {
              [i]: bo(l, s, "end", Math.min)
            }
          })
        }
      }
      return a
    }(i, s, n);
    for (const {
        source: e,
        target: l,
        start: h,
        end: c
      } of r) {
      const {
        style: {
          backgroundColor: r = o
        } = {}
      } = e, d = !0 !== s;
      t.save(), t.fillStyle = r, Co(t, a, d && po(n, h, c)), t.beginPath();
      const u = !!i.pathSegment(t, e);
      let f;
      if (d) {
        u ? t.closePath() : Ao(t, s, c, n);
        const e = !!s.pathSegment(t, l, {
          move: u,
          reverse: !0
        });
        f = u && e, f || Ao(t, s, h, n)
      }
      t.closePath(), t.fill(f ? "evenodd" : "nonzero"), t.restore()
    }
  }

  function Co(t, e, i) {
    const {
      top: s,
      bottom: n
    } = e.chart.chartArea, {
      property: o,
      start: a,
      end: r
    } = i || {};
    "x" === o && (t.beginPath(), t.rect(a, s, r - a, n - s), t.clip())
  }

  function Ao(t, e, i, s) {
    const n = e.interpolate(i, s);
    n && t.lineTo(n.x, n.y)
  }
  var To = {
    id: "filler",
    afterDatasetsUpdate(t, e, i) {
      const s = (t.data.datasets || []).length,
        n = [];
      let o, a, r, l;
      for (a = 0; a < s; ++a) o = t.getDatasetMeta(a), r = o.dataset, l = null, r && r.options && r instanceof to && (l = {
        visible: t.isDatasetVisible(a),
        index: a,
        fill: vo(r, a, s),
        chart: t,
        axis: o.controller.options.indexAxis,
        scale: o.vScale,
        line: r
      }), o.$filler = l, n.push(l);
      for (a = 0; a < s; ++a) l = n[a], l && !1 !== l.fill && (l.fill = yo(n, a, i.propagate))
    },
    beforeDraw(t, e, i) {
      const s = "beforeDraw" === i.drawTime,
        n = t.getSortedVisibleDatasetMetas(),
        o = t.chartArea;
      for (let e = n.length - 1; e >= 0; --e) {
        const i = n[e].$filler;
        i && (i.line.updateControlPoints(o, i.axis), s && i.fill && Po(t.ctx, i, o))
      }
    },
    beforeDatasetsDraw(t, e, i) {
      if ("beforeDatasetsDraw" !== i.drawTime) return;
      const s = t.getSortedVisibleDatasetMetas();
      for (let e = s.length - 1; e >= 0; --e) {
        const i = s[e].$filler;
        _o(i) && Po(t.ctx, i, t.chartArea)
      }
    },
    beforeDatasetDraw(t, e, i) {
      const s = e.meta.$filler;
      _o(s) && "beforeDatasetDraw" === i.drawTime && Po(t.ctx, s, t.chartArea)
    },
    defaults: {
      propagate: !0,
      drawTime: "beforeDatasetDraw"
    }
  };
  const Lo = (t, e) => {
    let {
      boxHeight: i = e,
      boxWidth: s = e
    } = t;
    return t.usePointStyle && (i = Math.min(i, e), s = t.pointStyleWidth || Math.min(s, e)), {
      boxWidth: s,
      boxHeight: i,
      itemHeight: Math.max(e, i)
    }
  };
  class Eo extends Es {
    constructor(t) {
      super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0
    }
    update(t, e, i) {
      this.maxWidth = t, this.maxHeight = e, this._margins = i, this.setDimensions(), this.buildLabels(), this.fit()
    }
    setDimensions() {
      this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height)
    }
    buildLabels() {
      const t = this.options.labels || {};
      let e = c(t.generateLabels, [this.chart], this) || [];
      t.filter && (e = e.filter((e => t.filter(e, this.chart.data)))), t.sort && (e = e.sort(((e, i) => t.sort(e, i, this.chart.data)))), this.options.reverse && e.reverse(), this.legendItems = e
    }
    fit() {
      const {
        options: t,
        ctx: e
      } = this;
      if (!t.display) return void(this.width = this.height = 0);
      const i = t.labels,
        s = mi(i.font),
        n = s.size,
        o = this._computeTitleHeight(),
        {
          boxWidth: a,
          itemHeight: r
        } = Lo(i, n);
      let l, h;
      e.font = s.string, this.isHorizontal() ? (l = this.maxWidth, h = this._fitRows(o, n, a, r) + 10) : (h = this.maxHeight, l = this._fitCols(o, n, a, r) + 10), this.width = Math.min(l, t.maxWidth || this.maxWidth), this.height = Math.min(h, t.maxHeight || this.maxHeight)
    }
    _fitRows(t, e, i, s) {
      const {
        ctx: n,
        maxWidth: o,
        options: {
          labels: {
            padding: a
          }
        }
      } = this, r = this.legendHitBoxes = [], l = this.lineWidths = [0], h = s + a;
      let c = t;
      n.textAlign = "left", n.textBaseline = "middle";
      let d = -1,
        u = -h;
      return this.legendItems.forEach(((t, f) => {
        const g = i + e / 2 + n.measureText(t.text).width;
        (0 === f || l[l.length - 1] + g + 2 * a > o) && (c += h, l[l.length - (f > 0 ? 0 : 1)] = 0, u += h, d++), r[f] = {
          left: 0,
          top: u,
          row: d,
          width: g,
          height: s
        }, l[l.length - 1] += g + a
      })), c
    }
    _fitCols(t, e, i, s) {
      const {
        ctx: n,
        maxHeight: o,
        options: {
          labels: {
            padding: a
          }
        }
      } = this, r = this.legendHitBoxes = [], l = this.columnSizes = [], h = o - t;
      let c = a,
        d = 0,
        u = 0,
        f = 0,
        g = 0;
      return this.legendItems.forEach(((t, o) => {
        const p = i + e / 2 + n.measureText(t.text).width;
        o > 0 && u + s + 2 * a > h && (c += d + a, l.push({
          width: d,
          height: u
        }), f += d + a, g++, d = u = 0), r[o] = {
          left: f,
          top: u,
          col: g,
          width: p,
          height: s
        }, d = Math.max(d, p), u += s + a
      })), c += d, l.push({
        width: d,
        height: u
      }), c
    }
    adjustHitBoxes() {
      if (!this.options.display) return;
      const t = this._computeTitleHeight(),
        {
          legendHitBoxes: e,
          options: {
            align: i,
            labels: {
              padding: s
            },
            rtl: n
          }
        } = this,
        o = yi(n, this.left, this.width);
      if (this.isHorizontal()) {
        let n = 0,
          a = ut(i, this.left + s, this.right - this.lineWidths[n]);
        for (const r of e) n !== r.row && (n = r.row, a = ut(i, this.left + s, this.right - this.lineWidths[n])), r.top += this.top + t + s, r.left = o.leftForLtr(o.x(a), r.width), a += r.width + s
      } else {
        let n = 0,
          a = ut(i, this.top + t + s, this.bottom - this.columnSizes[n].height);
        for (const r of e) r.col !== n && (n = r.col, a = ut(i, this.top + t + s, this.bottom - this.columnSizes[n].height)), r.top = a, r.left += this.left + s, r.left = o.leftForLtr(o.x(r.left), r.width), a += r.height + s
      }
    }
    isHorizontal() {
      return "top" === this.options.position || "bottom" === this.options.position
    }
    draw() {
      if (this.options.display) {
        const t = this.ctx;
        Pe(t, this), this._draw(), De(t)
      }
    }
    _draw() {
      const {
        options: t,
        columnSizes: e,
        lineWidths: i,
        ctx: s
      } = this, {
        align: n,
        labels: o
      } = t, a = ne.color, l = yi(t.rtl, this.left, this.width), h = mi(o.font), {
        color: c,
        padding: d
      } = o, u = h.size, f = u / 2;
      let g;
      this.drawTitle(), s.textAlign = l.textAlign("left"), s.textBaseline = "middle", s.lineWidth = .5, s.font = h.string;
      const {
        boxWidth: p,
        boxHeight: m,
        itemHeight: b
      } = Lo(o, u), x = this.isHorizontal(), _ = this._computeTitleHeight();
      g = x ? {
        x: ut(n, this.left + d, this.right - i[0]),
        y: this.top + d + _,
        line: 0
      } : {
        x: this.left + d,
        y: ut(n, this.top + _ + d, this.bottom - e[0].height),
        line: 0
      }, vi(this.ctx, t.textDirection);
      const y = b + d;
      this.legendItems.forEach(((v, w) => {
        s.strokeStyle = v.fontColor || c, s.fillStyle = v.fontColor || c;
        const M = s.measureText(v.text).width,
          k = l.textAlign(v.textAlign || (v.textAlign = o.textAlign)),
          S = p + f + M;
        let P = g.x,
          D = g.y;
        l.setWidth(this.width), x ? w > 0 && P + S + d > this.right && (D = g.y += y, g.line++, P = g.x = ut(n, this.left + d, this.right - i[g.line])) : w > 0 && D + y > this.bottom && (P = g.x = P + e[g.line].width + d, g.line++, D = g.y = ut(n, this.top + _ + d, this.bottom - e[g.line].height));
        ! function (t, e, i) {
          if (isNaN(p) || p <= 0 || isNaN(m) || m < 0) return;
          s.save();
          const n = r(i.lineWidth, 1);
          if (s.fillStyle = r(i.fillStyle, a), s.lineCap = r(i.lineCap, "butt"), s.lineDashOffset = r(i.lineDashOffset, 0), s.lineJoin = r(i.lineJoin, "miter"), s.lineWidth = n, s.strokeStyle = r(i.strokeStyle, a), s.setLineDash(r(i.lineDash, [])), o.usePointStyle) {
            const a = {
                radius: m * Math.SQRT2 / 2,
                pointStyle: i.pointStyle,
                rotation: i.rotation,
                borderWidth: n
              },
              r = l.xPlus(t, p / 2);
            ke(s, a, r, e + f, o.pointStyleWidth && p)
          } else {
            const o = e + Math.max((u - m) / 2, 0),
              a = l.leftForLtr(t, p),
              r = gi(i.borderRadius);
            s.beginPath(), Object.values(r).some((t => 0 !== t)) ? Le(s, {
              x: a,
              y: o,
              w: p,
              h: m,
              radius: r
            }) : s.rect(a, o, p, m), s.fill(), 0 !== n && s.stroke()
          }
          s.restore()
        }(l.x(P), D, v), P = ft(k, P + p + f, x ? P + S : this.right, t.rtl),
          function (t, e, i) {
            Ae(s, i.text, t, e + b / 2, h, {
              strikethrough: i.hidden,
              textAlign: l.textAlign(i.textAlign)
            })
          }(l.x(P), D, v), x ? g.x += S + d : g.y += y
      })), wi(this.ctx, t.textDirection)
    }
    drawTitle() {
      const t = this.options,
        e = t.title,
        i = mi(e.font),
        s = pi(e.padding);
      if (!e.display) return;
      const n = yi(t.rtl, this.left, this.width),
        o = this.ctx,
        a = e.position,
        r = i.size / 2,
        l = s.top + r;
      let h, c = this.left,
        d = this.width;
      if (this.isHorizontal()) d = Math.max(...this.lineWidths), h = this.top + l, c = ut(t.align, c, this.right - d);
      else {
        const e = this.columnSizes.reduce(((t, e) => Math.max(t, e.height)), 0);
        h = l + ut(t.align, this.top, this.bottom - e - t.labels.padding - this._computeTitleHeight())
      }
      const u = ut(a, c, c + d);
      o.textAlign = n.textAlign(dt(a)), o.textBaseline = "middle", o.strokeStyle = e.color, o.fillStyle = e.color, o.font = i.string, Ae(o, e.text, u, h, i)
    }
    _computeTitleHeight() {
      const t = this.options.title,
        e = mi(t.font),
        i = pi(t.padding);
      return t.display ? e.lineHeight + i.height : 0
    }
    _getLegendItemAt(t, e) {
      let i, s, n;
      if (Q(t, this.left, this.right) && Q(e, this.top, this.bottom))
        for (n = this.legendHitBoxes, i = 0; i < n.length; ++i)
          if (s = n[i], Q(t, s.left, s.left + s.width) && Q(e, s.top, s.top + s.height)) return this.legendItems[i];
      return null
    }
    handleEvent(t) {
      const e = this.options;
      if (! function (t, e) {
          if (("mousemove" === t || "mouseout" === t) && (e.onHover || e.onLeave)) return !0;
          if (e.onClick && ("click" === t || "mouseup" === t)) return !0;
          return !1
        }(t.type, e)) return;
      const i = this._getLegendItemAt(t.x, t.y);
      if ("mousemove" === t.type || "mouseout" === t.type) {
        const o = this._hoveredItem,
          a = (n = i, null !== (s = o) && null !== n && s.datasetIndex === n.datasetIndex && s.index === n.index);
        o && !a && c(e.onLeave, [t, o, this], this), this._hoveredItem = i, i && !a && c(e.onHover, [t, i, this], this)
      } else i && c(e.onClick, [t, i, this], this);
      var s, n
    }
  }
  var Ro = {
    id: "legend",
    _element: Eo,
    start(t, e, i) {
      const s = t.legend = new Eo({
        ctx: t.ctx,
        options: i,
        chart: t
      });
      Zi.configure(t, s, i), Zi.addBox(t, s)
    },
    stop(t) {
      Zi.removeBox(t, t.legend), delete t.legend
    },
    beforeUpdate(t, e, i) {
      const s = t.legend;
      Zi.configure(t, s, i), s.options = i
    },
    afterUpdate(t) {
      const e = t.legend;
      e.buildLabels(), e.adjustHitBoxes()
    },
    afterEvent(t, e) {
      e.replay || t.legend.handleEvent(e.event)
    },
    defaults: {
      display: !0,
      position: "top",
      align: "center",
      fullSize: !0,
      reverse: !1,
      weight: 1e3,
      onClick(t, e, i) {
        const s = e.datasetIndex,
          n = i.chart;
        n.isDatasetVisible(s) ? (n.hide(s), e.hidden = !0) : (n.show(s), e.hidden = !1)
      },
      onHover: null,
      onLeave: null,
      labels: {
        color: t => t.chart.options.color,
        boxWidth: 40,
        padding: 10,
        generateLabels(t) {
          const e = t.data.datasets,
            {
              labels: {
                usePointStyle: i,
                pointStyle: s,
                textAlign: n,
                color: o
              }
            } = t.legend.options;
          return t._getSortedDatasetMetas().map((t => {
            const a = t.controller.getStyle(i ? 0 : void 0),
              r = pi(a.borderWidth);
            return {
              text: e[t.index].label,
              fillStyle: a.backgroundColor,
              fontColor: o,
              hidden: !t.visible,
              lineCap: a.borderCapStyle,
              lineDash: a.borderDash,
              lineDashOffset: a.borderDashOffset,
              lineJoin: a.borderJoinStyle,
              lineWidth: (r.width + r.height) / 4,
              strokeStyle: a.borderColor,
              pointStyle: s || a.pointStyle,
              rotation: a.rotation,
              textAlign: n || a.textAlign,
              borderRadius: 0,
              datasetIndex: t.index
            }
          }), this)
        }
      },
      title: {
        color: t => t.chart.options.color,
        display: !1,
        position: "center",
        text: ""
      }
    },
    descriptors: {
      _scriptable: t => !t.startsWith("on"),
      labels: {
        _scriptable: t => !["generateLabels", "filter", "sort"].includes(t)
      }
    }
  };
  class Io extends Es {
    constructor(t) {
      super(), this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0
    }
    update(t, e) {
      const i = this.options;
      if (this.left = 0, this.top = 0, !i.display) return void(this.width = this.height = this.right = this.bottom = 0);
      this.width = this.right = t, this.height = this.bottom = e;
      const n = s(i.text) ? i.text.length : 1;
      this._padding = pi(i.padding);
      const o = n * mi(i.font).lineHeight + this._padding.height;
      this.isHorizontal() ? this.height = o : this.width = o
    }
    isHorizontal() {
      const t = this.options.position;
      return "top" === t || "bottom" === t
    }
    _drawArgs(t) {
      const {
        top: e,
        left: i,
        bottom: s,
        right: n,
        options: o
      } = this, a = o.align;
      let r, l, h, c = 0;
      return this.isHorizontal() ? (l = ut(a, i, n), h = e + t, r = n - i) : ("left" === o.position ? (l = i + t, h = ut(a, s, e), c = -.5 * D) : (l = n - t, h = ut(a, e, s), c = .5 * D), r = s - e), {
        titleX: l,
        titleY: h,
        maxWidth: r,
        rotation: c
      }
    }
    draw() {
      const t = this.ctx,
        e = this.options;
      if (!e.display) return;
      const i = mi(e.font),
        s = i.lineHeight / 2 + this._padding.top,
        {
          titleX: n,
          titleY: o,
          maxWidth: a,
          rotation: r
        } = this._drawArgs(s);
      Ae(t, e.text, 0, 0, i, {
        color: e.color,
        maxWidth: a,
        rotation: r,
        textAlign: dt(e.align),
        textBaseline: "middle",
        translation: [n, o]
      })
    }
  }
  var zo = {
    id: "title",
    _element: Io,
    start(t, e, i) {
      ! function (t, e) {
        const i = new Io({
          ctx: t.ctx,
          options: e,
          chart: t
        });
        Zi.configure(t, i, e), Zi.addBox(t, i), t.titleBlock = i
      }(t, i)
    },
    stop(t) {
      const e = t.titleBlock;
      Zi.removeBox(t, e), delete t.titleBlock
    },
    beforeUpdate(t, e, i) {
      const s = t.titleBlock;
      Zi.configure(t, s, i), s.options = i
    },
    defaults: {
      align: "center",
      display: !1,
      font: {
        weight: "bold"
      },
      fullSize: !0,
      padding: 10,
      position: "top",
      text: "",
      weight: 2e3
    },
    defaultRoutes: {
      color: "color"
    },
    descriptors: {
      _scriptable: !0,
      _indexable: !1
    }
  };
  const Fo = new WeakMap;
  var Vo = {
    id: "subtitle",
    start(t, e, i) {
      const s = new Io({
        ctx: t.ctx,
        options: i,
        chart: t
      });
      Zi.configure(t, s, i), Zi.addBox(t, s), Fo.set(t, s)
    },
    stop(t) {
      Zi.removeBox(t, Fo.get(t)), Fo.delete(t)
    },
    beforeUpdate(t, e, i) {
      const s = Fo.get(t);
      Zi.configure(t, s, i), s.options = i
    },
    defaults: {
      align: "center",
      display: !1,
      font: {
        weight: "normal"
      },
      fullSize: !0,
      padding: 0,
      position: "top",
      text: "",
      weight: 1500
    },
    defaultRoutes: {
      color: "color"
    },
    descriptors: {
      _scriptable: !0,
      _indexable: !1
    }
  };
  const Bo = {
    average(t) {
      if (!t.length) return !1;
      let e, i, s = 0,
        n = 0,
        o = 0;
      for (e = 0, i = t.length; e < i; ++e) {
        const i = t[e].element;
        if (i && i.hasValue()) {
          const t = i.tooltipPosition();
          s += t.x, n += t.y, ++o
        }
      }
      return {
        x: s / o,
        y: n / o
      }
    },
    nearest(t, e) {
      if (!t.length) return !1;
      let i, s, n, o = e.x,
        a = e.y,
        r = Number.POSITIVE_INFINITY;
      for (i = 0, s = t.length; i < s; ++i) {
        const s = t[i].element;
        if (s && s.hasValue()) {
          const t = X(e, s.getCenterPoint());
          t < r && (r = t, n = s)
        }
      }
      if (n) {
        const t = n.tooltipPosition();
        o = t.x, a = t.y
      }
      return {
        x: o,
        y: a
      }
    }
  };

  function No(t, e) {
    return e && (s(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t
  }

  function Wo(t) {
    return ("string" == typeof t || t instanceof String) && t.indexOf("\n") > -1 ? t.split("\n") : t
  }

  function jo(t, e) {
    const {
      element: i,
      datasetIndex: s,
      index: n
    } = e, o = t.getDatasetMeta(s).controller, {
      label: a,
      value: r
    } = o.getLabelAndValue(n);
    return {
      chart: t,
      label: a,
      parsed: o.getParsed(n),
      raw: t.data.datasets[s].data[n],
      formattedValue: r,
      dataset: o.getDataset(),
      dataIndex: n,
      datasetIndex: s,
      element: i
    }
  }

  function Ho(t, e) {
    const i = t.chart.ctx,
      {
        body: s,
        footer: n,
        title: o
      } = t,
      {
        boxWidth: a,
        boxHeight: r
      } = e,
      l = mi(e.bodyFont),
      h = mi(e.titleFont),
      c = mi(e.footerFont),
      u = o.length,
      f = n.length,
      g = s.length,
      p = pi(e.padding);
    let m = p.height,
      b = 0,
      x = s.reduce(((t, e) => t + e.before.length + e.lines.length + e.after.length), 0);
    if (x += t.beforeBody.length + t.afterBody.length, u && (m += u * h.lineHeight + (u - 1) * e.titleSpacing + e.titleMarginBottom), x) {
      m += g * (e.displayColors ? Math.max(r, l.lineHeight) : l.lineHeight) + (x - g) * l.lineHeight + (x - 1) * e.bodySpacing
    }
    f && (m += e.footerMarginTop + f * c.lineHeight + (f - 1) * e.footerSpacing);
    let _ = 0;
    const y = function (t) {
      b = Math.max(b, i.measureText(t).width + _)
    };
    return i.save(), i.font = h.string, d(t.title, y), i.font = l.string, d(t.beforeBody.concat(t.afterBody), y), _ = e.displayColors ? a + 2 + e.boxPadding : 0, d(s, (t => {
      d(t.before, y), d(t.lines, y), d(t.after, y)
    })), _ = 0, i.font = c.string, d(t.footer, y), i.restore(), b += p.width, {
      width: b,
      height: m
    }
  }

  function $o(t, e, i, s) {
    const {
      x: n,
      width: o
    } = i, {
      width: a,
      chartArea: {
        left: r,
        right: l
      }
    } = t;
    let h = "center";
    return "center" === s ? h = n <= (r + l) / 2 ? "left" : "right" : n <= o / 2 ? h = "left" : n >= a - o / 2 && (h = "right"),
      function (t, e, i, s) {
        const {
          x: n,
          width: o
        } = s, a = i.caretSize + i.caretPadding;
        return "left" === t && n + o + a > e.width || "right" === t && n - o - a < 0 || void 0
      }(h, t, e, i) && (h = "center"), h
  }

  function Yo(t, e, i) {
    const s = i.yAlign || e.yAlign || function (t, e) {
      const {
        y: i,
        height: s
      } = e;
      return i < s / 2 ? "top" : i > t.height - s / 2 ? "bottom" : "center"
    }(t, i);
    return {
      xAlign: i.xAlign || e.xAlign || $o(t, e, i, s),
      yAlign: s
    }
  }

  function Uo(t, e, i, s) {
    const {
      caretSize: n,
      caretPadding: o,
      cornerRadius: a
    } = t, {
      xAlign: r,
      yAlign: l
    } = i, h = n + o, {
      topLeft: c,
      topRight: d,
      bottomLeft: u,
      bottomRight: f
    } = gi(a);
    let g = function (t, e) {
      let {
        x: i,
        width: s
      } = t;
      return "right" === e ? i -= s : "center" === e && (i -= s / 2), i
    }(e, r);
    const p = function (t, e, i) {
      let {
        y: s,
        height: n
      } = t;
      return "top" === e ? s += i : s -= "bottom" === e ? n + i : n / 2, s
    }(e, l, h);
    return "center" === l ? "left" === r ? g += h : "right" === r && (g -= h) : "left" === r ? g -= Math.max(c, u) + n : "right" === r && (g += Math.max(d, f) + n), {
      x: Z(g, 0, s.width - e.width),
      y: Z(p, 0, s.height - e.height)
    }
  }

  function Xo(t, e, i) {
    const s = pi(i.padding);
    return "center" === e ? t.x + t.width / 2 : "right" === e ? t.x + t.width - s.right : t.x + s.left
  }

  function qo(t) {
    return No([], Wo(t))
  }

  function Ko(t, e) {
    const i = e && e.dataset && e.dataset.tooltip && e.dataset.tooltip.callbacks;
    return i ? t.override(i) : t
  }
  class Go extends Es {
    constructor(t) {
      super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = t.chart || t._chart, this._chart = this.chart, this.options = t.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0
    }
    initialize(t) {
      this.options = t, this._cachedAnimations = void 0, this.$context = void 0
    }
    _resolveAnimations() {
      const t = this._cachedAnimations;
      if (t) return t;
      const e = this.chart,
        i = this.options.setContext(this.getContext()),
        s = i.enabled && e.options.animation && i.animations,
        n = new ys(this.chart, s);
      return s._cacheable && (this._cachedAnimations = Object.freeze(n)), n
    }
    getContext() {
      return this.$context || (this.$context = (t = this.chart.getContext(), e = this, i = this._tooltipItems, _i(t, {
        tooltip: e,
        tooltipItems: i,
        type: "tooltip"
      })));
      var t, e, i
    }
    getTitle(t, e) {
      const {
        callbacks: i
      } = e, s = i.beforeTitle.apply(this, [t]), n = i.title.apply(this, [t]), o = i.afterTitle.apply(this, [t]);
      let a = [];
      return a = No(a, Wo(s)), a = No(a, Wo(n)), a = No(a, Wo(o)), a
    }
    getBeforeBody(t, e) {
      return qo(e.callbacks.beforeBody.apply(this, [t]))
    }
    getBody(t, e) {
      const {
        callbacks: i
      } = e, s = [];
      return d(t, (t => {
        const e = {
            before: [],
            lines: [],
            after: []
          },
          n = Ko(i, t);
        No(e.before, Wo(n.beforeLabel.call(this, t))), No(e.lines, n.label.call(this, t)), No(e.after, Wo(n.afterLabel.call(this, t))), s.push(e)
      })), s
    }
    getAfterBody(t, e) {
      return qo(e.callbacks.afterBody.apply(this, [t]))
    }
    getFooter(t, e) {
      const {
        callbacks: i
      } = e, s = i.beforeFooter.apply(this, [t]), n = i.footer.apply(this, [t]), o = i.afterFooter.apply(this, [t]);
      let a = [];
      return a = No(a, Wo(s)), a = No(a, Wo(n)), a = No(a, Wo(o)), a
    }
    _createItems(t) {
      const e = this._active,
        i = this.chart.data,
        s = [],
        n = [],
        o = [];
      let a, r, l = [];
      for (a = 0, r = e.length; a < r; ++a) l.push(jo(this.chart, e[a]));
      return t.filter && (l = l.filter(((e, s, n) => t.filter(e, s, n, i)))), t.itemSort && (l = l.sort(((e, s) => t.itemSort(e, s, i)))), d(l, (e => {
        const i = Ko(t.callbacks, e);
        s.push(i.labelColor.call(this, e)), n.push(i.labelPointStyle.call(this, e)), o.push(i.labelTextColor.call(this, e))
      })), this.labelColors = s, this.labelPointStyles = n, this.labelTextColors = o, this.dataPoints = l, l
    }
    update(t, e) {
      const i = this.options.setContext(this.getContext()),
        s = this._active;
      let n, o = [];
      if (s.length) {
        const t = Bo[i.position].call(this, s, this._eventPosition);
        o = this._createItems(i), this.title = this.getTitle(o, i), this.beforeBody = this.getBeforeBody(o, i), this.body = this.getBody(o, i), this.afterBody = this.getAfterBody(o, i), this.footer = this.getFooter(o, i);
        const e = this._size = Ho(this, i),
          a = Object.assign({}, t, e),
          r = Yo(this.chart, i, a),
          l = Uo(i, a, r, this.chart);
        this.xAlign = r.xAlign, this.yAlign = r.yAlign, n = {
          opacity: 1,
          x: l.x,
          y: l.y,
          width: e.width,
          height: e.height,
          caretX: t.x,
          caretY: t.y
        }
      } else 0 !== this.opacity && (n = {
        opacity: 0
      });
      this._tooltipItems = o, this.$context = void 0, n && this._resolveAnimations().update(this, n), t && i.external && i.external.call(this, {
        chart: this.chart,
        tooltip: this,
        replay: e
      })
    }
    drawCaret(t, e, i, s) {
      const n = this.getCaretPosition(t, i, s);
      e.lineTo(n.x1, n.y1), e.lineTo(n.x2, n.y2), e.lineTo(n.x3, n.y3)
    }
    getCaretPosition(t, e, i) {
      const {
        xAlign: s,
        yAlign: n
      } = this, {
        caretSize: o,
        cornerRadius: a
      } = i, {
        topLeft: r,
        topRight: l,
        bottomLeft: h,
        bottomRight: c
      } = gi(a), {
        x: d,
        y: u
      } = t, {
        width: f,
        height: g
      } = e;
      let p, m, b, x, _, y;
      return "center" === n ? (_ = u + g / 2, "left" === s ? (p = d, m = p - o, x = _ + o, y = _ - o) : (p = d + f, m = p + o, x = _ - o, y = _ + o), b = p) : (m = "left" === s ? d + Math.max(r, h) + o : "right" === s ? d + f - Math.max(l, c) - o : this.caretX, "top" === n ? (x = u, _ = x - o, p = m - o, b = m + o) : (x = u + g, _ = x + o, p = m + o, b = m - o), y = x), {
        x1: p,
        x2: m,
        x3: b,
        y1: x,
        y2: _,
        y3: y
      }
    }
    drawTitle(t, e, i) {
      const s = this.title,
        n = s.length;
      let o, a, r;
      if (n) {
        const l = yi(i.rtl, this.x, this.width);
        for (t.x = Xo(this, i.titleAlign, i), e.textAlign = l.textAlign(i.titleAlign), e.textBaseline = "middle", o = mi(i.titleFont), a = i.titleSpacing, e.fillStyle = i.titleColor, e.font = o.string, r = 0; r < n; ++r) e.fillText(s[r], l.x(t.x), t.y + o.lineHeight / 2), t.y += o.lineHeight + a, r + 1 === n && (t.y += i.titleMarginBottom - a)
      }
    }
    _drawColorBox(t, e, i, s, o) {
      const a = this.labelColors[i],
        r = this.labelPointStyles[i],
        {
          boxHeight: l,
          boxWidth: h,
          boxPadding: c
        } = o,
        d = mi(o.bodyFont),
        u = Xo(this, "left", o),
        f = s.x(u),
        g = l < d.lineHeight ? (d.lineHeight - l) / 2 : 0,
        p = e.y + g;
      if (o.usePointStyle) {
        const e = {
            radius: Math.min(h, l) / 2,
            pointStyle: r.pointStyle,
            rotation: r.rotation,
            borderWidth: 1
          },
          i = s.leftForLtr(f, h) + h / 2,
          n = p + l / 2;
        t.strokeStyle = o.multiKeyBackground, t.fillStyle = o.multiKeyBackground, Me(t, e, i, n), t.strokeStyle = a.borderColor, t.fillStyle = a.backgroundColor, Me(t, e, i, n)
      } else {
        t.lineWidth = n(a.borderWidth) ? Math.max(...Object.values(a.borderWidth)) : a.borderWidth || 1, t.strokeStyle = a.borderColor, t.setLineDash(a.borderDash || []), t.lineDashOffset = a.borderDashOffset || 0;
        const e = s.leftForLtr(f, h - c),
          i = s.leftForLtr(s.xPlus(f, 1), h - c - 2),
          r = gi(a.borderRadius);
        Object.values(r).some((t => 0 !== t)) ? (t.beginPath(), t.fillStyle = o.multiKeyBackground, Le(t, {
          x: e,
          y: p,
          w: h,
          h: l,
          radius: r
        }), t.fill(), t.stroke(), t.fillStyle = a.backgroundColor, t.beginPath(), Le(t, {
          x: i,
          y: p + 1,
          w: h - 2,
          h: l - 2,
          radius: r
        }), t.fill()) : (t.fillStyle = o.multiKeyBackground, t.fillRect(e, p, h, l), t.strokeRect(e, p, h, l), t.fillStyle = a.backgroundColor, t.fillRect(i, p + 1, h - 2, l - 2))
      }
      t.fillStyle = this.labelTextColors[i]
    }
    drawBody(t, e, i) {
      const {
        body: s
      } = this, {
        bodySpacing: n,
        bodyAlign: o,
        displayColors: a,
        boxHeight: r,
        boxWidth: l,
        boxPadding: h
      } = i, c = mi(i.bodyFont);
      let u = c.lineHeight,
        f = 0;
      const g = yi(i.rtl, this.x, this.width),
        p = function (i) {
          e.fillText(i, g.x(t.x + f), t.y + u / 2), t.y += u + n
        },
        m = g.textAlign(o);
      let b, x, _, y, v, w, M;
      for (e.textAlign = o, e.textBaseline = "middle", e.font = c.string, t.x = Xo(this, m, i), e.fillStyle = i.bodyColor, d(this.beforeBody, p), f = a && "right" !== m ? "center" === o ? l / 2 + h : l + 2 + h : 0, y = 0, w = s.length; y < w; ++y) {
        for (b = s[y], x = this.labelTextColors[y], e.fillStyle = x, d(b.before, p), _ = b.lines, a && _.length && (this._drawColorBox(e, t, y, g, i), u = Math.max(c.lineHeight, r)), v = 0, M = _.length; v < M; ++v) p(_[v]), u = c.lineHeight;
        d(b.after, p)
      }
      f = 0, u = c.lineHeight, d(this.afterBody, p), t.y -= n
    }
    drawFooter(t, e, i) {
      const s = this.footer,
        n = s.length;
      let o, a;
      if (n) {
        const r = yi(i.rtl, this.x, this.width);
        for (t.x = Xo(this, i.footerAlign, i), t.y += i.footerMarginTop, e.textAlign = r.textAlign(i.footerAlign), e.textBaseline = "middle", o = mi(i.footerFont), e.fillStyle = i.footerColor, e.font = o.string, a = 0; a < n; ++a) e.fillText(s[a], r.x(t.x), t.y + o.lineHeight / 2), t.y += o.lineHeight + i.footerSpacing
      }
    }
    drawBackground(t, e, i, s) {
      const {
        xAlign: n,
        yAlign: o
      } = this, {
        x: a,
        y: r
      } = t, {
        width: l,
        height: h
      } = i, {
        topLeft: c,
        topRight: d,
        bottomLeft: u,
        bottomRight: f
      } = gi(s.cornerRadius);
      e.fillStyle = s.backgroundColor, e.strokeStyle = s.borderColor, e.lineWidth = s.borderWidth, e.beginPath(), e.moveTo(a + c, r), "top" === o && this.drawCaret(t, e, i, s), e.lineTo(a + l - d, r), e.quadraticCurveTo(a + l, r, a + l, r + d), "center" === o && "right" === n && this.drawCaret(t, e, i, s), e.lineTo(a + l, r + h - f), e.quadraticCurveTo(a + l, r + h, a + l - f, r + h), "bottom" === o && this.drawCaret(t, e, i, s), e.lineTo(a + u, r + h), e.quadraticCurveTo(a, r + h, a, r + h - u), "center" === o && "left" === n && this.drawCaret(t, e, i, s), e.lineTo(a, r + c), e.quadraticCurveTo(a, r, a + c, r), e.closePath(), e.fill(), s.borderWidth > 0 && e.stroke()
    }
    _updateAnimationTarget(t) {
      const e = this.chart,
        i = this.$animations,
        s = i && i.x,
        n = i && i.y;
      if (s || n) {
        const i = Bo[t.position].call(this, this._active, this._eventPosition);
        if (!i) return;
        const o = this._size = Ho(this, t),
          a = Object.assign({}, i, this._size),
          r = Yo(e, t, a),
          l = Uo(t, a, r, e);
        s._to === l.x && n._to === l.y || (this.xAlign = r.xAlign, this.yAlign = r.yAlign, this.width = o.width, this.height = o.height, this.caretX = i.x, this.caretY = i.y, this._resolveAnimations().update(this, l))
      }
    }
    _willRender() {
      return !!this.opacity
    }
    draw(t) {
      const e = this.options.setContext(this.getContext());
      let i = this.opacity;
      if (!i) return;
      this._updateAnimationTarget(e);
      const s = {
          width: this.width,
          height: this.height
        },
        n = {
          x: this.x,
          y: this.y
        };
      i = Math.abs(i) < .001 ? 0 : i;
      const o = pi(e.padding),
        a = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
      e.enabled && a && (t.save(), t.globalAlpha = i, this.drawBackground(n, t, s, e), vi(t, e.textDirection), n.y += o.top, this.drawTitle(n, t, e), this.drawBody(n, t, e), this.drawFooter(n, t, e), wi(t, e.textDirection), t.restore())
    }
    getActiveElements() {
      return this._active || []
    }
    setActiveElements(t, e) {
      const i = this._active,
        s = t.map((({
          datasetIndex: t,
          index: e
        }) => {
          const i = this.chart.getDatasetMeta(t);
          if (!i) throw new Error("Cannot find a dataset at index " + t);
          return {
            datasetIndex: t,
            element: i.data[e],
            index: e
          }
        })),
        n = !u(i, s),
        o = this._positionChanged(s, e);
      (n || o) && (this._active = s, this._eventPosition = e, this._ignoreReplayEvents = !0, this.update(!0))
    }
    handleEvent(t, e, i = !0) {
      if (e && this._ignoreReplayEvents) return !1;
      this._ignoreReplayEvents = !1;
      const s = this.options,
        n = this._active || [],
        o = this._getActiveElements(t, n, e, i),
        a = this._positionChanged(o, t),
        r = e || !u(o, n) || a;
      return r && (this._active = o, (s.enabled || s.external) && (this._eventPosition = {
        x: t.x,
        y: t.y
      }, this.update(!0, e))), r
    }
    _getActiveElements(t, e, i, s) {
      const n = this.options;
      if ("mouseout" === t.type) return [];
      if (!s) return e;
      const o = this.chart.getElementsAtEventForMode(t, n.mode, n, i);
      return n.reverse && o.reverse(), o
    }
    _positionChanged(t, e) {
      const {
        caretX: i,
        caretY: s,
        options: n
      } = this, o = Bo[n.position].call(this, t, e);
      return !1 !== o && (i !== o.x || s !== o.y)
    }
  }
  Go.positioners = Bo;
  var Zo = {
      id: "tooltip",
      _element: Go,
      positioners: Bo,
      afterInit(t, e, i) {
        i && (t.tooltip = new Go({
          chart: t,
          options: i
        }))
      },
      beforeUpdate(t, e, i) {
        t.tooltip && t.tooltip.initialize(i)
      },
      reset(t, e, i) {
        t.tooltip && t.tooltip.initialize(i)
      },
      afterDraw(t) {
        const e = t.tooltip;
        if (e && e._willRender()) {
          const i = {
            tooltip: e
          };
          if (!1 === t.notifyPlugins("beforeTooltipDraw", i)) return;
          e.draw(t.ctx), t.notifyPlugins("afterTooltipDraw", i)
        }
      },
      afterEvent(t, e) {
        if (t.tooltip) {
          const i = e.replay;
          t.tooltip.handleEvent(e.event, i, e.inChartArea) && (e.changed = !0)
        }
      },
      defaults: {
        enabled: !0,
        external: null,
        position: "average",
        backgroundColor: "rgba(0,0,0,0.8)",
        titleColor: "#fff",
        titleFont: {
          weight: "bold"
        },
        titleSpacing: 2,
        titleMarginBottom: 6,
        titleAlign: "left",
        bodyColor: "#fff",
        bodySpacing: 2,
        bodyFont: {},
        bodyAlign: "left",
        footerColor: "#fff",
        footerSpacing: 2,
        footerMarginTop: 6,
        footerFont: {
          weight: "bold"
        },
        footerAlign: "left",
        padding: 6,
        caretPadding: 2,
        caretSize: 5,
        cornerRadius: 6,
        boxHeight: (t, e) => e.bodyFont.size,
        boxWidth: (t, e) => e.bodyFont.size,
        multiKeyBackground: "#fff",
        displayColors: !0,
        boxPadding: 0,
        borderColor: "rgba(0,0,0,0)",
        borderWidth: 0,
        animation: {
          duration: 400,
          easing: "easeOutQuart"
        },
        animations: {
          numbers: {
            type: "number",
            properties: ["x", "y", "width", "height", "caretX", "caretY"]
          },
          opacity: {
            easing: "linear",
            duration: 200
          }
        },
        callbacks: {
          beforeTitle: t,
          title(t) {
            if (t.length > 0) {
              const e = t[0],
                i = e.chart.data.labels,
                s = i ? i.length : 0;
              if (this && this.options && "dataset" === this.options.mode) return e.dataset.label || "";
              if (e.label) return e.label;
              if (s > 0 && e.dataIndex < s) return i[e.dataIndex]
            }
            return ""
          },
          afterTitle: t,
          beforeBody: t,
          beforeLabel: t,
          label(t) {
            if (this && this.options && "dataset" === this.options.mode) return t.label + ": " + t.formattedValue || t.formattedValue;
            let e = t.dataset.label || "";
            e && (e += ": ");
            const s = t.formattedValue;
            return i(s) || (e += s), e
          },
          labelColor(t) {
            const e = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);
            return {
              borderColor: e.borderColor,
              backgroundColor: e.backgroundColor,
              borderWidth: e.borderWidth,
              borderDash: e.borderDash,
              borderDashOffset: e.borderDashOffset,
              borderRadius: 0
            }
          },
          labelTextColor() {
            return this.options.bodyColor
          },
          labelPointStyle(t) {
            const e = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);
            return {
              pointStyle: e.pointStyle,
              rotation: e.rotation
            }
          },
          afterLabel: t,
          afterBody: t,
          beforeFooter: t,
          footer: t,
          afterFooter: t
        }
      },
      defaultRoutes: {
        bodyFont: "font",
        footerFont: "font",
        titleFont: "font"
      },
      descriptors: {
        _scriptable: t => "filter" !== t && "itemSort" !== t && "external" !== t,
        _indexable: !1,
        callbacks: {
          _scriptable: !1,
          _indexable: !1
        },
        animation: {
          _fallback: !1
        },
        animations: {
          _fallback: "animation"
        }
      },
      additionalOptionScopes: ["interaction"]
    },
    Jo = Object.freeze({
      __proto__: null,
      Decimation: go,
      Filler: To,
      Legend: Ro,
      SubTitle: Vo,
      Title: zo,
      Tooltip: Zo
    });

  function Qo(t, e, i, s) {
    const n = t.indexOf(e);
    if (-1 === n) return ((t, e, i, s) => ("string" == typeof e ? (i = t.push(e) - 1, s.unshift({
      index: i,
      label: e
    })) : isNaN(e) && (i = null), i))(t, e, i, s);
    return n !== t.lastIndexOf(e) ? i : n
  }
  class ta extends $s {
    constructor(t) {
      super(t), this._startValue = void 0, this._valueRange = 0, this._addedLabels = []
    }
    init(t) {
      const e = this._addedLabels;
      if (e.length) {
        const t = this.getLabels();
        for (const {
            index: i,
            label: s
          } of e) t[i] === s && t.splice(i, 1);
        this._addedLabels = []
      }
      super.init(t)
    }
    parse(t, e) {
      if (i(t)) return null;
      const s = this.getLabels();
      return ((t, e) => null === t ? null : Z(Math.round(t), 0, e))(e = isFinite(e) && s[e] === t ? e : Qo(s, t, r(e, t), this._addedLabels), s.length - 1)
    }
    determineDataLimits() {
      const {
        minDefined: t,
        maxDefined: e
      } = this.getUserBounds();
      let {
        min: i,
        max: s
      } = this.getMinMax(!0);
      "ticks" === this.options.bounds && (t || (i = 0), e || (s = this.getLabels().length - 1)), this.min = i, this.max = s
    }
    buildTicks() {
      const t = this.min,
        e = this.max,
        i = this.options.offset,
        s = [];
      let n = this.getLabels();
      n = 0 === t && e === n.length - 1 ? n : n.slice(t, e + 1), this._valueRange = Math.max(n.length - (i ? 0 : 1), 1), this._startValue = this.min - (i ? .5 : 0);
      for (let i = t; i <= e; i++) s.push({
        value: i
      });
      return s
    }
    getLabelForValue(t) {
      const e = this.getLabels();
      return t >= 0 && t < e.length ? e[t] : t
    }
    configure() {
      super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels)
    }
    getPixelForValue(t) {
      return "number" != typeof t && (t = this.parse(t)), null === t ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange)
    }
    getPixelForTick(t) {
      const e = this.ticks;
      return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value)
    }
    getValueForPixel(t) {
      return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange)
    }
    getBasePixel() {
      return this.bottom
    }
  }

  function ea(t, e, {
    horizontal: i,
    minRotation: s
  }) {
    const n = H(s),
      o = (i ? Math.sin(n) : Math.cos(n)) || .001,
      a = .75 * e * ("" + t).length;
    return Math.min(e / o, a)
  }
  ta.id = "category", ta.defaults = {
    ticks: {
      callback: ta.prototype.getLabelForValue
    }
  };
  class ia extends $s {
    constructor(t) {
      super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0
    }
    parse(t, e) {
      return i(t) || ("number" == typeof t || t instanceof Number) && !isFinite(+t) ? null : +t
    }
    handleTickRangeOptions() {
      const {
        beginAtZero: t
      } = this.options, {
        minDefined: e,
        maxDefined: i
      } = this.getUserBounds();
      let {
        min: s,
        max: n
      } = this;
      const o = t => s = e ? s : t,
        a = t => n = i ? n : t;
      if (t) {
        const t = z(s),
          e = z(n);
        t < 0 && e < 0 ? a(0) : t > 0 && e > 0 && o(0)
      }
      if (s === n) {
        let e = 1;
        (n >= Number.MAX_SAFE_INTEGER || s <= Number.MIN_SAFE_INTEGER) && (e = Math.abs(.05 * n)), a(n + e), t || o(s - e)
      }
      this.min = s, this.max = n
    }
    getTickLimit() {
      const t = this.options.ticks;
      let e, {
        maxTicksLimit: i,
        stepSize: s
      } = t;
      return s ? (e = Math.ceil(this.max / s) - Math.floor(this.min / s) + 1, e > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${s} would result generating up to ${e} ticks. Limiting to 1000.`), e = 1e3)) : (e = this.computeTickLimit(), i = i || 11), i && (e = Math.min(i, e)), e
    }
    computeTickLimit() {
      return Number.POSITIVE_INFINITY
    }
    buildTicks() {
      const t = this.options,
        e = t.ticks;
      let s = this.getTickLimit();
      s = Math.max(2, s);
      const n = function (t, e) {
        const s = [],
          {
            bounds: n,
            step: o,
            min: a,
            max: r,
            precision: l,
            count: h,
            maxTicks: c,
            maxDigits: d,
            includeBounds: u
          } = t,
          f = o || 1,
          g = c - 1,
          {
            min: p,
            max: m
          } = e,
          b = !i(a),
          x = !i(r),
          _ = !i(h),
          y = (m - p) / (d + 1);
        let v, w, M, k, S = F((m - p) / g / f) * f;
        if (S < 1e-14 && !b && !x) return [{
          value: p
        }, {
          value: m
        }];
        k = Math.ceil(m / S) - Math.floor(p / S), k > g && (S = F(k * S / g / f) * f), i(l) || (v = Math.pow(10, l), S = Math.ceil(S * v) / v), "ticks" === n ? (w = Math.floor(p / S) * S, M = Math.ceil(m / S) * S) : (w = p, M = m), b && x && o && W((r - a) / o, S / 1e3) ? (k = Math.round(Math.min((r - a) / S, c)), S = (r - a) / k, w = a, M = r) : _ ? (w = b ? a : w, M = x ? r : M, k = h - 1, S = (M - w) / k) : (k = (M - w) / S, k = N(k, Math.round(k), S / 1e3) ? Math.round(k) : Math.ceil(k));
        const P = Math.max(Y(S), Y(w));
        v = Math.pow(10, i(l) ? P : l), w = Math.round(w * v) / v, M = Math.round(M * v) / v;
        let D = 0;
        for (b && (u && w !== a ? (s.push({
            value: a
          }), w < a && D++, N(Math.round((w + D * S) * v) / v, a, ea(a, y, t)) && D++) : w < a && D++); D < k; ++D) s.push({
          value: Math.round((w + D * S) * v) / v
        });
        return x && u && M !== r ? s.length && N(s[s.length - 1].value, r, ea(r, y, t)) ? s[s.length - 1].value = r : s.push({
          value: r
        }) : x && M !== r || s.push({
          value: M
        }), s
      }({
        maxTicks: s,
        bounds: t.bounds,
        min: t.min,
        max: t.max,
        precision: e.precision,
        step: e.stepSize,
        count: e.count,
        maxDigits: this._maxDigits(),
        horizontal: this.isHorizontal(),
        minRotation: e.minRotation || 0,
        includeBounds: !1 !== e.includeBounds
      }, this._range || this);
      return "ticks" === t.bounds && j(n, this, "value"), t.reverse ? (n.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), n
    }
    configure() {
      const t = this.ticks;
      let e = this.min,
        i = this.max;
      if (super.configure(), this.options.offset && t.length) {
        const s = (i - e) / Math.max(t.length - 1, 1) / 2;
        e -= s, i += s
      }
      this._startValue = e, this._endValue = i, this._valueRange = i - e
    }
    getLabelForValue(t) {
      return li(t, this.chart.options.locale, this.options.ticks.format)
    }
  }
  class sa extends ia {
    determineDataLimits() {
      const {
        min: t,
        max: e
      } = this.getMinMax(!0);
      this.min = o(t) ? t : 0, this.max = o(e) ? e : 1, this.handleTickRangeOptions()
    }
    computeTickLimit() {
      const t = this.isHorizontal(),
        e = t ? this.width : this.height,
        i = H(this.options.ticks.minRotation),
        s = (t ? Math.sin(i) : Math.cos(i)) || .001,
        n = this._resolveTickFontOptions(0);
      return Math.ceil(e / Math.min(40, n.lineHeight / s))
    }
    getPixelForValue(t) {
      return null === t ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange)
    }
    getValueForPixel(t) {
      return this._startValue + this.getDecimalForPixel(t) * this._valueRange
    }
  }

  function na(t) {
    return 1 === t / Math.pow(10, Math.floor(I(t)))
  }
  sa.id = "linear", sa.defaults = {
    ticks: {
      callback: Is.formatters.numeric
    }
  };
  class oa extends $s {
    constructor(t) {
      super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0
    }
    parse(t, e) {
      const i = ia.prototype.parse.apply(this, [t, e]);
      if (0 !== i) return o(i) && i > 0 ? i : null;
      this._zero = !0
    }
    determineDataLimits() {
      const {
        min: t,
        max: e
      } = this.getMinMax(!0);
      this.min = o(t) ? Math.max(0, t) : null, this.max = o(e) ? Math.max(0, e) : null, this.options.beginAtZero && (this._zero = !0), this.handleTickRangeOptions()
    }
    handleTickRangeOptions() {
      const {
        minDefined: t,
        maxDefined: e
      } = this.getUserBounds();
      let i = this.min,
        s = this.max;
      const n = e => i = t ? i : e,
        o = t => s = e ? s : t,
        a = (t, e) => Math.pow(10, Math.floor(I(t)) + e);
      i === s && (i <= 0 ? (n(1), o(10)) : (n(a(i, -1)), o(a(s, 1)))), i <= 0 && n(a(s, -1)), s <= 0 && o(a(i, 1)), this._zero && this.min !== this._suggestedMin && i === a(this.min, 0) && n(a(i, -1)), this.min = i, this.max = s
    }
    buildTicks() {
      const t = this.options,
        e = function (t, e) {
          const i = Math.floor(I(e.max)),
            s = Math.ceil(e.max / Math.pow(10, i)),
            n = [];
          let o = a(t.min, Math.pow(10, Math.floor(I(e.min)))),
            r = Math.floor(I(o)),
            l = Math.floor(o / Math.pow(10, r)),
            h = r < 0 ? Math.pow(10, Math.abs(r)) : 1;
          do {
            n.push({
              value: o,
              major: na(o)
            }), ++l, 10 === l && (l = 1, ++r, h = r >= 0 ? 1 : h), o = Math.round(l * Math.pow(10, r) * h) / h
          } while (r < i || r === i && l < s);
          const c = a(t.max, o);
          return n.push({
            value: c,
            major: na(o)
          }), n
        }({
          min: this._userMin,
          max: this._userMax
        }, this);
      return "ticks" === t.bounds && j(e, this, "value"), t.reverse ? (e.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), e
    }
    getLabelForValue(t) {
      return void 0 === t ? "0" : li(t, this.chart.options.locale, this.options.ticks.format)
    }
    configure() {
      const t = this.min;
      super.configure(), this._startValue = I(t), this._valueRange = I(this.max) - I(t)
    }
    getPixelForValue(t) {
      return void 0 !== t && 0 !== t || (t = this.min), null === t || isNaN(t) ? NaN : this.getPixelForDecimal(t === this.min ? 0 : (I(t) - this._startValue) / this._valueRange)
    }
    getValueForPixel(t) {
      const e = this.getDecimalForPixel(t);
      return Math.pow(10, this._startValue + e * this._valueRange)
    }
  }

  function aa(t) {
    const e = t.ticks;
    if (e.display && t.display) {
      const t = pi(e.backdropPadding);
      return r(e.font && e.font.size, ne.font.size) + t.height
    }
    return 0
  }

  function ra(t, e, i, s, n) {
    return t === s || t === n ? {
      start: e - i / 2,
      end: e + i / 2
    } : t < s || t > n ? {
      start: e - i,
      end: e
    } : {
      start: e,
      end: e + i
    }
  }

  function la(t) {
    const e = {
        l: t.left + t._padding.left,
        r: t.right - t._padding.right,
        t: t.top + t._padding.top,
        b: t.bottom - t._padding.bottom
      },
      i = Object.assign({}, e),
      n = [],
      o = [],
      a = t._pointLabels.length,
      r = t.options.pointLabels,
      l = r.centerPointLabels ? D / a : 0;
    for (let u = 0; u < a; u++) {
      const a = r.setContext(t.getPointLabelContext(u));
      o[u] = a.padding;
      const f = t.getPointPosition(u, t.drawingArea + o[u], l),
        g = mi(a.font),
        p = (h = t.ctx, c = g, d = s(d = t._pointLabels[u]) ? d : [d], {
          w: ye(h, c.string, d),
          h: d.length * c.lineHeight
        });
      n[u] = p;
      const m = K(t.getIndexAngle(u) + l),
        b = Math.round($(m));
      ha(i, e, m, ra(b, f.x, p.w, 0, 180), ra(b, f.y, p.h, 90, 270))
    }
    var h, c, d;
    t.setCenterPoint(e.l - i.l, i.r - e.r, e.t - i.t, i.b - e.b), t._pointLabelItems = function (t, e, i) {
      const s = [],
        n = t._pointLabels.length,
        o = t.options,
        a = aa(o) / 2,
        r = t.drawingArea,
        l = o.pointLabels.centerPointLabels ? D / n : 0;
      for (let o = 0; o < n; o++) {
        const n = t.getPointPosition(o, r + a + i[o], l),
          h = Math.round($(K(n.angle + L))),
          c = e[o],
          d = ua(n.y, c.h, h),
          u = ca(h),
          f = da(n.x, c.w, u);
        s.push({
          x: n.x,
          y: d,
          textAlign: u,
          left: f,
          top: d,
          right: f + c.w,
          bottom: d + c.h
        })
      }
      return s
    }(t, n, o)
  }

  function ha(t, e, i, s, n) {
    const o = Math.abs(Math.sin(i)),
      a = Math.abs(Math.cos(i));
    let r = 0,
      l = 0;
    s.start < e.l ? (r = (e.l - s.start) / o, t.l = Math.min(t.l, e.l - r)) : s.end > e.r && (r = (s.end - e.r) / o, t.r = Math.max(t.r, e.r + r)), n.start < e.t ? (l = (e.t - n.start) / a, t.t = Math.min(t.t, e.t - l)) : n.end > e.b && (l = (n.end - e.b) / a, t.b = Math.max(t.b, e.b + l))
  }

  function ca(t) {
    return 0 === t || 180 === t ? "center" : t < 180 ? "left" : "right"
  }

  function da(t, e, i) {
    return "right" === i ? t -= e : "center" === i && (t -= e / 2), t
  }

  function ua(t, e, i) {
    return 90 === i || 270 === i ? t -= e / 2 : (i > 270 || i < 90) && (t -= e), t
  }

  function fa(t, e, i, s) {
    const {
      ctx: n
    } = t;
    if (i) n.arc(t.xCenter, t.yCenter, e, 0, O);
    else {
      let i = t.getPointPosition(0, e);
      n.moveTo(i.x, i.y);
      for (let o = 1; o < s; o++) i = t.getPointPosition(o, e), n.lineTo(i.x, i.y)
    }
  }
  oa.id = "logarithmic", oa.defaults = {
    ticks: {
      callback: Is.formatters.logarithmic,
      major: {
        enabled: !0
      }
    }
  };
  class ga extends ia {
    constructor(t) {
      super(t), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = []
    }
    setDimensions() {
      const t = this._padding = pi(aa(this.options) / 2),
        e = this.width = this.maxWidth - t.width,
        i = this.height = this.maxHeight - t.height;
      this.xCenter = Math.floor(this.left + e / 2 + t.left), this.yCenter = Math.floor(this.top + i / 2 + t.top), this.drawingArea = Math.floor(Math.min(e, i) / 2)
    }
    determineDataLimits() {
      const {
        min: t,
        max: e
      } = this.getMinMax(!1);
      this.min = o(t) && !isNaN(t) ? t : 0, this.max = o(e) && !isNaN(e) ? e : 0, this.handleTickRangeOptions()
    }
    computeTickLimit() {
      return Math.ceil(this.drawingArea / aa(this.options))
    }
    generateTickLabels(t) {
      ia.prototype.generateTickLabels.call(this, t), this._pointLabels = this.getLabels().map(((t, e) => {
        const i = c(this.options.pointLabels.callback, [t, e], this);
        return i || 0 === i ? i : ""
      })).filter(((t, e) => this.chart.getDataVisibility(e)))
    }
    fit() {
      const t = this.options;
      t.display && t.pointLabels.display ? la(this) : this.setCenterPoint(0, 0, 0, 0)
    }
    setCenterPoint(t, e, i, s) {
      this.xCenter += Math.floor((t - e) / 2), this.yCenter += Math.floor((i - s) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(t, e, i, s))
    }
    getIndexAngle(t) {
      return K(t * (O / (this._pointLabels.length || 1)) + H(this.options.startAngle || 0))
    }
    getDistanceFromCenterForValue(t) {
      if (i(t)) return NaN;
      const e = this.drawingArea / (this.max - this.min);
      return this.options.reverse ? (this.max - t) * e : (t - this.min) * e
    }
    getValueForDistanceFromCenter(t) {
      if (i(t)) return NaN;
      const e = t / (this.drawingArea / (this.max - this.min));
      return this.options.reverse ? this.max - e : this.min + e
    }
    getPointLabelContext(t) {
      const e = this._pointLabels || [];
      if (t >= 0 && t < e.length) {
        const i = e[t];
        return function (t, e, i) {
          return _i(t, {
            label: i,
            index: e,
            type: "pointLabel"
          })
        }(this.getContext(), t, i)
      }
    }
    getPointPosition(t, e, i = 0) {
      const s = this.getIndexAngle(t) - L + i;
      return {
        x: Math.cos(s) * e + this.xCenter,
        y: Math.sin(s) * e + this.yCenter,
        angle: s
      }
    }
    getPointPositionForValue(t, e) {
      return this.getPointPosition(t, this.getDistanceFromCenterForValue(e))
    }
    getBasePosition(t) {
      return this.getPointPositionForValue(t || 0, this.getBaseValue())
    }
    getPointLabelPosition(t) {
      const {
        left: e,
        top: i,
        right: s,
        bottom: n
      } = this._pointLabelItems[t];
      return {
        left: e,
        top: i,
        right: s,
        bottom: n
      }
    }
    drawBackground() {
      const {
        backgroundColor: t,
        grid: {
          circular: e
        }
      } = this.options;
      if (t) {
        const i = this.ctx;
        i.save(), i.beginPath(), fa(this, this.getDistanceFromCenterForValue(this._endValue), e, this._pointLabels.length), i.closePath(), i.fillStyle = t, i.fill(), i.restore()
      }
    }
    drawGrid() {
      const t = this.ctx,
        e = this.options,
        {
          angleLines: s,
          grid: n
        } = e,
        o = this._pointLabels.length;
      let a, r, l;
      if (e.pointLabels.display && function (t, e) {
          const {
            ctx: s,
            options: {
              pointLabels: n
            }
          } = t;
          for (let o = e - 1; o >= 0; o--) {
            const e = n.setContext(t.getPointLabelContext(o)),
              a = mi(e.font),
              {
                x: r,
                y: l,
                textAlign: h,
                left: c,
                top: d,
                right: u,
                bottom: f
              } = t._pointLabelItems[o],
              {
                backdropColor: g
              } = e;
            if (!i(g)) {
              const t = gi(e.borderRadius),
                i = pi(e.backdropPadding);
              s.fillStyle = g;
              const n = c - i.left,
                o = d - i.top,
                a = u - c + i.width,
                r = f - d + i.height;
              Object.values(t).some((t => 0 !== t)) ? (s.beginPath(), Le(s, {
                x: n,
                y: o,
                w: a,
                h: r,
                radius: t
              }), s.fill()) : s.fillRect(n, o, a, r)
            }
            Ae(s, t._pointLabels[o], r, l + a.lineHeight / 2, a, {
              color: e.color,
              textAlign: h,
              textBaseline: "middle"
            })
          }
        }(this, o), n.display && this.ticks.forEach(((t, e) => {
          if (0 !== e) {
            r = this.getDistanceFromCenterForValue(t.value);
            ! function (t, e, i, s) {
              const n = t.ctx,
                o = e.circular,
                {
                  color: a,
                  lineWidth: r
                } = e;
              !o && !s || !a || !r || i < 0 || (n.save(), n.strokeStyle = a, n.lineWidth = r, n.setLineDash(e.borderDash), n.lineDashOffset = e.borderDashOffset, n.beginPath(), fa(t, i, o, s), n.closePath(), n.stroke(), n.restore())
            }(this, n.setContext(this.getContext(e - 1)), r, o)
          }
        })), s.display) {
        for (t.save(), a = o - 1; a >= 0; a--) {
          const i = s.setContext(this.getPointLabelContext(a)),
            {
              color: n,
              lineWidth: o
            } = i;
          o && n && (t.lineWidth = o, t.strokeStyle = n, t.setLineDash(i.borderDash), t.lineDashOffset = i.borderDashOffset, r = this.getDistanceFromCenterForValue(e.ticks.reverse ? this.min : this.max), l = this.getPointPosition(a, r), t.beginPath(), t.moveTo(this.xCenter, this.yCenter), t.lineTo(l.x, l.y), t.stroke())
        }
        t.restore()
      }
    }
    drawBorder() {}
    drawLabels() {
      const t = this.ctx,
        e = this.options,
        i = e.ticks;
      if (!i.display) return;
      const s = this.getIndexAngle(0);
      let n, o;
      t.save(), t.translate(this.xCenter, this.yCenter), t.rotate(s), t.textAlign = "center", t.textBaseline = "middle", this.ticks.forEach(((s, a) => {
        if (0 === a && !e.reverse) return;
        const r = i.setContext(this.getContext(a)),
          l = mi(r.font);
        if (n = this.getDistanceFromCenterForValue(this.ticks[a].value), r.showLabelBackdrop) {
          t.font = l.string, o = t.measureText(s.label).width, t.fillStyle = r.backdropColor;
          const e = pi(r.backdropPadding);
          t.fillRect(-o / 2 - e.left, -n - l.size / 2 - e.top, o + e.width, l.size + e.height)
        }
        Ae(t, s.label, 0, -n, l, {
          color: r.color
        })
      })), t.restore()
    }
    drawTitle() {}
  }
  ga.id = "radialLinear", ga.defaults = {
    display: !0,
    animate: !0,
    position: "chartArea",
    angleLines: {
      display: !0,
      lineWidth: 1,
      borderDash: [],
      borderDashOffset: 0
    },
    grid: {
      circular: !1
    },
    startAngle: 0,
    ticks: {
      showLabelBackdrop: !0,
      callback: Is.formatters.numeric
    },
    pointLabels: {
      backdropColor: void 0,
      backdropPadding: 2,
      display: !0,
      font: {
        size: 10
      },
      callback: t => t,
      padding: 5,
      centerPointLabels: !1
    }
  }, ga.defaultRoutes = {
    "angleLines.color": "borderColor",
    "pointLabels.color": "color",
    "ticks.color": "color"
  }, ga.descriptors = {
    angleLines: {
      _fallback: "grid"
    }
  };
  const pa = {
      millisecond: {
        common: !0,
        size: 1,
        steps: 1e3
      },
      second: {
        common: !0,
        size: 1e3,
        steps: 60
      },
      minute: {
        common: !0,
        size: 6e4,
        steps: 60
      },
      hour: {
        common: !0,
        size: 36e5,
        steps: 24
      },
      day: {
        common: !0,
        size: 864e5,
        steps: 30
      },
      week: {
        common: !1,
        size: 6048e5,
        steps: 4
      },
      month: {
        common: !0,
        size: 2628e6,
        steps: 12
      },
      quarter: {
        common: !1,
        size: 7884e6,
        steps: 4
      },
      year: {
        common: !0,
        size: 3154e7
      }
    },
    ma = Object.keys(pa);

  function ba(t, e) {
    return t - e
  }

  function xa(t, e) {
    if (i(e)) return null;
    const s = t._adapter,
      {
        parser: n,
        round: a,
        isoWeekday: r
      } = t._parseOpts;
    let l = e;
    return "function" == typeof n && (l = n(l)), o(l) || (l = "string" == typeof n ? s.parse(l, n) : s.parse(l)), null === l ? null : (a && (l = "week" !== a || !B(r) && !0 !== r ? s.startOf(l, a) : s.startOf(l, "isoWeek", r)), +l)
  }

  function _a(t, e, i, s) {
    const n = ma.length;
    for (let o = ma.indexOf(t); o < n - 1; ++o) {
      const t = pa[ma[o]],
        n = t.steps ? t.steps : Number.MAX_SAFE_INTEGER;
      if (t.common && Math.ceil((i - e) / (n * t.size)) <= s) return ma[o]
    }
    return ma[n - 1]
  }

  function ya(t, e, i) {
    if (i) {
      if (i.length) {
        const {
          lo: s,
          hi: n
        } = tt(i, e);
        t[i[s] >= e ? i[s] : i[n]] = !0
      }
    } else t[e] = !0
  }

  function va(t, e, i) {
    const s = [],
      n = {},
      o = e.length;
    let a, r;
    for (a = 0; a < o; ++a) r = e[a], n[r] = a, s.push({
      value: r,
      major: !1
    });
    return 0 !== o && i ? function (t, e, i, s) {
      const n = t._adapter,
        o = +n.startOf(e[0].value, s),
        a = e[e.length - 1].value;
      let r, l;
      for (r = o; r <= a; r = +n.add(r, 1, s)) l = i[r], l >= 0 && (e[l].major = !0);
      return e
    }(t, s, n, i) : s
  }
  class wa extends $s {
    constructor(t) {
      super(t), this._cache = {
        data: [],
        labels: [],
        all: []
      }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0
    }
    init(t, e) {
      const i = t.time || (t.time = {}),
        s = this._adapter = new wn._date(t.adapters.date);
      s.init(e), b(i.displayFormats, s.formats()), this._parseOpts = {
        parser: i.parser,
        round: i.round,
        isoWeekday: i.isoWeekday
      }, super.init(t), this._normalized = e.normalized
    }
    parse(t, e) {
      return void 0 === t ? null : xa(this, t)
    }
    beforeLayout() {
      super.beforeLayout(), this._cache = {
        data: [],
        labels: [],
        all: []
      }
    }
    determineDataLimits() {
      const t = this.options,
        e = this._adapter,
        i = t.time.unit || "day";
      let {
        min: s,
        max: n,
        minDefined: a,
        maxDefined: r
      } = this.getUserBounds();

      function l(t) {
        a || isNaN(t.min) || (s = Math.min(s, t.min)), r || isNaN(t.max) || (n = Math.max(n, t.max))
      }
      a && r || (l(this._getLabelBounds()), "ticks" === t.bounds && "labels" === t.ticks.source || l(this.getMinMax(!1))), s = o(s) && !isNaN(s) ? s : +e.startOf(Date.now(), i), n = o(n) && !isNaN(n) ? n : +e.endOf(Date.now(), i) + 1, this.min = Math.min(s, n - 1), this.max = Math.max(s + 1, n)
    }
    _getLabelBounds() {
      const t = this.getLabelTimestamps();
      let e = Number.POSITIVE_INFINITY,
        i = Number.NEGATIVE_INFINITY;
      return t.length && (e = t[0], i = t[t.length - 1]), {
        min: e,
        max: i
      }
    }
    buildTicks() {
      const t = this.options,
        e = t.time,
        i = t.ticks,
        s = "labels" === i.source ? this.getLabelTimestamps() : this._generate();
      "ticks" === t.bounds && s.length && (this.min = this._userMin || s[0], this.max = this._userMax || s[s.length - 1]);
      const n = this.min,
        o = st(s, n, this.max);
      return this._unit = e.unit || (i.autoSkip ? _a(e.minUnit, this.min, this.max, this._getLabelCapacity(n)) : function (t, e, i, s, n) {
        for (let o = ma.length - 1; o >= ma.indexOf(i); o--) {
          const i = ma[o];
          if (pa[i].common && t._adapter.diff(n, s, i) >= e - 1) return i
        }
        return ma[i ? ma.indexOf(i) : 0]
      }(this, o.length, e.minUnit, this.min, this.max)), this._majorUnit = i.major.enabled && "year" !== this._unit ? function (t) {
        for (let e = ma.indexOf(t) + 1, i = ma.length; e < i; ++e)
          if (pa[ma[e]].common) return ma[e]
      }(this._unit) : void 0, this.initOffsets(s), t.reverse && o.reverse(), va(this, o, this._majorUnit)
    }
    afterAutoSkip() {
      this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((t => +t.value)))
    }
    initOffsets(t) {
      let e, i, s = 0,
        n = 0;
      this.options.offset && t.length && (e = this.getDecimalForValue(t[0]), s = 1 === t.length ? 1 - e : (this.getDecimalForValue(t[1]) - e) / 2, i = this.getDecimalForValue(t[t.length - 1]), n = 1 === t.length ? i : (i - this.getDecimalForValue(t[t.length - 2])) / 2);
      const o = t.length < 3 ? .5 : .25;
      s = Z(s, 0, o), n = Z(n, 0, o), this._offsets = {
        start: s,
        end: n,
        factor: 1 / (s + 1 + n)
      }
    }
    _generate() {
      const t = this._adapter,
        e = this.min,
        i = this.max,
        s = this.options,
        n = s.time,
        o = n.unit || _a(n.minUnit, e, i, this._getLabelCapacity(e)),
        a = r(n.stepSize, 1),
        l = "week" === o && n.isoWeekday,
        h = B(l) || !0 === l,
        c = {};
      let d, u, f = e;
      if (h && (f = +t.startOf(f, "isoWeek", l)), f = +t.startOf(f, h ? "day" : o), t.diff(i, e, o) > 1e5 * a) throw new Error(e + " and " + i + " are too far apart with stepSize of " + a + " " + o);
      const g = "data" === s.ticks.source && this.getDataTimestamps();
      for (d = f, u = 0; d < i; d = +t.add(d, a, o), u++) ya(c, d, g);
      return d !== i && "ticks" !== s.bounds && 1 !== u || ya(c, d, g), Object.keys(c).sort(((t, e) => t - e)).map((t => +t))
    }
    getLabelForValue(t) {
      const e = this._adapter,
        i = this.options.time;
      return i.tooltipFormat ? e.format(t, i.tooltipFormat) : e.format(t, i.displayFormats.datetime)
    }
    _tickFormatFunction(t, e, i, s) {
      const n = this.options,
        o = n.time.displayFormats,
        a = this._unit,
        r = this._majorUnit,
        l = a && o[a],
        h = r && o[r],
        d = i[e],
        u = r && h && d && d.major,
        f = this._adapter.format(t, s || (u ? h : l)),
        g = n.ticks.callback;
      return g ? c(g, [f, e, i], this) : f
    }
    generateTickLabels(t) {
      let e, i, s;
      for (e = 0, i = t.length; e < i; ++e) s = t[e], s.label = this._tickFormatFunction(s.value, e, t)
    }
    getDecimalForValue(t) {
      return null === t ? NaN : (t - this.min) / (this.max - this.min)
    }
    getPixelForValue(t) {
      const e = this._offsets,
        i = this.getDecimalForValue(t);
      return this.getPixelForDecimal((e.start + i) * e.factor)
    }
    getValueForPixel(t) {
      const e = this._offsets,
        i = this.getDecimalForPixel(t) / e.factor - e.end;
      return this.min + i * (this.max - this.min)
    }
    _getLabelSize(t) {
      const e = this.options.ticks,
        i = this.ctx.measureText(t).width,
        s = H(this.isHorizontal() ? e.maxRotation : e.minRotation),
        n = Math.cos(s),
        o = Math.sin(s),
        a = this._resolveTickFontOptions(0).size;
      return {
        w: i * n + a * o,
        h: i * o + a * n
      }
    }
    _getLabelCapacity(t) {
      const e = this.options.time,
        i = e.displayFormats,
        s = i[e.unit] || i.millisecond,
        n = this._tickFormatFunction(t, 0, va(this, [t], this._majorUnit), s),
        o = this._getLabelSize(n),
        a = Math.floor(this.isHorizontal() ? this.width / o.w : this.height / o.h) - 1;
      return a > 0 ? a : 1
    }
    getDataTimestamps() {
      let t, e, i = this._cache.data || [];
      if (i.length) return i;
      const s = this.getMatchingVisibleMetas();
      if (this._normalized && s.length) return this._cache.data = s[0].controller.getAllParsedValues(this);
      for (t = 0, e = s.length; t < e; ++t) i = i.concat(s[t].controller.getAllParsedValues(this));
      return this._cache.data = this.normalize(i)
    }
    getLabelTimestamps() {
      const t = this._cache.labels || [];
      let e, i;
      if (t.length) return t;
      const s = this.getLabels();
      for (e = 0, i = s.length; e < i; ++e) t.push(xa(this, s[e]));
      return this._cache.labels = this._normalized ? t : this.normalize(t)
    }
    normalize(t) {
      return rt(t.sort(ba))
    }
  }

  function Ma(t, e, i) {
    let s, n, o, a, r = 0,
      l = t.length - 1;
    i ? (e >= t[r].pos && e <= t[l].pos && ({
      lo: r,
      hi: l
    } = et(t, "pos", e)), ({
      pos: s,
      time: o
    } = t[r]), ({
      pos: n,
      time: a
    } = t[l])) : (e >= t[r].time && e <= t[l].time && ({
      lo: r,
      hi: l
    } = et(t, "time", e)), ({
      time: s,
      pos: o
    } = t[r]), ({
      time: n,
      pos: a
    } = t[l]));
    const h = n - s;
    return h ? o + (a - o) * (e - s) / h : o
  }
  wa.id = "time", wa.defaults = {
    bounds: "data",
    adapters: {},
    time: {
      parser: !1,
      unit: !1,
      round: !1,
      isoWeekday: !1,
      minUnit: "millisecond",
      displayFormats: {}
    },
    ticks: {
      source: "auto",
      major: {
        enabled: !1
      }
    }
  };
  class ka extends wa {
    constructor(t) {
      super(t), this._table = [], this._minPos = void 0, this._tableRange = void 0
    }
    initOffsets() {
      const t = this._getTimestampsForTable(),
        e = this._table = this.buildLookupTable(t);
      this._minPos = Ma(e, this.min), this._tableRange = Ma(e, this.max) - this._minPos, super.initOffsets(t)
    }
    buildLookupTable(t) {
      const {
        min: e,
        max: i
      } = this, s = [], n = [];
      let o, a, r, l, h;
      for (o = 0, a = t.length; o < a; ++o) l = t[o], l >= e && l <= i && s.push(l);
      if (s.length < 2) return [{
        time: e,
        pos: 0
      }, {
        time: i,
        pos: 1
      }];
      for (o = 0, a = s.length; o < a; ++o) h = s[o + 1], r = s[o - 1], l = s[o], Math.round((h + r) / 2) !== l && n.push({
        time: l,
        pos: o / (a - 1)
      });
      return n
    }
    _getTimestampsForTable() {
      let t = this._cache.all || [];
      if (t.length) return t;
      const e = this.getDataTimestamps(),
        i = this.getLabelTimestamps();
      return t = e.length && i.length ? this.normalize(e.concat(i)) : e.length ? e : i, t = this._cache.all = t, t
    }
    getDecimalForValue(t) {
      return (Ma(this._table, t) - this._minPos) / this._tableRange
    }
    getValueForPixel(t) {
      const e = this._offsets,
        i = this.getDecimalForPixel(t) / e.factor - e.end;
      return Ma(this._table, i * this._tableRange + this._minPos, !0)
    }
  }
  ka.id = "timeseries", ka.defaults = wa.defaults;
  var Sa = Object.freeze({
    __proto__: null,
    CategoryScale: ta,
    LinearScale: sa,
    LogarithmicScale: oa,
    RadialLinearScale: ga,
    TimeScale: wa,
    TimeSeriesScale: ka
  });
  return bn.register(Bn, Sa, co, Jo), bn.helpers = {
    ...Ti
  }, bn._adapters = wn, bn.Animation = xs, bn.Animations = ys, bn.animator = mt, bn.controllers = Us.controllers.items, bn.DatasetController = Ls, bn.Element = Es, bn.elements = co, bn.Interaction = Vi, bn.layouts = Zi, bn.platforms = ps, bn.Scale = $s, bn.Ticks = Is, Object.assign(bn, Bn, Sa, co, Jo, ps), bn.Chart = bn, "undefined" != typeof window && (window.Chart = bn), bn
}));

/*! Hammer.JS - v2.0.8 - 2016-04-23
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
! function (a, b, c, d) {
  "use strict";

  function e(a, b, c) {
    return setTimeout(j(a, c), b)
  }

  function f(a, b, c) {
    return Array.isArray(a) ? (g(a, c[b], c), !0) : !1
  }

  function g(a, b, c) {
    var e;
    if (a)
      if (a.forEach) a.forEach(b, c);
      else if (a.length !== d)
      for (e = 0; e < a.length;) b.call(c, a[e], e, a), e++;
    else
      for (e in a) a.hasOwnProperty(e) && b.call(c, a[e], e, a)
  }

  function h(b, c, d) {
    var e = "DEPRECATED METHOD: " + c + "\n" + d + " AT \n";
    return function () {
      var c = new Error("get-stack-trace"),
        d = c && c.stack ? c.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace",
        f = a.console && (a.console.warn || a.console.log);
      return f && f.call(a.console, e, d), b.apply(this, arguments)
    }
  }

  function i(a, b, c) {
    var d, e = b.prototype;
    d = a.prototype = Object.create(e), d.constructor = a, d._super = e, c && la(d, c)
  }

  function j(a, b) {
    return function () {
      return a.apply(b, arguments)
    }
  }

  function k(a, b) {
    return typeof a == oa ? a.apply(b ? b[0] || d : d, b) : a
  }

  function l(a, b) {
    return a === d ? b : a
  }

  function m(a, b, c) {
    g(q(b), function (b) {
      a.addEventListener(b, c, !1)
    })
  }

  function n(a, b, c) {
    g(q(b), function (b) {
      a.removeEventListener(b, c, !1)
    })
  }

  function o(a, b) {
    for (; a;) {
      if (a == b) return !0;
      a = a.parentNode
    }
    return !1
  }

  function p(a, b) {
    return a.indexOf(b) > -1
  }

  function q(a) {
    return a.trim().split(/\s+/g)
  }

  function r(a, b, c) {
    if (a.indexOf && !c) return a.indexOf(b);
    for (var d = 0; d < a.length;) {
      if (c && a[d][c] == b || !c && a[d] === b) return d;
      d++
    }
    return -1
  }

  function s(a) {
    return Array.prototype.slice.call(a, 0)
  }

  function t(a, b, c) {
    for (var d = [], e = [], f = 0; f < a.length;) {
      var g = b ? a[f][b] : a[f];
      r(e, g) < 0 && d.push(a[f]), e[f] = g, f++
    }
    return c && (d = b ? d.sort(function (a, c) {
      return a[b] > c[b]
    }) : d.sort()), d
  }

  function u(a, b) {
    for (var c, e, f = b[0].toUpperCase() + b.slice(1), g = 0; g < ma.length;) {
      if (c = ma[g], e = c ? c + f : b, e in a) return e;
      g++
    }
    return d
  }

  function v() {
    return ua++
  }

  function w(b) {
    var c = b.ownerDocument || b;
    return c.defaultView || c.parentWindow || a
  }

  function x(a, b) {
    var c = this;
    this.manager = a, this.callback = b, this.element = a.element, this.target = a.options.inputTarget, this.domHandler = function (b) {
      k(a.options.enable, [a]) && c.handler(b)
    }, this.init()
  }

  function y(a) {
    var b, c = a.options.inputClass;
    return new(b = c ? c : xa ? M : ya ? P : wa ? R : L)(a, z)
  }

  function z(a, b, c) {
    var d = c.pointers.length,
      e = c.changedPointers.length,
      f = b & Ea && d - e === 0,
      g = b & (Ga | Ha) && d - e === 0;
    c.isFirst = !!f, c.isFinal = !!g, f && (a.session = {}), c.eventType = b, A(a, c), a.emit("hammer.input", c), a.recognize(c), a.session.prevInput = c
  }

  function A(a, b) {
    var c = a.session,
      d = b.pointers,
      e = d.length;
    c.firstInput || (c.firstInput = D(b)), e > 1 && !c.firstMultiple ? c.firstMultiple = D(b) : 1 === e && (c.firstMultiple = !1);
    var f = c.firstInput,
      g = c.firstMultiple,
      h = g ? g.center : f.center,
      i = b.center = E(d);
    b.timeStamp = ra(), b.deltaTime = b.timeStamp - f.timeStamp, b.angle = I(h, i), b.distance = H(h, i), B(c, b), b.offsetDirection = G(b.deltaX, b.deltaY);
    var j = F(b.deltaTime, b.deltaX, b.deltaY);
    b.overallVelocityX = j.x, b.overallVelocityY = j.y, b.overallVelocity = qa(j.x) > qa(j.y) ? j.x : j.y, b.scale = g ? K(g.pointers, d) : 1, b.rotation = g ? J(g.pointers, d) : 0, b.maxPointers = c.prevInput ? b.pointers.length > c.prevInput.maxPointers ? b.pointers.length : c.prevInput.maxPointers : b.pointers.length, C(c, b);
    var k = a.element;
    o(b.srcEvent.target, k) && (k = b.srcEvent.target), b.target = k
  }

  function B(a, b) {
    var c = b.center,
      d = a.offsetDelta || {},
      e = a.prevDelta || {},
      f = a.prevInput || {};
    b.eventType !== Ea && f.eventType !== Ga || (e = a.prevDelta = {
      x: f.deltaX || 0,
      y: f.deltaY || 0
    }, d = a.offsetDelta = {
      x: c.x,
      y: c.y
    }), b.deltaX = e.x + (c.x - d.x), b.deltaY = e.y + (c.y - d.y)
  }

  function C(a, b) {
    var c, e, f, g, h = a.lastInterval || b,
      i = b.timeStamp - h.timeStamp;
    if (b.eventType != Ha && (i > Da || h.velocity === d)) {
      var j = b.deltaX - h.deltaX,
        k = b.deltaY - h.deltaY,
        l = F(i, j, k);
      e = l.x, f = l.y, c = qa(l.x) > qa(l.y) ? l.x : l.y, g = G(j, k), a.lastInterval = b
    } else c = h.velocity, e = h.velocityX, f = h.velocityY, g = h.direction;
    b.velocity = c, b.velocityX = e, b.velocityY = f, b.direction = g
  }

  function D(a) {
    for (var b = [], c = 0; c < a.pointers.length;) b[c] = {
      clientX: pa(a.pointers[c].clientX),
      clientY: pa(a.pointers[c].clientY)
    }, c++;
    return {
      timeStamp: ra(),
      pointers: b,
      center: E(b),
      deltaX: a.deltaX,
      deltaY: a.deltaY
    }
  }

  function E(a) {
    var b = a.length;
    if (1 === b) return {
      x: pa(a[0].clientX),
      y: pa(a[0].clientY)
    };
    for (var c = 0, d = 0, e = 0; b > e;) c += a[e].clientX, d += a[e].clientY, e++;
    return {
      x: pa(c / b),
      y: pa(d / b)
    }
  }

  function F(a, b, c) {
    return {
      x: b / a || 0,
      y: c / a || 0
    }
  }

  function G(a, b) {
    return a === b ? Ia : qa(a) >= qa(b) ? 0 > a ? Ja : Ka : 0 > b ? La : Ma
  }

  function H(a, b, c) {
    c || (c = Qa);
    var d = b[c[0]] - a[c[0]],
      e = b[c[1]] - a[c[1]];
    return Math.sqrt(d * d + e * e)
  }

  function I(a, b, c) {
    c || (c = Qa);
    var d = b[c[0]] - a[c[0]],
      e = b[c[1]] - a[c[1]];
    return 180 * Math.atan2(e, d) / Math.PI
  }

  function J(a, b) {
    return I(b[1], b[0], Ra) + I(a[1], a[0], Ra)
  }

  function K(a, b) {
    return H(b[0], b[1], Ra) / H(a[0], a[1], Ra)
  }

  function L() {
    this.evEl = Ta, this.evWin = Ua, this.pressed = !1, x.apply(this, arguments)
  }

  function M() {
    this.evEl = Xa, this.evWin = Ya, x.apply(this, arguments), this.store = this.manager.session.pointerEvents = []
  }

  function N() {
    this.evTarget = $a, this.evWin = _a, this.started = !1, x.apply(this, arguments)
  }

  function O(a, b) {
    var c = s(a.touches),
      d = s(a.changedTouches);
    return b & (Ga | Ha) && (c = t(c.concat(d), "identifier", !0)), [c, d]
  }

  function P() {
    this.evTarget = bb, this.targetIds = {}, x.apply(this, arguments)
  }

  function Q(a, b) {
    var c = s(a.touches),
      d = this.targetIds;
    if (b & (Ea | Fa) && 1 === c.length) return d[c[0].identifier] = !0, [c, c];
    var e, f, g = s(a.changedTouches),
      h = [],
      i = this.target;
    if (f = c.filter(function (a) {
        return o(a.target, i)
      }), b === Ea)
      for (e = 0; e < f.length;) d[f[e].identifier] = !0, e++;
    for (e = 0; e < g.length;) d[g[e].identifier] && h.push(g[e]), b & (Ga | Ha) && delete d[g[e].identifier], e++;
    return h.length ? [t(f.concat(h), "identifier", !0), h] : void 0
  }

  function R() {
    x.apply(this, arguments);
    var a = j(this.handler, this);
    this.touch = new P(this.manager, a), this.mouse = new L(this.manager, a), this.primaryTouch = null, this.lastTouches = []
  }

  function S(a, b) {
    a & Ea ? (this.primaryTouch = b.changedPointers[0].identifier, T.call(this, b)) : a & (Ga | Ha) && T.call(this, b)
  }

  function T(a) {
    var b = a.changedPointers[0];
    if (b.identifier === this.primaryTouch) {
      var c = {
        x: b.clientX,
        y: b.clientY
      };
      this.lastTouches.push(c);
      var d = this.lastTouches,
        e = function () {
          var a = d.indexOf(c);
          a > -1 && d.splice(a, 1)
        };
      setTimeout(e, cb)
    }
  }

  function U(a) {
    for (var b = a.srcEvent.clientX, c = a.srcEvent.clientY, d = 0; d < this.lastTouches.length; d++) {
      var e = this.lastTouches[d],
        f = Math.abs(b - e.x),
        g = Math.abs(c - e.y);
      if (db >= f && db >= g) return !0
    }
    return !1
  }

  function V(a, b) {
    this.manager = a, this.set(b)
  }

  function W(a) {
    if (p(a, jb)) return jb;
    var b = p(a, kb),
      c = p(a, lb);
    return b && c ? jb : b || c ? b ? kb : lb : p(a, ib) ? ib : hb
  }

  function X() {
    if (!fb) return !1;
    var b = {},
      c = a.CSS && a.CSS.supports;
    return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function (d) {
      b[d] = c ? a.CSS.supports("touch-action", d) : !0
    }), b
  }

  function Y(a) {
    this.options = la({}, this.defaults, a || {}), this.id = v(), this.manager = null, this.options.enable = l(this.options.enable, !0), this.state = nb, this.simultaneous = {}, this.requireFail = []
  }

  function Z(a) {
    return a & sb ? "cancel" : a & qb ? "end" : a & pb ? "move" : a & ob ? "start" : ""
  }

  function $(a) {
    return a == Ma ? "down" : a == La ? "up" : a == Ja ? "left" : a == Ka ? "right" : ""
  }

  function _(a, b) {
    var c = b.manager;
    return c ? c.get(a) : a
  }

  function aa() {
    Y.apply(this, arguments)
  }

  function ba() {
    aa.apply(this, arguments), this.pX = null, this.pY = null
  }

  function ca() {
    aa.apply(this, arguments)
  }

  function da() {
    Y.apply(this, arguments), this._timer = null, this._input = null
  }

  function ea() {
    aa.apply(this, arguments)
  }

  function fa() {
    aa.apply(this, arguments)
  }

  function ga() {
    Y.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0
  }

  function ha(a, b) {
    return b = b || {}, b.recognizers = l(b.recognizers, ha.defaults.preset), new ia(a, b)
  }

  function ia(a, b) {
    this.options = la({}, ha.defaults, b || {}), this.options.inputTarget = this.options.inputTarget || a, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = a, this.input = y(this), this.touchAction = new V(this, this.options.touchAction), ja(this, !0), g(this.options.recognizers, function (a) {
      var b = this.add(new a[0](a[1]));
      a[2] && b.recognizeWith(a[2]), a[3] && b.requireFailure(a[3])
    }, this)
  }

  function ja(a, b) {
    var c = a.element;
    if (c.style) {
      var d;
      g(a.options.cssProps, function (e, f) {
        d = u(c.style, f), b ? (a.oldCssProps[d] = c.style[d], c.style[d] = e) : c.style[d] = a.oldCssProps[d] || ""
      }), b || (a.oldCssProps = {})
    }
  }

  function ka(a, c) {
    var d = b.createEvent("Event");
    d.initEvent(a, !0, !0), d.gesture = c, c.target.dispatchEvent(d)
  }
  var la, ma = ["", "webkit", "Moz", "MS", "ms", "o"],
    na = b.createElement("div"),
    oa = "function",
    pa = Math.round,
    qa = Math.abs,
    ra = Date.now;
  la = "function" != typeof Object.assign ? function (a) {
    if (a === d || null === a) throw new TypeError("Cannot convert undefined or null to object");
    for (var b = Object(a), c = 1; c < arguments.length; c++) {
      var e = arguments[c];
      if (e !== d && null !== e)
        for (var f in e) e.hasOwnProperty(f) && (b[f] = e[f])
    }
    return b
  } : Object.assign;
  var sa = h(function (a, b, c) {
      for (var e = Object.keys(b), f = 0; f < e.length;)(!c || c && a[e[f]] === d) && (a[e[f]] = b[e[f]]), f++;
      return a
    }, "extend", "Use `assign`."),
    ta = h(function (a, b) {
      return sa(a, b, !0)
    }, "merge", "Use `assign`."),
    ua = 1,
    va = /mobile|tablet|ip(ad|hone|od)|android/i,
    wa = "ontouchstart" in a,
    xa = u(a, "PointerEvent") !== d,
    ya = wa && va.test(navigator.userAgent),
    za = "touch",
    Aa = "pen",
    Ba = "mouse",
    Ca = "kinect",
    Da = 25,
    Ea = 1,
    Fa = 2,
    Ga = 4,
    Ha = 8,
    Ia = 1,
    Ja = 2,
    Ka = 4,
    La = 8,
    Ma = 16,
    Na = Ja | Ka,
    Oa = La | Ma,
    Pa = Na | Oa,
    Qa = ["x", "y"],
    Ra = ["clientX", "clientY"];
  x.prototype = {
    handler: function () {},
    init: function () {
      this.evEl && m(this.element, this.evEl, this.domHandler), this.evTarget && m(this.target, this.evTarget, this.domHandler), this.evWin && m(w(this.element), this.evWin, this.domHandler)
    },
    destroy: function () {
      this.evEl && n(this.element, this.evEl, this.domHandler), this.evTarget && n(this.target, this.evTarget, this.domHandler), this.evWin && n(w(this.element), this.evWin, this.domHandler)
    }
  };
  var Sa = {
      mousedown: Ea,
      mousemove: Fa,
      mouseup: Ga
    },
    Ta = "mousedown",
    Ua = "mousemove mouseup";
  i(L, x, {
    handler: function (a) {
      var b = Sa[a.type];
      b & Ea && 0 === a.button && (this.pressed = !0), b & Fa && 1 !== a.which && (b = Ga), this.pressed && (b & Ga && (this.pressed = !1), this.callback(this.manager, b, {
        pointers: [a],
        changedPointers: [a],
        pointerType: Ba,
        srcEvent: a
      }))
    }
  });
  var Va = {
      pointerdown: Ea,
      pointermove: Fa,
      pointerup: Ga,
      pointercancel: Ha,
      pointerout: Ha
    },
    Wa = {
      2: za,
      3: Aa,
      4: Ba,
      5: Ca
    },
    Xa = "pointerdown",
    Ya = "pointermove pointerup pointercancel";
  a.MSPointerEvent && !a.PointerEvent && (Xa = "MSPointerDown", Ya = "MSPointerMove MSPointerUp MSPointerCancel"), i(M, x, {
    handler: function (a) {
      var b = this.store,
        c = !1,
        d = a.type.toLowerCase().replace("ms", ""),
        e = Va[d],
        f = Wa[a.pointerType] || a.pointerType,
        g = f == za,
        h = r(b, a.pointerId, "pointerId");
      e & Ea && (0 === a.button || g) ? 0 > h && (b.push(a), h = b.length - 1) : e & (Ga | Ha) && (c = !0), 0 > h || (b[h] = a, this.callback(this.manager, e, {
        pointers: b,
        changedPointers: [a],
        pointerType: f,
        srcEvent: a
      }), c && b.splice(h, 1))
    }
  });
  var Za = {
      touchstart: Ea,
      touchmove: Fa,
      touchend: Ga,
      touchcancel: Ha
    },
    $a = "touchstart",
    _a = "touchstart touchmove touchend touchcancel";
  i(N, x, {
    handler: function (a) {
      var b = Za[a.type];
      if (b === Ea && (this.started = !0), this.started) {
        var c = O.call(this, a, b);
        b & (Ga | Ha) && c[0].length - c[1].length === 0 && (this.started = !1), this.callback(this.manager, b, {
          pointers: c[0],
          changedPointers: c[1],
          pointerType: za,
          srcEvent: a
        })
      }
    }
  });
  var ab = {
      touchstart: Ea,
      touchmove: Fa,
      touchend: Ga,
      touchcancel: Ha
    },
    bb = "touchstart touchmove touchend touchcancel";
  i(P, x, {
    handler: function (a) {
      var b = ab[a.type],
        c = Q.call(this, a, b);
      c && this.callback(this.manager, b, {
        pointers: c[0],
        changedPointers: c[1],
        pointerType: za,
        srcEvent: a
      })
    }
  });
  var cb = 2500,
    db = 25;
  i(R, x, {
    handler: function (a, b, c) {
      var d = c.pointerType == za,
        e = c.pointerType == Ba;
      if (!(e && c.sourceCapabilities && c.sourceCapabilities.firesTouchEvents)) {
        if (d) S.call(this, b, c);
        else if (e && U.call(this, c)) return;
        this.callback(a, b, c)
      }
    },
    destroy: function () {
      this.touch.destroy(), this.mouse.destroy()
    }
  });
  var eb = u(na.style, "touchAction"),
    fb = eb !== d,
    gb = "compute",
    hb = "auto",
    ib = "manipulation",
    jb = "none",
    kb = "pan-x",
    lb = "pan-y",
    mb = X();
  V.prototype = {
    set: function (a) {
      a == gb && (a = this.compute()), fb && this.manager.element.style && mb[a] && (this.manager.element.style[eb] = a), this.actions = a.toLowerCase().trim()
    },
    update: function () {
      this.set(this.manager.options.touchAction)
    },
    compute: function () {
      var a = [];
      return g(this.manager.recognizers, function (b) {
        k(b.options.enable, [b]) && (a = a.concat(b.getTouchAction()))
      }), W(a.join(" "))
    },
    preventDefaults: function (a) {
      var b = a.srcEvent,
        c = a.offsetDirection;
      if (this.manager.session.prevented) return void b.preventDefault();
      var d = this.actions,
        e = p(d, jb) && !mb[jb],
        f = p(d, lb) && !mb[lb],
        g = p(d, kb) && !mb[kb];
      if (e) {
        var h = 1 === a.pointers.length,
          i = a.distance < 2,
          j = a.deltaTime < 250;
        if (h && i && j) return
      }
      return g && f ? void 0 : e || f && c & Na || g && c & Oa ? this.preventSrc(b) : void 0
    },
    preventSrc: function (a) {
      this.manager.session.prevented = !0, a.preventDefault()
    }
  };
  var nb = 1,
    ob = 2,
    pb = 4,
    qb = 8,
    rb = qb,
    sb = 16,
    tb = 32;
  Y.prototype = {
    defaults: {},
    set: function (a) {
      return la(this.options, a), this.manager && this.manager.touchAction.update(), this
    },
    recognizeWith: function (a) {
      if (f(a, "recognizeWith", this)) return this;
      var b = this.simultaneous;
      return a = _(a, this), b[a.id] || (b[a.id] = a, a.recognizeWith(this)), this
    },
    dropRecognizeWith: function (a) {
      return f(a, "dropRecognizeWith", this) ? this : (a = _(a, this), delete this.simultaneous[a.id], this)
    },
    requireFailure: function (a) {
      if (f(a, "requireFailure", this)) return this;
      var b = this.requireFail;
      return a = _(a, this), -1 === r(b, a) && (b.push(a), a.requireFailure(this)), this
    },
    dropRequireFailure: function (a) {
      if (f(a, "dropRequireFailure", this)) return this;
      a = _(a, this);
      var b = r(this.requireFail, a);
      return b > -1 && this.requireFail.splice(b, 1), this
    },
    hasRequireFailures: function () {
      return this.requireFail.length > 0
    },
    canRecognizeWith: function (a) {
      return !!this.simultaneous[a.id]
    },
    emit: function (a) {
      function b(b) {
        c.manager.emit(b, a)
      }
      var c = this,
        d = this.state;
      qb > d && b(c.options.event + Z(d)), b(c.options.event), a.additionalEvent && b(a.additionalEvent), d >= qb && b(c.options.event + Z(d))
    },
    tryEmit: function (a) {
      return this.canEmit() ? this.emit(a) : void(this.state = tb)
    },
    canEmit: function () {
      for (var a = 0; a < this.requireFail.length;) {
        if (!(this.requireFail[a].state & (tb | nb))) return !1;
        a++
      }
      return !0
    },
    recognize: function (a) {
      var b = la({}, a);
      return k(this.options.enable, [this, b]) ? (this.state & (rb | sb | tb) && (this.state = nb), this.state = this.process(b), void(this.state & (ob | pb | qb | sb) && this.tryEmit(b))) : (this.reset(), void(this.state = tb))
    },
    process: function (a) {},
    getTouchAction: function () {},
    reset: function () {}
  }, i(aa, Y, {
    defaults: {
      pointers: 1
    },
    attrTest: function (a) {
      var b = this.options.pointers;
      return 0 === b || a.pointers.length === b
    },
    process: function (a) {
      var b = this.state,
        c = a.eventType,
        d = b & (ob | pb),
        e = this.attrTest(a);
      return d && (c & Ha || !e) ? b | sb : d || e ? c & Ga ? b | qb : b & ob ? b | pb : ob : tb
    }
  }), i(ba, aa, {
    defaults: {
      event: "pan",
      threshold: 10,
      pointers: 1,
      direction: Pa
    },
    getTouchAction: function () {
      var a = this.options.direction,
        b = [];
      return a & Na && b.push(lb), a & Oa && b.push(kb), b
    },
    directionTest: function (a) {
      var b = this.options,
        c = !0,
        d = a.distance,
        e = a.direction,
        f = a.deltaX,
        g = a.deltaY;
      return e & b.direction || (b.direction & Na ? (e = 0 === f ? Ia : 0 > f ? Ja : Ka, c = f != this.pX, d = Math.abs(a.deltaX)) : (e = 0 === g ? Ia : 0 > g ? La : Ma, c = g != this.pY, d = Math.abs(a.deltaY))), a.direction = e, c && d > b.threshold && e & b.direction
    },
    attrTest: function (a) {
      return aa.prototype.attrTest.call(this, a) && (this.state & ob || !(this.state & ob) && this.directionTest(a))
    },
    emit: function (a) {
      this.pX = a.deltaX, this.pY = a.deltaY;
      var b = $(a.direction);
      b && (a.additionalEvent = this.options.event + b), this._super.emit.call(this, a)
    }
  }), i(ca, aa, {
    defaults: {
      event: "pinch",
      threshold: 0,
      pointers: 2
    },
    getTouchAction: function () {
      return [jb]
    },
    attrTest: function (a) {
      return this._super.attrTest.call(this, a) && (Math.abs(a.scale - 1) > this.options.threshold || this.state & ob)
    },
    emit: function (a) {
      if (1 !== a.scale) {
        var b = a.scale < 1 ? "in" : "out";
        a.additionalEvent = this.options.event + b
      }
      this._super.emit.call(this, a)
    }
  }), i(da, Y, {
    defaults: {
      event: "press",
      pointers: 1,
      time: 251,
      threshold: 9
    },
    getTouchAction: function () {
      return [hb]
    },
    process: function (a) {
      var b = this.options,
        c = a.pointers.length === b.pointers,
        d = a.distance < b.threshold,
        f = a.deltaTime > b.time;
      if (this._input = a, !d || !c || a.eventType & (Ga | Ha) && !f) this.reset();
      else if (a.eventType & Ea) this.reset(), this._timer = e(function () {
        this.state = rb, this.tryEmit()
      }, b.time, this);
      else if (a.eventType & Ga) return rb;
      return tb
    },
    reset: function () {
      clearTimeout(this._timer)
    },
    emit: function (a) {
      this.state === rb && (a && a.eventType & Ga ? this.manager.emit(this.options.event + "up", a) : (this._input.timeStamp = ra(), this.manager.emit(this.options.event, this._input)))
    }
  }), i(ea, aa, {
    defaults: {
      event: "rotate",
      threshold: 0,
      pointers: 2
    },
    getTouchAction: function () {
      return [jb]
    },
    attrTest: function (a) {
      return this._super.attrTest.call(this, a) && (Math.abs(a.rotation) > this.options.threshold || this.state & ob)
    }
  }), i(fa, aa, {
    defaults: {
      event: "swipe",
      threshold: 10,
      velocity: .3,
      direction: Na | Oa,
      pointers: 1
    },
    getTouchAction: function () {
      return ba.prototype.getTouchAction.call(this)
    },
    attrTest: function (a) {
      var b, c = this.options.direction;
      return c & (Na | Oa) ? b = a.overallVelocity : c & Na ? b = a.overallVelocityX : c & Oa && (b = a.overallVelocityY), this._super.attrTest.call(this, a) && c & a.offsetDirection && a.distance > this.options.threshold && a.maxPointers == this.options.pointers && qa(b) > this.options.velocity && a.eventType & Ga
    },
    emit: function (a) {
      var b = $(a.offsetDirection);
      b && this.manager.emit(this.options.event + b, a), this.manager.emit(this.options.event, a)
    }
  }), i(ga, Y, {
    defaults: {
      event: "tap",
      pointers: 1,
      taps: 1,
      interval: 300,
      time: 250,
      threshold: 9,
      posThreshold: 10
    },
    getTouchAction: function () {
      return [ib]
    },
    process: function (a) {
      var b = this.options,
        c = a.pointers.length === b.pointers,
        d = a.distance < b.threshold,
        f = a.deltaTime < b.time;
      if (this.reset(), a.eventType & Ea && 0 === this.count) return this.failTimeout();
      if (d && f && c) {
        if (a.eventType != Ga) return this.failTimeout();
        var g = this.pTime ? a.timeStamp - this.pTime < b.interval : !0,
          h = !this.pCenter || H(this.pCenter, a.center) < b.posThreshold;
        this.pTime = a.timeStamp, this.pCenter = a.center, h && g ? this.count += 1 : this.count = 1, this._input = a;
        var i = this.count % b.taps;
        if (0 === i) return this.hasRequireFailures() ? (this._timer = e(function () {
          this.state = rb, this.tryEmit()
        }, b.interval, this), ob) : rb
      }
      return tb
    },
    failTimeout: function () {
      return this._timer = e(function () {
        this.state = tb
      }, this.options.interval, this), tb
    },
    reset: function () {
      clearTimeout(this._timer)
    },
    emit: function () {
      this.state == rb && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input))
    }
  }), ha.VERSION = "2.0.8", ha.defaults = {
    domEvents: !1,
    touchAction: gb,
    enable: !0,
    inputTarget: null,
    inputClass: null,
    preset: [
      [ea, {
        enable: !1
      }],
      [ca, {
          enable: !1
        },
        ["rotate"]
      ],
      [fa, {
        direction: Na
      }],
      [ba, {
          direction: Na
        },
        ["swipe"]
      ],
      [ga],
      [ga, {
          event: "doubletap",
          taps: 2
        },
        ["tap"]
      ],
      [da]
    ],
    cssProps: {
      userSelect: "none",
      touchSelect: "none",
      touchCallout: "none",
      contentZooming: "none",
      userDrag: "none",
      tapHighlightColor: "rgba(0,0,0,0)"
    }
  };
  var ub = 1,
    vb = 2;
  ia.prototype = {
    set: function (a) {
      return la(this.options, a), a.touchAction && this.touchAction.update(), a.inputTarget && (this.input.destroy(), this.input.target = a.inputTarget, this.input.init()), this
    },
    stop: function (a) {
      this.session.stopped = a ? vb : ub
    },
    recognize: function (a) {
      var b = this.session;
      if (!b.stopped) {
        this.touchAction.preventDefaults(a);
        var c, d = this.recognizers,
          e = b.curRecognizer;
        (!e || e && e.state & rb) && (e = b.curRecognizer = null);
        for (var f = 0; f < d.length;) c = d[f], b.stopped === vb || e && c != e && !c.canRecognizeWith(e) ? c.reset() : c.recognize(a), !e && c.state & (ob | pb | qb) && (e = b.curRecognizer = c), f++
      }
    },
    get: function (a) {
      if (a instanceof Y) return a;
      for (var b = this.recognizers, c = 0; c < b.length; c++)
        if (b[c].options.event == a) return b[c];
      return null
    },
    add: function (a) {
      if (f(a, "add", this)) return this;
      var b = this.get(a.options.event);
      return b && this.remove(b), this.recognizers.push(a), a.manager = this, this.touchAction.update(), a
    },
    remove: function (a) {
      if (f(a, "remove", this)) return this;
      if (a = this.get(a)) {
        var b = this.recognizers,
          c = r(b, a); - 1 !== c && (b.splice(c, 1), this.touchAction.update())
      }
      return this
    },
    on: function (a, b) {
      if (a !== d && b !== d) {
        var c = this.handlers;
        return g(q(a), function (a) {
          c[a] = c[a] || [], c[a].push(b)
        }), this
      }
    },
    off: function (a, b) {
      if (a !== d) {
        var c = this.handlers;
        return g(q(a), function (a) {
          b ? c[a] && c[a].splice(r(c[a], b), 1) : delete c[a]
        }), this
      }
    },
    emit: function (a, b) {
      this.options.domEvents && ka(a, b);
      var c = this.handlers[a] && this.handlers[a].slice();
      if (c && c.length) {
        b.type = a, b.preventDefault = function () {
          b.srcEvent.preventDefault()
        };
        for (var d = 0; d < c.length;) c[d](b), d++
      }
    },
    destroy: function () {
      this.element && ja(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null
    }
  }, la(ha, {
    INPUT_START: Ea,
    INPUT_MOVE: Fa,
    INPUT_END: Ga,
    INPUT_CANCEL: Ha,
    STATE_POSSIBLE: nb,
    STATE_BEGAN: ob,
    STATE_CHANGED: pb,
    STATE_ENDED: qb,
    STATE_RECOGNIZED: rb,
    STATE_CANCELLED: sb,
    STATE_FAILED: tb,
    DIRECTION_NONE: Ia,
    DIRECTION_LEFT: Ja,
    DIRECTION_RIGHT: Ka,
    DIRECTION_UP: La,
    DIRECTION_DOWN: Ma,
    DIRECTION_HORIZONTAL: Na,
    DIRECTION_VERTICAL: Oa,
    DIRECTION_ALL: Pa,
    Manager: ia,
    Input: x,
    TouchAction: V,
    TouchInput: P,
    MouseInput: L,
    PointerEventInput: M,
    TouchMouseInput: R,
    SingleTouchInput: N,
    Recognizer: Y,
    AttrRecognizer: aa,
    Tap: ga,
    Pan: ba,
    Swipe: fa,
    Pinch: ca,
    Rotate: ea,
    Press: da,
    on: m,
    off: n,
    each: g,
    merge: ta,
    extend: sa,
    assign: la,
    inherit: i,
    bindFn: j,
    prefixed: u
  });
  var wb = "undefined" != typeof a ? a : "undefined" != typeof self ? self : {};
  wb.Hammer = ha, "function" == typeof define && define.amd ? define(function () {
    return ha
  }) : "undefined" != typeof module && module.exports ? module.exports = ha : a[c] = ha
}(window, document, "Hammer");

/*!
 * chartjs-plugin-zoom v1.2.1
 * undefined
 * (c) 2016-2022 chartjs-plugin-zoom Contributors
 * Released under the MIT License
 */
! function (e, n) {
  "object" == typeof exports && "undefined" != typeof module ? module.exports = n(require("chart.js"), require("hammerjs"), require("chart.js/helpers")) : "function" == typeof define && define.amd ? define(["chart.js", "hammerjs", "chart.js/helpers"], n) : (e = "undefined" != typeof globalThis ? globalThis : e || self).ChartZoom = n(e.Chart, e.Hammer, e.Chart.helpers)
}(this, (function (e, n, t) {
  "use strict";

  function o(e) {
    return e && "object" == typeof e && "default" in e ? e : {
      default: e
    }
  }
  var a = o(n);
  const i = e => e && e.enabled && e.modifierKey,
    c = (e, n) => e && n[e + "Key"],
    r = (e, n) => e && !n[e + "Key"];

  function l(e, n, t) {
    return void 0 === e || ("string" == typeof e ? -1 !== e.indexOf(n) : "function" == typeof e && -1 !== e({
      chart: t
    }).indexOf(n))
  }

  function s(e, n, o) {
    const a = function ({
      x: e,
      y: n
    }, t) {
      const o = t.scales,
        a = Object.keys(o);
      for (let t = 0; t < a.length; t++) {
        const i = o[a[t]];
        if (n >= i.top && n <= i.bottom && e >= i.left && e <= i.right) return i
      }
      return null
    }(n, o);
    if (a && l(e, a.axis, o)) return [a];
    const i = [];
    return t.each(o.scales, (function (n) {
      l(e, n.axis, o) || i.push(n)
    })), i
  }
  const m = new WeakMap;

  function u(e) {
    let n = m.get(e);
    return n || (n = {
      originalScaleLimits: {},
      updatedScaleLimits: {},
      handlers: {},
      panDelta: {}
    }, m.set(e, n)), n
  }

  function d(e, n, t) {
    const o = e.max - e.min,
      a = o * (n - 1),
      i = e.isHorizontal() ? t.x : t.y,
      c = Math.max(0, Math.min(1, (e.getValueForPixel(i) - e.min) / o || 0));
    return {
      min: a * c,
      max: a * (1 - c)
    }
  }

  function f(e, n, o, a, i) {
    let c = o[a];
    if ("original" === c) {
      const o = e.originalScaleLimits[n.id][a];
      c = t.valueOrDefault(o.options, o.scale)
    }
    return t.valueOrDefault(c, i)
  }

  function h(e, {
    min: n,
    max: t
  }, o, a = !1) {
    const i = u(e.chart),
      {
        id: c,
        axis: r,
        options: l
      } = e,
      s = o && (o[c] || o[r]) || {},
      {
        minRange: m = 0
      } = s,
      d = f(i, e, s, "min", -1 / 0),
      h = f(i, e, s, "max", 1 / 0),
      p = Math.max(n, d),
      x = Math.min(t, h),
      g = a ? Math.max(x - p, m) : e.max - e.min;
    if (x - p !== g)
      if (d > x - g) n = p, t = p + g;
      else if (h < p + g) t = x, n = x - g;
    else {
      const e = (g - x + p) / 2;
      n = p - e, t = x + e
    } else n = p, t = x;
    return l.min = n, l.max = t, i.updatedScaleLimits[e.id] = {
      min: n,
      max: t
    }, e.parse(n) !== e.min || e.parse(t) !== e.max
  }
  const p = e => 0 === e || isNaN(e) ? 0 : e < 0 ? Math.min(Math.round(e), -1) : Math.max(Math.round(e), 1);
  const x = {
    second: 500,
    minute: 3e4,
    hour: 18e5,
    day: 432e5,
    week: 3024e5,
    month: 1296e6,
    quarter: 5184e6,
    year: 157248e5
  };

  function g(e, n, t, o = !1) {
    const {
      min: a,
      max: i,
      options: c
    } = e, r = c.time && c.time.round, l = x[r] || 0, s = e.getValueForPixel(e.getPixelForValue(a + l) - n), m = e.getValueForPixel(e.getPixelForValue(i + l) - n), {
      min: u = -1 / 0,
      max: d = 1 / 0
    } = o && t && t[e.axis] || {};
    return !!(isNaN(s) || isNaN(m) || s < u || m > d) || h(e, {
      min: s,
      max: m
    }, t, o)
  }

  function b(e, n, t) {
    return g(e, n, t, !0)
  }
  const y = {
      category: function (e, n, t, o) {
        const a = d(e, n, t);
        return e.min === e.max && n < 1 && function (e) {
          const n = e.getLabels().length - 1;
          e.min > 0 && (e.min -= 1), e.max < n && (e.max += 1)
        }(e), h(e, {
          min: e.min + p(a.min),
          max: e.max - p(a.max)
        }, o, !0)
      },
      default: function (e, n, t, o) {
        const a = d(e, n, t);
        return h(e, {
          min: e.min + a.min,
          max: e.max - a.max
        }, o, !0)
      }
    },
    v = {
      category: function (e, n, t) {
        const o = e.getLabels().length - 1;
        let {
          min: a,
          max: i
        } = e;
        const c = Math.max(i - a, 1),
          r = Math.round(function (e) {
            return e.isHorizontal() ? e.width : e.height
          }(e) / Math.max(c, 10)),
          l = Math.round(Math.abs(n / r));
        let s;
        return n < -r ? (i = Math.min(i + l, o), a = 1 === c ? i : i - c, s = i === o) : n > r && (a = Math.max(0, a - l), i = 1 === c ? a : a + c, s = 0 === a), h(e, {
          min: a,
          max: i
        }, t) || s
      },
      default: g,
      logarithmic: b,
      timeseries: b
    };

  function z(e, n) {
    t.each(e, ((t, o) => {
      n[o] || delete e[o]
    }))
  }

  function M(e, n) {
    const {
      scales: o
    } = e, {
      originalScaleLimits: a,
      updatedScaleLimits: i
    } = n;
    return t.each(o, (function (e) {
      (function (e, n, t) {
        const {
          id: o,
          options: {
            min: a,
            max: i
          }
        } = e;
        if (!n[o] || !t[o]) return !0;
        const c = t[o];
        return c.min !== a || c.max !== i
      })(e, a, i) && (a[e.id] = {
        min: {
          scale: e.min,
          options: e.options.min
        },
        max: {
          scale: e.max,
          options: e.options.max
        }
      })
    })), z(a, o), z(i, o), a
  }

  function k(e, n, o, a) {
    const i = y[e.type] || y.default;
    t.callback(i, [e, n, o, a])
  }

  function w(e) {
    const n = e.chartArea;
    return {
      x: (n.left + n.right) / 2,
      y: (n.top + n.bottom) / 2
    }
  }

  function S(e, n, o = "none") {
    const {
      x: a = 1,
      y: i = 1,
      focalPoint: c = w(e)
    } = "number" == typeof n ? {
      x: n,
      y: n
    } : n, r = u(e), {
      options: {
        limits: m,
        zoom: d
      }
    } = r, {
      mode: f = "xy",
      overScaleMode: h
    } = d || {};
    M(e, r);
    const p = 1 !== a && l(f, "x", e),
      x = 1 !== i && l(f, "y", e),
      g = h && s(h, c, e);
    t.each(g || e.scales, (function (e) {
      e.isHorizontal() && p ? k(e, a, c, m) : !e.isHorizontal() && x && k(e, i, c, m)
    })), e.update(o), t.callback(d.onZoom, [{
      chart: e
    }])
  }

  function P(e, n, t) {
    const o = e.getValueForPixel(n),
      a = e.getValueForPixel(t);
    return {
      min: Math.min(o, a),
      max: Math.max(o, a)
    }
  }

  function C(e) {
    const n = u(e);
    let o = 1,
      a = 1;
    return t.each(e.scales, (function (e) {
      const i = function (e, n) {
        const o = e.originalScaleLimits[n];
        if (!o) return;
        const {
          min: a,
          max: i
        } = o;
        return t.valueOrDefault(i.options, i.scale) - t.valueOrDefault(a.options, a.scale)
      }(n, e.id);
      if (i) {
        const n = Math.round(i / (e.max - e.min) * 100) / 100;
        o = Math.min(o, n), a = Math.max(a, n)
      }
    })), o < 1 ? o : a
  }

  function j(e, n, o, a) {
    const {
      panDelta: i
    } = a, c = i[e.id] || 0;
    t.sign(c) === t.sign(n) && (n += c);
    const r = v[e.type] || v.default;
    t.callback(r, [e, n, o]) ? i[e.id] = 0 : i[e.id] = n
  }

  function Z(e, n, o, a = "none") {
    const {
      x: i = 0,
      y: c = 0
    } = "number" == typeof n ? {
      x: n,
      y: n
    } : n, r = u(e), {
      options: {
        pan: s,
        limits: m
      }
    } = r, {
      mode: d = "xy",
      onPan: f
    } = s || {};
    M(e, r);
    const h = 0 !== i && l(d, "x", e),
      p = 0 !== c && l(d, "y", e);
    t.each(o || e.scales, (function (e) {
      e.isHorizontal() && h ? j(e, i, m, r) : !e.isHorizontal() && p && j(e, c, m, r)
    })), e.update(a), t.callback(f, [{
      chart: e
    }])
  }

  function L(e) {
    const n = u(e),
      t = {};
    for (const o of Object.keys(e.scales)) {
      const {
        min: e,
        max: a
      } = n.originalScaleLimits[o] || {
        min: {},
        max: {}
      };
      t[o] = {
        min: e.scale,
        max: a.scale
      }
    }
    return t
  }

  function R(e, n) {
    const {
      handlers: t
    } = u(e), o = t[n];
    o && o.target && (o.target.removeEventListener(n, o), delete t[n])
  }

  function Y(e, n, t, o) {
    const {
      handlers: a,
      options: i
    } = u(e), c = a[t];
    c && c.target === n || (R(e, t), a[t] = n => o(e, n, i), a[t].target = n, n.addEventListener(t, a[t]))
  }

  function O(e, n) {
    const t = u(e);
    t.dragStart && (t.dragging = !0, t.dragEnd = n, e.update("none"))
  }

  function T(e, n, o) {
    const {
      onZoomStart: a,
      onZoomRejected: i
    } = o;
    if (a) {
      const {
        left: o,
        top: c
      } = n.target.getBoundingClientRect(), r = {
        x: n.clientX - o,
        y: n.clientY - c
      };
      if (!1 === t.callback(a, [{
          chart: e,
          event: n,
          point: r
        }])) return t.callback(i, [{
        chart: e,
        event: n
      }]), !1
    }
  }

  function X(e, n) {
    const o = u(e),
      {
        pan: a,
        zoom: l = {}
      } = o.options;
    if (c(i(a), n) || r(i(l.drag), n)) return t.callback(l.onZoomRejected, [{
      chart: e,
      event: n
    }]);
    !1 !== T(e, n, l) && (o.dragStart = n, Y(e, e.canvas, "mousemove", O))
  }

  function D(e, n, t, o) {
    const {
      left: a,
      top: i
    } = t.target.getBoundingClientRect(), c = l(n, "x", e), r = l(n, "y", e);
    let {
      top: s,
      left: m,
      right: u,
      bottom: d,
      width: f,
      height: h
    } = e.chartArea;
    c && (m = Math.min(t.clientX, o.clientX) - a, u = Math.max(t.clientX, o.clientX) - a), r && (s = Math.min(t.clientY, o.clientY) - i, d = Math.max(t.clientY, o.clientY) - i);
    const p = u - m,
      x = d - s;
    return {
      left: m,
      top: s,
      right: u,
      bottom: d,
      width: p,
      height: x,
      zoomX: c && p ? 1 + (f - p) / f : 1,
      zoomY: r && x ? 1 + (h - x) / h : 1
    }
  }

  function E(e, n) {
    const o = u(e);
    if (!o.dragStart) return;
    R(e, "mousemove");
    const {
      mode: a,
      onZoomComplete: i,
      drag: {
        threshold: c = 0
      }
    } = o.options.zoom, r = D(e, a, o.dragStart, n), s = l(a, "x", e) ? r.width : 0, m = l(a, "y", e) ? r.height : 0, d = Math.sqrt(s * s + m * m);
    if (o.dragStart = o.dragEnd = null, d <= c) return o.dragging = !1, void e.update("none");
    ! function (e, n, o, a = "none") {
      const i = u(e),
        {
          options: {
            limits: c,
            zoom: r
          }
        } = i,
        {
          mode: s = "xy"
        } = r;
      M(e, i);
      const m = l(s, "x", e),
        d = l(s, "y", e);
      t.each(e.scales, (function (e) {
        e.isHorizontal() && m ? h(e, P(e, n.x, o.x), c, !0) : !e.isHorizontal() && d && h(e, P(e, n.y, o.y), c, !0)
      })), e.update(a), t.callback(r.onZoom, [{
        chart: e
      }])
    }(e, {
      x: r.left,
      y: r.top
    }, {
      x: r.right,
      y: r.bottom
    }, "zoom"), setTimeout((() => o.dragging = !1), 500), t.callback(i, [{
      chart: e
    }])
  }

  function F(e, n) {
    const {
      handlers: {
        onZoomComplete: o
      },
      options: {
        zoom: a
      }
    } = u(e);
    if (! function (e, n, o) {
        if (r(i(o.wheel), n)) t.callback(o.onZoomRejected, [{
          chart: e,
          event: n
        }]);
        else if (!1 !== T(e, n, o) && (n.cancelable && n.preventDefault(), void 0 !== n.deltaY)) return !0
      }(e, n, a)) return;
    const c = n.target.getBoundingClientRect(),
      l = 1 + (n.deltaY >= 0 ? -a.wheel.speed : a.wheel.speed);
    S(e, {
      x: l,
      y: l,
      focalPoint: {
        x: n.clientX - c.left,
        y: n.clientY - c.top
      }
    }), o && o()
  }

  function H(e, n, o, a) {
    o && (u(e).handlers[n] = function (e, n) {
      let t;
      return function () {
        return clearTimeout(t), t = setTimeout(e, n), n
      }
    }((() => t.callback(o, [{
      chart: e
    }])), a))
  }

  function V(e, n) {
    return function (o, a) {
      const {
        pan: l,
        zoom: s = {}
      } = n.options;
      if (!l || !l.enabled) return !1;
      const m = a && a.srcEvent;
      return !m || (!(!n.panning && "mouse" === a.pointerType && (r(i(l), m) || c(i(s.drag), m))) || (t.callback(l.onPanRejected, [{
        chart: e,
        event: a
      }]), !1))
    }
  }

  function B(e, n, t) {
    if (n.scale) {
      const {
        center: o,
        pointers: a
      } = t, i = 1 / n.scale * t.scale, c = t.target.getBoundingClientRect(), r = function (e, n) {
        const t = Math.abs(e.clientX - n.clientX),
          o = Math.abs(e.clientY - n.clientY),
          a = t / o;
        let i, c;
        return a > .3 && a < 1.7 ? i = c = !0 : t > o ? i = !0 : c = !0, {
          x: i,
          y: c
        }
      }(a[0], a[1]), s = n.options.zoom.mode;
      S(e, {
        x: r.x && l(s, "x", e) ? i : 1,
        y: r.y && l(s, "y", e) ? i : 1,
        focalPoint: {
          x: o.x - c.left,
          y: o.y - c.top
        }
      }), n.scale = t.scale
    }
  }

  function K(e, n, t) {
    const o = n.delta;
    o && (n.panning = !0, Z(e, {
      x: t.deltaX - o.x,
      y: t.deltaY - o.y
    }, n.panScales), n.delta = {
      x: t.deltaX,
      y: t.deltaY
    })
  }
  const N = new WeakMap;

  function q(e, n) {
    const o = u(e),
      i = e.canvas,
      {
        pan: c,
        zoom: r
      } = n,
      l = new a.default.Manager(i);
    r && r.pinch.enabled && (l.add(new a.default.Pinch), l.on("pinchstart", (() => function (e, n) {
      n.options.zoom.pinch.enabled && (n.scale = 1)
    }(0, o))), l.on("pinch", (n => B(e, o, n))), l.on("pinchend", (n => function (e, n, o) {
      n.scale && (B(e, n, o), n.scale = null, t.callback(n.options.zoom.onZoomComplete, [{
        chart: e
      }]))
    }(e, o, n)))), c && c.enabled && (l.add(new a.default.Pan({
      threshold: c.threshold,
      enable: V(e, o)
    })), l.on("panstart", (n => function (e, n, o) {
      const {
        enabled: a,
        overScaleMode: i,
        onPanStart: c,
        onPanRejected: r
      } = n.options.pan;
      if (!a) return;
      const l = o.target.getBoundingClientRect(),
        m = {
          x: o.center.x - l.left,
          y: o.center.y - l.top
        };
      if (!1 === t.callback(c, [{
          chart: e,
          event: o,
          point: m
        }])) return t.callback(r, [{
        chart: e,
        event: o
      }]);
      n.panScales = i && s(i, m, e), n.delta = {
        x: 0,
        y: 0
      }, clearTimeout(n.panEndTimeout), K(e, n, o)
    }(e, o, n))), l.on("panmove", (n => K(e, o, n))), l.on("panend", (() => function (e, n) {
      n.delta = null, n.panning && (n.panEndTimeout = setTimeout((() => n.panning = !1), 500), t.callback(n.options.pan.onPanComplete, [{
        chart: e
      }]))
    }(e, o)))), N.set(e, l)
  }
  var W = {
    id: "zoom",
    version: "1.2.1",
    defaults: {
      pan: {
        enabled: !1,
        mode: "xy",
        threshold: 10,
        modifierKey: null
      },
      zoom: {
        wheel: {
          enabled: !1,
          speed: .1,
          modifierKey: null
        },
        drag: {
          enabled: !1,
          modifierKey: null
        },
        pinch: {
          enabled: !1
        },
        mode: "xy"
      }
    },
    start: function (e, n, o) {
      u(e).options = o, Object.prototype.hasOwnProperty.call(o.zoom, "enabled") && console.warn("The option `zoom.enabled` is no longer supported. Please use `zoom.wheel.enabled`, `zoom.drag.enabled`, or `zoom.pinch.enabled`."), a.default && q(e, o), e.pan = (n, t, o) => Z(e, n, t, o), e.zoom = (n, t) => S(e, n, t), e.zoomScale = (n, t, o) => function (e, n, t, o = "none") {
        M(e, u(e)), h(e.scales[n], t, void 0, !0), e.update(o)
      }(e, n, t, o), e.resetZoom = n => function (e, n = "default") {
        const o = u(e),
          a = M(e, o);
        t.each(e.scales, (function (e) {
          const n = e.options;
          a[e.id] ? (n.min = a[e.id].min.options, n.max = a[e.id].max.options) : (delete n.min, delete n.max)
        })), e.update(n), t.callback(o.options.zoom.onZoomComplete, [{
          chart: e
        }])
      }(e, n), e.getZoomLevel = () => C(e), e.getInitialScaleBounds = () => L(e), e.isZoomedOrPanned = () => function (e) {
        const n = L(e);
        for (const t of Object.keys(e.scales)) {
          const {
            min: o,
            max: a
          } = n[t];
          if (void 0 !== o && e.scales[t].min !== o) return !0;
          if (void 0 !== a && e.scales[t].max !== a) return !0
        }
        return !1
      }(e)
    },
    beforeEvent(e) {
      const n = u(e);
      if (n.panning || n.dragging) return !1
    },
    beforeUpdate: function (e, n, t) {
      u(e).options = t,
        function (e, n) {
          const t = e.canvas,
            {
              wheel: o,
              drag: a,
              onZoomComplete: i
            } = n.zoom;
          o.enabled ? (Y(e, t, "wheel", F), H(e, "onZoomComplete", i, 250)) : R(e, "wheel"), a.enabled ? (Y(e, t, "mousedown", X), Y(e, t.ownerDocument, "mouseup", E)) : (R(e, "mousedown"), R(e, "mousemove"), R(e, "mouseup"))
        }(e, t)
    },
    beforeDatasetsDraw: function (e, n, t) {
      const {
        dragStart: o,
        dragEnd: a
      } = u(e);
      if (a) {
        const {
          left: n,
          top: i,
          width: c,
          height: r
        } = D(e, t.zoom.mode, o, a), l = t.zoom.drag, s = e.ctx;
        s.save(), s.beginPath(), s.fillStyle = l.backgroundColor || "rgba(225,225,225,0.3)", s.fillRect(n, i, c, r), l.borderWidth > 0 && (s.lineWidth = l.borderWidth, s.strokeStyle = l.borderColor || "rgba(225,225,225)", s.strokeRect(n, i, c, r)), s.restore()
      }
    },
    stop: function (e) {
      ! function (e) {
        R(e, "mousedown"), R(e, "mousemove"), R(e, "mouseup"), R(e, "wheel"), R(e, "click")
      }(e), a.default && function (e) {
          const n = N.get(e);
          n && (n.remove("pinchstart"), n.remove("pinch"), n.remove("pinchend"), n.remove("panstart"), n.remove("pan"), n.remove("panend"), n.destroy(), N.delete(e))
        }(e),
        function (e) {
          m.delete(e)
        }(e)
    },
    panFunctions: v,
    zoomFunctions: y
  };
  return e.Chart.register(W), W
}));

! function (e, t) {
  "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = e || self).GLightbox = t()
}(this, (function () {
  "use strict";

  function e(t) {
    return (e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
      return typeof e
    } : function (e) {
      return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(t)
  }

  function t(e, t) {
    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
  }

  function i(e, t) {
    for (var i = 0; i < t.length; i++) {
      var n = t[i];
      n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
    }
  }

  function n(e, t, n) {
    return t && i(e.prototype, t), n && i(e, n), e
  }
  var s = Date.now();

  function l() {
    var e = {},
      t = !0,
      i = 0,
      n = arguments.length;
    "[object Boolean]" === Object.prototype.toString.call(arguments[0]) && (t = arguments[0], i++);
    for (var s = function (i) {
        for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (t && "[object Object]" === Object.prototype.toString.call(i[n]) ? e[n] = l(!0, e[n], i[n]) : e[n] = i[n])
      }; i < n; i++) {
      var o = arguments[i];
      s(o)
    }
    return e
  }

  function o(e, t) {
    if ((k(e) || e === window || e === document) && (e = [e]), A(e) || L(e) || (e = [e]), 0 != P(e))
      if (A(e) && !L(e))
        for (var i = e.length, n = 0; n < i && !1 !== t.call(e[n], e[n], n, e); n++);
      else if (L(e))
      for (var s in e)
        if (O(e, s) && !1 === t.call(e[s], e[s], s, e)) break
  }

  function r(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
      i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
      n = e[s] = e[s] || [],
      l = {
        all: n,
        evt: null,
        found: null
      };
    return t && i && P(n) > 0 && o(n, (function (e, n) {
      if (e.eventName == t && e.fn.toString() == i.toString()) return l.found = !0, l.evt = n, !1
    })), l
  }

  function a(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
      i = t.onElement,
      n = t.withCallback,
      s = t.avoidDuplicate,
      l = void 0 === s || s,
      a = t.once,
      h = void 0 !== a && a,
      d = t.useCapture,
      c = void 0 !== d && d,
      u = arguments.length > 2 ? arguments[2] : void 0,
      g = i || [];

    function v(e) {
      T(n) && n.call(u, e, this), h && v.destroy()
    }
    return C(g) && (g = document.querySelectorAll(g)), v.destroy = function () {
      o(g, (function (t) {
        var i = r(t, e, v);
        i.found && i.all.splice(i.evt, 1), t.removeEventListener && t.removeEventListener(e, v, c)
      }))
    }, o(g, (function (t) {
      var i = r(t, e, v);
      (t.addEventListener && l && !i.found || !l) && (t.addEventListener(e, v, c), i.all.push({
        eventName: e,
        fn: v
      }))
    })), v
  }

  function h(e, t) {
    o(t.split(" "), (function (t) {
      return e.classList.add(t)
    }))
  }

  function d(e, t) {
    o(t.split(" "), (function (t) {
      return e.classList.remove(t)
    }))
  }

  function c(e, t) {
    return e.classList.contains(t)
  }

  function u(e, t) {
    for (; e !== document.body;) {
      if (!(e = e.parentElement)) return !1;
      if ("function" == typeof e.matches ? e.matches(t) : e.msMatchesSelector(t)) return e
    }
  }

  function g(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "",
      i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    if (!e || "" === t) return !1;
    if ("none" === t) return T(i) && i(), !1;
    var n = x(),
      s = t.split(" ");
    o(s, (function (t) {
      h(e, "g" + t)
    })), a(n, {
      onElement: e,
      avoidDuplicate: !1,
      once: !0,
      withCallback: function (e, t) {
        o(s, (function (e) {
          d(t, "g" + e)
        })), T(i) && i()
      }
    })
  }

  function v(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
    if ("" === t) return e.style.webkitTransform = "", e.style.MozTransform = "", e.style.msTransform = "", e.style.OTransform = "", e.style.transform = "", !1;
    e.style.webkitTransform = t, e.style.MozTransform = t, e.style.msTransform = t, e.style.OTransform = t, e.style.transform = t
  }

  function f(e) {
    e.style.display = "block"
  }

  function p(e) {
    e.style.display = "none"
  }

  function m(e) {
    var t = document.createDocumentFragment(),
      i = document.createElement("div");
    for (i.innerHTML = e; i.firstChild;) t.appendChild(i.firstChild);
    return t
  }

  function y() {
    return {
      width: window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth,
      height: window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight
    }
  }

  function x() {
    var e, t = document.createElement("fakeelement"),
      i = {
        animation: "animationend",
        OAnimation: "oAnimationEnd",
        MozAnimation: "animationend",
        WebkitAnimation: "webkitAnimationEnd"
      };
    for (e in i)
      if (void 0 !== t.style[e]) return i[e]
  }

  function b(e, t, i, n) {
    if (e()) t();
    else {
      var s;
      i || (i = 100);
      var l = setInterval((function () {
        e() && (clearInterval(l), s && clearTimeout(s), t())
      }), i);
      n && (s = setTimeout((function () {
        clearInterval(l)
      }), n))
    }
  }

  function S(e, t, i) {
    if (I(e)) console.error("Inject assets error");
    else if (T(t) && (i = t, t = !1), C(t) && t in window) T(i) && i();
    else {
      var n;
      if (-1 !== e.indexOf(".css")) {
        if ((n = document.querySelectorAll('link[href="' + e + '"]')) && n.length > 0) return void(T(i) && i());
        var s = document.getElementsByTagName("head")[0],
          l = s.querySelectorAll('link[rel="stylesheet"]'),
          o = document.createElement("link");
        return o.rel = "stylesheet", o.type = "text/css", o.href = e, o.media = "all", l ? s.insertBefore(o, l[0]) : s.appendChild(o), void(T(i) && i())
      }
      if ((n = document.querySelectorAll('script[src="' + e + '"]')) && n.length > 0) {
        if (T(i)) {
          if (C(t)) return b((function () {
            return void 0 !== window[t]
          }), (function () {
            i()
          })), !1;
          i()
        }
      } else {
        var r = document.createElement("script");
        r.type = "text/javascript", r.src = e, r.onload = function () {
          if (T(i)) {
            if (C(t)) return b((function () {
              return void 0 !== window[t]
            }), (function () {
              i()
            })), !1;
            i()
          }
        }, document.body.appendChild(r)
      }
    }
  }

  function w() {
    return "navigator" in window && window.navigator.userAgent.match(/(iPad)|(iPhone)|(iPod)|(Android)|(PlayBook)|(BB10)|(BlackBerry)|(Opera Mini)|(IEMobile)|(webOS)|(MeeGo)/i)
  }

  function T(e) {
    return "function" == typeof e
  }

  function C(e) {
    return "string" == typeof e
  }

  function k(e) {
    return !(!e || !e.nodeType || 1 != e.nodeType)
  }

  function E(e) {
    return Array.isArray(e)
  }

  function A(e) {
    return e && e.length && isFinite(e.length)
  }

  function L(t) {
    return "object" === e(t) && null != t && !T(t) && !E(t)
  }

  function I(e) {
    return null == e
  }

  function O(e, t) {
    return null !== e && hasOwnProperty.call(e, t)
  }

  function P(e) {
    if (L(e)) {
      if (e.keys) return e.keys().length;
      var t = 0;
      for (var i in e) O(e, i) && t++;
      return t
    }
    return e.length
  }

  function M(e) {
    return !isNaN(parseFloat(e)) && isFinite(e)
  }

  function z() {
    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : -1,
      t = document.querySelectorAll(".gbtn[data-taborder]:not(.disabled)");
    if (!t.length) return !1;
    if (1 == t.length) return t[0];
    "string" == typeof e && (e = parseInt(e));
    var i = [];
    o(t, (function (e) {
      i.push(e.getAttribute("data-taborder"))
    }));
    var n = Math.max.apply(Math, i.map((function (e) {
        return parseInt(e)
      }))),
      s = e < 0 ? 1 : e + 1;
    s > n && (s = "1");
    var l = i.filter((function (e) {
        return e >= parseInt(s)
      })),
      r = l.sort()[0];
    return document.querySelector('.gbtn[data-taborder="'.concat(r, '"]'))
  }

  function X(e) {
    if (e.events.hasOwnProperty("keyboard")) return !1;
    e.events.keyboard = a("keydown", {
      onElement: window,
      withCallback: function (t, i) {
        var n = (t = t || window.event).keyCode;
        if (9 == n) {
          var s = document.querySelector(".gbtn.focused");
          if (!s) {
            var l = !(!document.activeElement || !document.activeElement.nodeName) && document.activeElement.nodeName.toLocaleLowerCase();
            if ("input" == l || "textarea" == l || "button" == l) return
          }
          t.preventDefault();
          var o = document.querySelectorAll(".gbtn[data-taborder]");
          if (!o || o.length <= 0) return;
          if (!s) {
            var r = z();
            return void(r && (r.focus(), h(r, "focused")))
          }
          var a = z(s.getAttribute("data-taborder"));
          d(s, "focused"), a && (a.focus(), h(a, "focused"))
        }
        39 == n && e.nextSlide(), 37 == n && e.prevSlide(), 27 == n && e.close()
      }
    })
  }

  function Y(e) {
    return Math.sqrt(e.x * e.x + e.y * e.y)
  }

  function q(e, t) {
    var i = function (e, t) {
      var i = Y(e) * Y(t);
      if (0 === i) return 0;
      var n = function (e, t) {
        return e.x * t.x + e.y * t.y
      }(e, t) / i;
      return n > 1 && (n = 1), Math.acos(n)
    }(e, t);
    return function (e, t) {
      return e.x * t.y - t.x * e.y
    }(e, t) > 0 && (i *= -1), 180 * i / Math.PI
  }
  var N = function () {
    function e(i) {
      t(this, e), this.handlers = [], this.el = i
    }
    return n(e, [{
      key: "add",
      value: function (e) {
        this.handlers.push(e)
      }
    }, {
      key: "del",
      value: function (e) {
        e || (this.handlers = []);
        for (var t = this.handlers.length; t >= 0; t--) this.handlers[t] === e && this.handlers.splice(t, 1)
      }
    }, {
      key: "dispatch",
      value: function () {
        for (var e = 0, t = this.handlers.length; e < t; e++) {
          var i = this.handlers[e];
          "function" == typeof i && i.apply(this.el, arguments)
        }
      }
    }]), e
  }();

  function D(e, t) {
    var i = new N(e);
    return i.add(t), i
  }
  var _ = function () {
    function e(i, n) {
      t(this, e), this.element = "string" == typeof i ? document.querySelector(i) : i, this.start = this.start.bind(this), this.move = this.move.bind(this), this.end = this.end.bind(this), this.cancel = this.cancel.bind(this), this.element.addEventListener("touchstart", this.start, !1), this.element.addEventListener("touchmove", this.move, !1), this.element.addEventListener("touchend", this.end, !1), this.element.addEventListener("touchcancel", this.cancel, !1), this.preV = {
        x: null,
        y: null
      }, this.pinchStartLen = null, this.zoom = 1, this.isDoubleTap = !1;
      var s = function () {};
      this.rotate = D(this.element, n.rotate || s), this.touchStart = D(this.element, n.touchStart || s), this.multipointStart = D(this.element, n.multipointStart || s), this.multipointEnd = D(this.element, n.multipointEnd || s), this.pinch = D(this.element, n.pinch || s), this.swipe = D(this.element, n.swipe || s), this.tap = D(this.element, n.tap || s), this.doubleTap = D(this.element, n.doubleTap || s), this.longTap = D(this.element, n.longTap || s), this.singleTap = D(this.element, n.singleTap || s), this.pressMove = D(this.element, n.pressMove || s), this.twoFingerPressMove = D(this.element, n.twoFingerPressMove || s), this.touchMove = D(this.element, n.touchMove || s), this.touchEnd = D(this.element, n.touchEnd || s), this.touchCancel = D(this.element, n.touchCancel || s), this.translateContainer = this.element, this._cancelAllHandler = this.cancelAll.bind(this), window.addEventListener("scroll", this._cancelAllHandler), this.delta = null, this.last = null, this.now = null, this.tapTimeout = null, this.singleTapTimeout = null, this.longTapTimeout = null, this.swipeTimeout = null, this.x1 = this.x2 = this.y1 = this.y2 = null, this.preTapPosition = {
        x: null,
        y: null
      }
    }
    return n(e, [{
      key: "start",
      value: function (e) {
        if (e.touches) {
          if (e.target && e.target.nodeName && ["a", "button", "input"].indexOf(e.target.nodeName.toLowerCase()) >= 0) console.log("ignore drag for this touched element", e.target.nodeName.toLowerCase());
          else {
            this.now = Date.now(), this.x1 = e.touches[0].pageX, this.y1 = e.touches[0].pageY, this.delta = this.now - (this.last || this.now), this.touchStart.dispatch(e, this.element), null !== this.preTapPosition.x && (this.isDoubleTap = this.delta > 0 && this.delta <= 250 && Math.abs(this.preTapPosition.x - this.x1) < 30 && Math.abs(this.preTapPosition.y - this.y1) < 30, this.isDoubleTap && clearTimeout(this.singleTapTimeout)), this.preTapPosition.x = this.x1, this.preTapPosition.y = this.y1, this.last = this.now;
            var t = this.preV;
            if (e.touches.length > 1) {
              this._cancelLongTap(), this._cancelSingleTap();
              var i = {
                x: e.touches[1].pageX - this.x1,
                y: e.touches[1].pageY - this.y1
              };
              t.x = i.x, t.y = i.y, this.pinchStartLen = Y(t), this.multipointStart.dispatch(e, this.element)
            }
            this._preventTap = !1, this.longTapTimeout = setTimeout(function () {
              this.longTap.dispatch(e, this.element), this._preventTap = !0
            }.bind(this), 750)
          }
        }
      }
    }, {
      key: "move",
      value: function (e) {
        if (e.touches) {
          var t = this.preV,
            i = e.touches.length,
            n = e.touches[0].pageX,
            s = e.touches[0].pageY;
          if (this.isDoubleTap = !1, i > 1) {
            var l = e.touches[1].pageX,
              o = e.touches[1].pageY,
              r = {
                x: e.touches[1].pageX - n,
                y: e.touches[1].pageY - s
              };
            null !== t.x && (this.pinchStartLen > 0 && (e.zoom = Y(r) / this.pinchStartLen, this.pinch.dispatch(e, this.element)), e.angle = q(r, t), this.rotate.dispatch(e, this.element)), t.x = r.x, t.y = r.y, null !== this.x2 && null !== this.sx2 ? (e.deltaX = (n - this.x2 + l - this.sx2) / 2, e.deltaY = (s - this.y2 + o - this.sy2) / 2) : (e.deltaX = 0, e.deltaY = 0), this.twoFingerPressMove.dispatch(e, this.element), this.sx2 = l, this.sy2 = o
          } else {
            if (null !== this.x2) {
              e.deltaX = n - this.x2, e.deltaY = s - this.y2;
              var a = Math.abs(this.x1 - this.x2),
                h = Math.abs(this.y1 - this.y2);
              (a > 10 || h > 10) && (this._preventTap = !0)
            } else e.deltaX = 0, e.deltaY = 0;
            this.pressMove.dispatch(e, this.element)
          }
          this.touchMove.dispatch(e, this.element), this._cancelLongTap(), this.x2 = n, this.y2 = s, i > 1 && e.preventDefault()
        }
      }
    }, {
      key: "end",
      value: function (e) {
        if (e.changedTouches) {
          this._cancelLongTap();
          var t = this;
          e.touches.length < 2 && (this.multipointEnd.dispatch(e, this.element), this.sx2 = this.sy2 = null), this.x2 && Math.abs(this.x1 - this.x2) > 30 || this.y2 && Math.abs(this.y1 - this.y2) > 30 ? (e.direction = this._swipeDirection(this.x1, this.x2, this.y1, this.y2), this.swipeTimeout = setTimeout((function () {
            t.swipe.dispatch(e, t.element)
          }), 0)) : (this.tapTimeout = setTimeout((function () {
            t._preventTap || t.tap.dispatch(e, t.element), t.isDoubleTap && (t.doubleTap.dispatch(e, t.element), t.isDoubleTap = !1)
          }), 0), t.isDoubleTap || (t.singleTapTimeout = setTimeout((function () {
            t.singleTap.dispatch(e, t.element)
          }), 250))), this.touchEnd.dispatch(e, this.element), this.preV.x = 0, this.preV.y = 0, this.zoom = 1, this.pinchStartLen = null, this.x1 = this.x2 = this.y1 = this.y2 = null
        }
      }
    }, {
      key: "cancelAll",
      value: function () {
        this._preventTap = !0, clearTimeout(this.singleTapTimeout), clearTimeout(this.tapTimeout), clearTimeout(this.longTapTimeout), clearTimeout(this.swipeTimeout)
      }
    }, {
      key: "cancel",
      value: function (e) {
        this.cancelAll(), this.touchCancel.dispatch(e, this.element)
      }
    }, {
      key: "_cancelLongTap",
      value: function () {
        clearTimeout(this.longTapTimeout)
      }
    }, {
      key: "_cancelSingleTap",
      value: function () {
        clearTimeout(this.singleTapTimeout)
      }
    }, {
      key: "_swipeDirection",
      value: function (e, t, i, n) {
        return Math.abs(e - t) >= Math.abs(i - n) ? e - t > 0 ? "Left" : "Right" : i - n > 0 ? "Up" : "Down"
      }
    }, {
      key: "on",
      value: function (e, t) {
        this[e] && this[e].add(t)
      }
    }, {
      key: "off",
      value: function (e, t) {
        this[e] && this[e].del(t)
      }
    }, {
      key: "destroy",
      value: function () {
        return this.singleTapTimeout && clearTimeout(this.singleTapTimeout), this.tapTimeout && clearTimeout(this.tapTimeout), this.longTapTimeout && clearTimeout(this.longTapTimeout), this.swipeTimeout && clearTimeout(this.swipeTimeout), this.element.removeEventListener("touchstart", this.start), this.element.removeEventListener("touchmove", this.move), this.element.removeEventListener("touchend", this.end), this.element.removeEventListener("touchcancel", this.cancel), this.rotate.del(), this.touchStart.del(), this.multipointStart.del(), this.multipointEnd.del(), this.pinch.del(), this.swipe.del(), this.tap.del(), this.doubleTap.del(), this.longTap.del(), this.singleTap.del(), this.pressMove.del(), this.twoFingerPressMove.del(), this.touchMove.del(), this.touchEnd.del(), this.touchCancel.del(), this.preV = this.pinchStartLen = this.zoom = this.isDoubleTap = this.delta = this.last = this.now = this.tapTimeout = this.singleTapTimeout = this.longTapTimeout = this.swipeTimeout = this.x1 = this.x2 = this.y1 = this.y2 = this.preTapPosition = this.rotate = this.touchStart = this.multipointStart = this.multipointEnd = this.pinch = this.swipe = this.tap = this.doubleTap = this.longTap = this.singleTap = this.pressMove = this.touchMove = this.touchEnd = this.touchCancel = this.twoFingerPressMove = null, window.removeEventListener("scroll", this._cancelAllHandler), null
      }
    }]), e
  }();

  function W(e) {
    var t = function () {
        var e, t = document.createElement("fakeelement"),
          i = {
            transition: "transitionend",
            OTransition: "oTransitionEnd",
            MozTransition: "transitionend",
            WebkitTransition: "webkitTransitionEnd"
          };
        for (e in i)
          if (void 0 !== t.style[e]) return i[e]
      }(),
      i = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth,
      n = c(e, "gslide-media") ? e : e.querySelector(".gslide-media"),
      s = u(n, ".ginner-container"),
      l = e.querySelector(".gslide-description");
    i > 769 && (n = s), h(n, "greset"), v(n, "translate3d(0, 0, 0)"), a(t, {
      onElement: n,
      once: !0,
      withCallback: function (e, t) {
        d(n, "greset")
      }
    }), n.style.opacity = "", l && (l.style.opacity = "")
  }

  function B(e) {
    if (e.events.hasOwnProperty("touch")) return !1;
    var t, i, n, s = y(),
      l = s.width,
      o = s.height,
      r = !1,
      a = null,
      g = null,
      f = null,
      p = !1,
      m = 1,
      x = 1,
      b = !1,
      S = !1,
      w = null,
      T = null,
      C = null,
      k = null,
      E = 0,
      A = 0,
      L = !1,
      I = !1,
      O = {},
      P = {},
      M = 0,
      z = 0,
      X = document.getElementById("glightbox-slider"),
      Y = document.querySelector(".goverlay"),
      q = new _(X, {
        touchStart: function (t) {
          if (r = !0, (c(t.targetTouches[0].target, "ginner-container") || u(t.targetTouches[0].target, ".gslide-desc") || "a" == t.targetTouches[0].target.nodeName.toLowerCase()) && (r = !1), u(t.targetTouches[0].target, ".gslide-inline") && !c(t.targetTouches[0].target.parentNode, "gslide-inline") && (r = !1), r) {
            if (P = t.targetTouches[0], O.pageX = t.targetTouches[0].pageX, O.pageY = t.targetTouches[0].pageY, M = t.targetTouches[0].clientX, z = t.targetTouches[0].clientY, a = e.activeSlide, g = a.querySelector(".gslide-media"), n = a.querySelector(".gslide-inline"), f = null, c(g, "gslide-image") && (f = g.querySelector("img")), (window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth) > 769 && (g = a.querySelector(".ginner-container")), d(Y, "greset"), t.pageX > 20 && t.pageX < window.innerWidth - 20) return;
            t.preventDefault()
          }
        },
        touchMove: function (s) {
          if (r && (P = s.targetTouches[0], !b && !S)) {
            if (n && n.offsetHeight > o) {
              var a = O.pageX - P.pageX;
              if (Math.abs(a) <= 13) return !1
            }
            p = !0;
            var h, d = s.targetTouches[0].clientX,
              c = s.targetTouches[0].clientY,
              u = M - d,
              m = z - c;
            if (Math.abs(u) > Math.abs(m) ? (L = !1, I = !0) : (I = !1, L = !0), t = P.pageX - O.pageX, E = 100 * t / l, i = P.pageY - O.pageY, A = 100 * i / o, L && f && (h = 1 - Math.abs(i) / o, Y.style.opacity = h, e.settings.touchFollowAxis && (E = 0)), I && (h = 1 - Math.abs(t) / l, g.style.opacity = h, e.settings.touchFollowAxis && (A = 0)), !f) return v(g, "translate3d(".concat(E, "%, 0, 0)"));
            v(g, "translate3d(".concat(E, "%, ").concat(A, "%, 0)"))
          }
        },
        touchEnd: function () {
          if (r) {
            if (p = !1, S || b) return C = w, void(k = T);
            var t = Math.abs(parseInt(A)),
              i = Math.abs(parseInt(E));
            if (!(t > 29 && f)) return t < 29 && i < 25 ? (h(Y, "greset"), Y.style.opacity = 1, W(g)) : void 0;
            e.close()
          }
        },
        multipointEnd: function () {
          setTimeout((function () {
            b = !1
          }), 50)
        },
        multipointStart: function () {
          b = !0, m = x || 1
        },
        pinch: function (e) {
          if (!f || p) return !1;
          b = !0, f.scaleX = f.scaleY = m * e.zoom;
          var t = m * e.zoom;
          if (S = !0, t <= 1) return S = !1, t = 1, k = null, C = null, w = null, T = null, void f.setAttribute("style", "");
          t > 4.5 && (t = 4.5), f.style.transform = "scale3d(".concat(t, ", ").concat(t, ", 1)"), x = t
        },
        pressMove: function (e) {
          if (S && !b) {
            var t = P.pageX - O.pageX,
              i = P.pageY - O.pageY;
            C && (t += C), k && (i += k), w = t, T = i;
            var n = "translate3d(".concat(t, "px, ").concat(i, "px, 0)");
            x && (n += " scale3d(".concat(x, ", ").concat(x, ", 1)")), v(f, n)
          }
        },
        swipe: function (t) {
          if (!S)
            if (b) b = !1;
            else {
              if ("Left" == t.direction) {
                if (e.index == e.elements.length - 1) return W(g);
                e.nextSlide()
              }
              if ("Right" == t.direction) {
                if (0 == e.index) return W(g);
                e.prevSlide()
              }
            }
        }
      });
    e.events.touch = q
  }
  var H = function () {
      function e(i, n) {
        var s = this,
          l = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
        if (t(this, e), this.img = i, this.slide = n, this.onclose = l, this.img.setZoomEvents) return !1;
        this.active = !1, this.zoomedIn = !1, this.dragging = !1, this.currentX = null, this.currentY = null, this.initialX = null, this.initialY = null, this.xOffset = 0, this.yOffset = 0, this.img.addEventListener("mousedown", (function (e) {
          return s.dragStart(e)
        }), !1), this.img.addEventListener("mouseup", (function (e) {
          return s.dragEnd(e)
        }), !1), this.img.addEventListener("mousemove", (function (e) {
          return s.drag(e)
        }), !1), this.img.addEventListener("click", (function (e) {
          return s.slide.classList.contains("dragging-nav") ? (s.zoomOut(), !1) : s.zoomedIn ? void(s.zoomedIn && !s.dragging && s.zoomOut()) : s.zoomIn()
        }), !1), this.img.setZoomEvents = !0
      }
      return n(e, [{
        key: "zoomIn",
        value: function () {
          var e = this.widowWidth();
          if (!(this.zoomedIn || e <= 768)) {
            var t = this.img;
            if (t.setAttribute("data-style", t.getAttribute("style")), t.style.maxWidth = t.naturalWidth + "px", t.style.maxHeight = t.naturalHeight + "px", t.naturalWidth > e) {
              var i = e / 2 - t.naturalWidth / 2;
              this.setTranslate(this.img.parentNode, i, 0)
            }
            this.slide.classList.add("zoomed"), this.zoomedIn = !0
          }
        }
      }, {
        key: "zoomOut",
        value: function () {
          this.img.parentNode.setAttribute("style", ""), this.img.setAttribute("style", this.img.getAttribute("data-style")), this.slide.classList.remove("zoomed"), this.zoomedIn = !1, this.currentX = null, this.currentY = null, this.initialX = null, this.initialY = null, this.xOffset = 0, this.yOffset = 0, this.onclose && "function" == typeof this.onclose && this.onclose()
        }
      }, {
        key: "dragStart",
        value: function (e) {
          e.preventDefault(), this.zoomedIn ? ("touchstart" === e.type ? (this.initialX = e.touches[0].clientX - this.xOffset, this.initialY = e.touches[0].clientY - this.yOffset) : (this.initialX = e.clientX - this.xOffset, this.initialY = e.clientY - this.yOffset), e.target === this.img && (this.active = !0, this.img.classList.add("dragging"))) : this.active = !1
        }
      }, {
        key: "dragEnd",
        value: function (e) {
          var t = this;
          e.preventDefault(), this.initialX = this.currentX, this.initialY = this.currentY, this.active = !1, setTimeout((function () {
            t.dragging = !1, t.img.isDragging = !1, t.img.classList.remove("dragging")
          }), 100)
        }
      }, {
        key: "drag",
        value: function (e) {
          this.active && (e.preventDefault(), "touchmove" === e.type ? (this.currentX = e.touches[0].clientX - this.initialX, this.currentY = e.touches[0].clientY - this.initialY) : (this.currentX = e.clientX - this.initialX, this.currentY = e.clientY - this.initialY), this.xOffset = this.currentX, this.yOffset = this.currentY, this.img.isDragging = !0, this.dragging = !0, this.setTranslate(this.img, this.currentX, this.currentY))
        }
      }, {
        key: "onMove",
        value: function (e) {
          if (this.zoomedIn) {
            var t = e.clientX - this.img.naturalWidth / 2,
              i = e.clientY - this.img.naturalHeight / 2;
            this.setTranslate(this.img, t, i)
          }
        }
      }, {
        key: "setTranslate",
        value: function (e, t, i) {
          e.style.transform = "translate3d(" + t + "px, " + i + "px, 0)"
        }
      }, {
        key: "widowWidth",
        value: function () {
          return window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth
        }
      }]), e
    }(),
    V = function () {
      function e() {
        var i = this,
          n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        t(this, e);
        var s = n.dragEl,
          l = n.toleranceX,
          o = void 0 === l ? 40 : l,
          r = n.toleranceY,
          a = void 0 === r ? 65 : r,
          h = n.slide,
          d = void 0 === h ? null : h,
          c = n.instance,
          u = void 0 === c ? null : c;
        this.el = s, this.active = !1, this.dragging = !1, this.currentX = null, this.currentY = null, this.initialX = null, this.initialY = null, this.xOffset = 0, this.yOffset = 0, this.direction = null, this.lastDirection = null, this.toleranceX = o, this.toleranceY = a, this.toleranceReached = !1, this.dragContainer = this.el, this.slide = d, this.instance = u, this.el.addEventListener("mousedown", (function (e) {
          return i.dragStart(e)
        }), !1), this.el.addEventListener("mouseup", (function (e) {
          return i.dragEnd(e)
        }), !1), this.el.addEventListener("mousemove", (function (e) {
          return i.drag(e)
        }), !1)
      }
      return n(e, [{
        key: "dragStart",
        value: function (e) {
          if (this.slide.classList.contains("zoomed")) this.active = !1;
          else {
            "touchstart" === e.type ? (this.initialX = e.touches[0].clientX - this.xOffset, this.initialY = e.touches[0].clientY - this.yOffset) : (this.initialX = e.clientX - this.xOffset, this.initialY = e.clientY - this.yOffset);
            var t = e.target.nodeName.toLowerCase();
            e.target.classList.contains("nodrag") || u(e.target, ".nodrag") || -1 !== ["input", "select", "textarea", "button", "a"].indexOf(t) ? this.active = !1 : (e.preventDefault(), (e.target === this.el || "img" !== t && u(e.target, ".gslide-inline")) && (this.active = !0, this.el.classList.add("dragging"), this.dragContainer = u(e.target, ".ginner-container")))
          }
        }
      }, {
        key: "dragEnd",
        value: function (e) {
          var t = this;
          e && e.preventDefault(), this.initialX = 0, this.initialY = 0, this.currentX = null, this.currentY = null, this.initialX = null, this.initialY = null, this.xOffset = 0, this.yOffset = 0, this.active = !1, this.doSlideChange && (this.instance.preventOutsideClick = !0, "right" == this.doSlideChange && this.instance.prevSlide(), "left" == this.doSlideChange && this.instance.nextSlide()), this.doSlideClose && this.instance.close(), this.toleranceReached || this.setTranslate(this.dragContainer, 0, 0, !0), setTimeout((function () {
            t.instance.preventOutsideClick = !1, t.toleranceReached = !1, t.lastDirection = null, t.dragging = !1, t.el.isDragging = !1, t.el.classList.remove("dragging"), t.slide.classList.remove("dragging-nav"), t.dragContainer.style.transform = "", t.dragContainer.style.transition = ""
          }), 100)
        }
      }, {
        key: "drag",
        value: function (e) {
          if (this.active) {
            e.preventDefault(), this.slide.classList.add("dragging-nav"), "touchmove" === e.type ? (this.currentX = e.touches[0].clientX - this.initialX, this.currentY = e.touches[0].clientY - this.initialY) : (this.currentX = e.clientX - this.initialX, this.currentY = e.clientY - this.initialY), this.xOffset = this.currentX, this.yOffset = this.currentY, this.el.isDragging = !0, this.dragging = !0, this.doSlideChange = !1, this.doSlideClose = !1;
            var t = Math.abs(this.currentX),
              i = Math.abs(this.currentY);
            if (t > 0 && t >= Math.abs(this.currentY) && (!this.lastDirection || "x" == this.lastDirection)) {
              this.yOffset = 0, this.lastDirection = "x", this.setTranslate(this.dragContainer, this.currentX, 0);
              var n = this.shouldChange();
              if (!this.instance.settings.dragAutoSnap && n && (this.doSlideChange = n), this.instance.settings.dragAutoSnap && n) return this.instance.preventOutsideClick = !0, this.toleranceReached = !0, this.active = !1, this.instance.preventOutsideClick = !0, this.dragEnd(null), "right" == n && this.instance.prevSlide(), void("left" == n && this.instance.nextSlide())
            }
            if (this.toleranceY > 0 && i > 0 && i >= t && (!this.lastDirection || "y" == this.lastDirection)) {
              this.xOffset = 0, this.lastDirection = "y", this.setTranslate(this.dragContainer, 0, this.currentY);
              var s = this.shouldClose();
              return !this.instance.settings.dragAutoSnap && s && (this.doSlideClose = !0), void(this.instance.settings.dragAutoSnap && s && this.instance.close())
            }
          }
        }
      }, {
        key: "shouldChange",
        value: function () {
          var e = !1;
          if (Math.abs(this.currentX) >= this.toleranceX) {
            var t = this.currentX > 0 ? "right" : "left";
            ("left" == t && this.slide !== this.slide.parentNode.lastChild || "right" == t && this.slide !== this.slide.parentNode.firstChild) && (e = t)
          }
          return e
        }
      }, {
        key: "shouldClose",
        value: function () {
          var e = !1;
          return Math.abs(this.currentY) >= this.toleranceY && (e = !0), e
        }
      }, {
        key: "setTranslate",
        value: function (e, t, i) {
          var n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
          e.style.transition = n ? "all .2s ease" : "", e.style.transform = "translate3d(".concat(t, "px, ").concat(i, "px, 0)")
        }
      }]), e
    }();

  function j(e, t, i, n) {
    var s = e.querySelector(".gslide-media"),
      l = new Image,
      o = "gSlideTitle_" + i,
      r = "gSlideDesc_" + i;
    l.addEventListener("load", (function () {
      T(n) && n()
    }), !1), l.src = t.href, "" != t.sizes && "" != t.srcset && (l.sizes = t.sizes, l.srcset = t.srcset), l.alt = "", I(t.alt) || "" === t.alt || (l.alt = t.alt), "" !== t.title && l.setAttribute("aria-labelledby", o), "" !== t.description && l.setAttribute("aria-describedby", r), t.hasOwnProperty("_hasCustomWidth") && t._hasCustomWidth && (l.style.width = t.width), t.hasOwnProperty("_hasCustomHeight") && t._hasCustomHeight && (l.style.height = t.height), s.insertBefore(l, s.firstChild)
  }

  function F(e, t, i, n) {
    var s = this,
      l = e.querySelector(".ginner-container"),
      o = "gvideo" + i,
      r = e.querySelector(".gslide-media"),
      a = this.getAllPlayers();
    h(l, "gvideo-container"), r.insertBefore(m('<div class="gvideo-wrapper"></div>'), r.firstChild);
    var d = e.querySelector(".gvideo-wrapper");
    S(this.settings.plyr.css, "Plyr");
    var c = t.href,
      u = null == t ? void 0 : t.videoProvider,
      g = !1;
    r.style.maxWidth = t.width, S(this.settings.plyr.js, "Plyr", (function () {
      if (!u && c.match(/vimeo\.com\/([0-9]*)/) && (u = "vimeo"), !u && (c.match(/(youtube\.com|youtube-nocookie\.com)\/watch\?v=([a-zA-Z0-9\-_]+)/) || c.match(/youtu\.be\/([a-zA-Z0-9\-_]+)/) || c.match(/(youtube\.com|youtube-nocookie\.com)\/embed\/([a-zA-Z0-9\-_]+)/)) && (u = "youtube"), "local" === u || !u) {
        u = "local";
        var l = '<video id="' + o + '" ';
        l += 'style="background:#000; max-width: '.concat(t.width, ';" '), l += 'preload="metadata" ', l += 'x-webkit-airplay="allow" ', l += "playsinline ", l += "controls ", l += 'class="gvideo-local">', l += '<source src="'.concat(c, '">'), g = m(l += "</video>")
      }
      var r = g || m('<div id="'.concat(o, '" data-plyr-provider="').concat(u, '" data-plyr-embed-id="').concat(c, '"></div>'));
      h(d, "".concat(u, "-video gvideo")), d.appendChild(r), d.setAttribute("data-id", o), d.setAttribute("data-index", i);
      var v = O(s.settings.plyr, "config") ? s.settings.plyr.config : {},
        f = new Plyr("#" + o, v);
      f.on("ready", (function (e) {
        a[o] = e.detail.plyr, T(n) && n()
      })), b((function () {
        return e.querySelector("iframe") && "true" == e.querySelector("iframe").dataset.ready
      }), (function () {
        s.resize(e)
      })), f.on("enterfullscreen", R), f.on("exitfullscreen", R)
    }))
  }

  function R(e) {
    var t = u(e.target, ".gslide-media");
    "enterfullscreen" === e.type && h(t, "fullscreen"), "exitfullscreen" === e.type && d(t, "fullscreen")
  }

  function G(e, t, i, n) {
    var s, l = this,
      o = e.querySelector(".gslide-media"),
      r = !(!O(t, "href") || !t.href) && t.href.split("#").pop().trim(),
      d = !(!O(t, "content") || !t.content) && t.content;
    if (d && (C(d) && (s = m('<div class="ginlined-content">'.concat(d, "</div>"))), k(d))) {
      "none" == d.style.display && (d.style.display = "block");
      var c = document.createElement("div");
      c.className = "ginlined-content", c.appendChild(d), s = c
    }
    if (r) {
      var u = document.getElementById(r);
      if (!u) return !1;
      var g = u.cloneNode(!0);
      g.style.height = t.height, g.style.maxWidth = t.width, h(g, "ginlined-content"), s = g
    }
    if (!s) return console.error("Unable to append inline slide content", t), !1;
    o.style.height = t.height, o.style.width = t.width, o.appendChild(s), this.events["inlineclose" + r] = a("click", {
      onElement: o.querySelectorAll(".gtrigger-close"),
      withCallback: function (e) {
        e.preventDefault(), l.close()
      }
    }), T(n) && n()
  }

  function Z(e, t, i, n) {
    var s = e.querySelector(".gslide-media"),
      l = function (e) {
        var t = e.url,
          i = e.allow,
          n = e.callback,
          s = e.appendTo,
          l = document.createElement("iframe");
        return l.className = "vimeo-video gvideo", l.src = t, l.style.width = "100%", l.style.height = "100%", i && l.setAttribute("allow", i), l.onload = function () {
          l.onload = null, h(l, "node-ready"), T(n) && n()
        }, s && s.appendChild(l), l
      }({
        url: t.href,
        callback: n
      });
    s.parentNode.style.maxWidth = t.width, s.parentNode.style.height = t.height, s.appendChild(l)
  }
  var U = function () {
      function e() {
        var i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        t(this, e), this.defaults = {
          href: "",
          sizes: "",
          srcset: "",
          title: "",
          type: "",
          videoProvider: "",
          description: "",
          alt: "",
          descPosition: "bottom",
          effect: "",
          width: "",
          height: "",
          content: !1,
          zoomable: !0,
          draggable: !0
        }, L(i) && (this.defaults = l(this.defaults, i))
      }
      return n(e, [{
        key: "sourceType",
        value: function (e) {
          var t = e;
          if (null !== (e = e.toLowerCase()).match(/\.(jpeg|jpg|jpe|gif|png|apn|webp|avif|svg)/)) return "image";
          if (e.match(/(youtube\.com|youtube-nocookie\.com)\/watch\?v=([a-zA-Z0-9\-_]+)/) || e.match(/youtu\.be\/([a-zA-Z0-9\-_]+)/) || e.match(/(youtube\.com|youtube-nocookie\.com)\/embed\/([a-zA-Z0-9\-_]+)/)) return "video";
          if (e.match(/vimeo\.com\/([0-9]*)/)) return "video";
          if (null !== e.match(/\.(mp4|ogg|webm|mov)/)) return "video";
          if (null !== e.match(/\.(mp3|wav|wma|aac|ogg)/)) return "audio";
          if (e.indexOf("#") > -1 && "" !== t.split("#").pop().trim()) return "inline";
          return e.indexOf("goajax=true") > -1 ? "ajax" : "external"
        }
      }, {
        key: "parseConfig",
        value: function (e, t) {
          var i = this,
            n = l({
              descPosition: t.descPosition
            }, this.defaults);
          if (L(e) && !k(e)) {
            O(e, "type") || (O(e, "content") && e.content ? e.type = "inline" : O(e, "href") && (e.type = this.sourceType(e.href)));
            var s = l(n, e);
            return this.setSize(s, t), s
          }
          var r = "",
            a = e.getAttribute("data-glightbox"),
            h = e.nodeName.toLowerCase();
          if ("a" === h && (r = e.href), "img" === h && (r = e.src, n.alt = e.alt), n.href = r, o(n, (function (s, l) {
              O(t, l) && "width" !== l && (n[l] = t[l]);
              var o = e.dataset[l];
              I(o) || (n[l] = i.sanitizeValue(o))
            })), n.content && (n.type = "inline"), !n.type && r && (n.type = this.sourceType(r)), I(a)) {
            if (!n.title && "a" == h) {
              var d = e.title;
              I(d) || "" === d || (n.title = d)
            }
            if (!n.title && "img" == h) {
              var c = e.alt;
              I(c) || "" === c || (n.title = c)
            }
          } else {
            var u = [];
            o(n, (function (e, t) {
              u.push(";\\s?" + t)
            })), u = u.join("\\s?:|"), "" !== a.trim() && o(n, (function (e, t) {
              var s = a,
                l = new RegExp("s?" + t + "s?:s?(.*?)(" + u + "s?:|$)"),
                o = s.match(l);
              if (o && o.length && o[1]) {
                var r = o[1].trim().replace(/;\s*$/, "");
                n[t] = i.sanitizeValue(r)
              }
            }))
          }
          if (n.description && "." === n.description.substring(0, 1)) {
            var g;
            try {
              g = document.querySelector(n.description).innerHTML
            } catch (e) {
              if (!(e instanceof DOMException)) throw e
            }
            g && (n.description = g)
          }
          if (!n.description) {
            var v = e.querySelector(".glightbox-desc");
            v && (n.description = v.innerHTML)
          }
          return this.setSize(n, t, e), this.slideConfig = n, n
        }
      }, {
        key: "setSize",
        value: function (e, t) {
          var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
            n = "video" == e.type ? this.checkSize(t.videosWidth) : this.checkSize(t.width),
            s = this.checkSize(t.height);
          return e.width = O(e, "width") && "" !== e.width ? this.checkSize(e.width) : n, e.height = O(e, "height") && "" !== e.height ? this.checkSize(e.height) : s, i && "image" == e.type && (e._hasCustomWidth = !!i.dataset.width, e._hasCustomHeight = !!i.dataset.height), e
        }
      }, {
        key: "checkSize",
        value: function (e) {
          return M(e) ? "".concat(e, "px") : e
        }
      }, {
        key: "sanitizeValue",
        value: function (e) {
          return "true" !== e && "false" !== e ? e : "true" === e
        }
      }]), e
    }(),
    $ = function () {
      function e(i, n, s) {
        t(this, e), this.element = i, this.instance = n, this.index = s
      }
      return n(e, [{
        key: "setContent",
        value: function () {
          var e = this,
            t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
            i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          if (c(t, "loaded")) return !1;
          var n = this.instance.settings,
            s = this.slideConfig,
            l = w();
          T(n.beforeSlideLoad) && n.beforeSlideLoad({
            index: this.index,
            slide: t,
            player: !1
          });
          var o = s.type,
            r = s.descPosition,
            a = t.querySelector(".gslide-media"),
            d = t.querySelector(".gslide-title"),
            u = t.querySelector(".gslide-desc"),
            g = t.querySelector(".gdesc-inner"),
            v = i,
            f = "gSlideTitle_" + this.index,
            p = "gSlideDesc_" + this.index;
          if (T(n.afterSlideLoad) && (v = function () {
              T(i) && i(), n.afterSlideLoad({
                index: e.index,
                slide: t,
                player: e.instance.getSlidePlayerInstance(e.index)
              })
            }), "" == s.title && "" == s.description ? g && g.parentNode.parentNode.removeChild(g.parentNode) : (d && "" !== s.title ? (d.id = f, d.innerHTML = s.title) : d.parentNode.removeChild(d), u && "" !== s.description ? (u.id = p, l && n.moreLength > 0 ? (s.smallDescription = this.slideShortDesc(s.description, n.moreLength, n.moreText), u.innerHTML = s.smallDescription, this.descriptionEvents(u, s)) : u.innerHTML = s.description) : u.parentNode.removeChild(u), h(a.parentNode, "desc-".concat(r)), h(g.parentNode, "description-".concat(r))), h(a, "gslide-".concat(o)), h(t, "loaded"), "video" !== o) {
            if ("external" !== o) return "inline" === o ? (G.apply(this.instance, [t, s, this.index, v]), void(s.draggable && new V({
              dragEl: t.querySelector(".gslide-inline"),
              toleranceX: n.dragToleranceX,
              toleranceY: n.dragToleranceY,
              slide: t,
              instance: this.instance
            }))) : void("image" !== o ? T(v) && v() : j(t, s, this.index, (function () {
              var i = t.querySelector("img");
              s.draggable && new V({
                dragEl: i,
                toleranceX: n.dragToleranceX,
                toleranceY: n.dragToleranceY,
                slide: t,
                instance: e.instance
              }), s.zoomable && i.naturalWidth > i.offsetWidth && (h(i, "zoomable"), new H(i, t, (function () {
                e.instance.resize()
              }))), T(v) && v()
            })));
            Z.apply(this, [t, s, this.index, v])
          } else F.apply(this.instance, [t, s, this.index, v])
        }
      }, {
        key: "slideShortDesc",
        value: function (e) {
          var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 50,
            i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
            n = document.createElement("div");
          n.innerHTML = e;
          var s = n.innerText,
            l = i;
          if ((e = s.trim()).length <= t) return e;
          var o = e.substr(0, t - 1);
          return l ? (n = null, o + '... <a href="#" class="desc-more">' + i + "</a>") : o
        }
      }, {
        key: "descriptionEvents",
        value: function (e, t) {
          var i = this,
            n = e.querySelector(".desc-more");
          if (!n) return !1;
          a("click", {
            onElement: n,
            withCallback: function (e, n) {
              e.preventDefault();
              var s = document.body,
                l = u(n, ".gslide-desc");
              if (!l) return !1;
              l.innerHTML = t.description, h(s, "gdesc-open");
              var o = a("click", {
                onElement: [s, u(l, ".gslide-description")],
                withCallback: function (e, n) {
                  "a" !== e.target.nodeName.toLowerCase() && (d(s, "gdesc-open"), h(s, "gdesc-closed"), l.innerHTML = t.smallDescription, i.descriptionEvents(l, t), setTimeout((function () {
                    d(s, "gdesc-closed")
                  }), 400), o.destroy())
                }
              })
            }
          })
        }
      }, {
        key: "create",
        value: function () {
          return m(this.instance.settings.slideHTML)
        }
      }, {
        key: "getConfig",
        value: function () {
          k(this.element) || this.element.hasOwnProperty("draggable") || (this.element.draggable = this.instance.settings.draggable);
          var e = new U(this.instance.settings.slideExtraAttributes);
          return this.slideConfig = e.parseConfig(this.element, this.instance.settings), this.slideConfig
        }
      }]), e
    }(),
    J = w(),
    K = null !== w() || void 0 !== document.createTouch || "ontouchstart" in window || "onmsgesturechange" in window || navigator.msMaxTouchPoints,
    Q = document.getElementsByTagName("html")[0],
    ee = {
      selector: ".glightbox",
      elements: null,
      skin: "clean",
      theme: "clean",
      closeButton: !0,
      startAt: null,
      autoplayVideos: !0,
      autofocusVideos: !0,
      descPosition: "bottom",
      width: "900px",
      height: "506px",
      videosWidth: "960px",
      beforeSlideChange: null,
      afterSlideChange: null,
      beforeSlideLoad: null,
      afterSlideLoad: null,
      slideInserted: null,
      slideRemoved: null,
      slideExtraAttributes: null,
      onOpen: null,
      onClose: null,
      loop: !1,
      zoomable: !0,
      draggable: !0,
      dragAutoSnap: !1,
      dragToleranceX: 40,
      dragToleranceY: 65,
      preload: !0,
      oneSlidePerOpen: !1,
      touchNavigation: !0,
      touchFollowAxis: !0,
      keyboardNavigation: !0,
      closeOnOutsideClick: !0,
      plugins: !1,
      plyr: {
        css: "https://cdn.plyr.io/3.6.12/plyr.css",
        js: "https://cdn.plyr.io/3.6.12/plyr.js",
        config: {
          ratio: "16:9",
          fullscreen: {
            enabled: !0,
            iosNative: !0
          },
          youtube: {
            noCookie: !0,
            rel: 0,
            showinfo: 0,
            iv_load_policy: 3
          },
          vimeo: {
            byline: !1,
            portrait: !1,
            title: !1,
            transparent: !1
          }
        }
      },
      openEffect: "zoom",
      closeEffect: "zoom",
      slideEffect: "slide",
      moreText: "See more",
      moreLength: 60,
      cssEfects: {
        fade: {
          in: "fadeIn",
          out: "fadeOut"
        },
        zoom: {
          in: "zoomIn",
          out: "zoomOut"
        },
        slide: {
          in: "slideInRight",
          out: "slideOutLeft"
        },
        slideBack: {
          in: "slideInLeft",
          out: "slideOutRight"
        },
        none: {
          in: "none",
          out: "none"
        }
      },
      svg: {
        close: '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 512 512" xml:space="preserve"><g><g><path d="M505.943,6.058c-8.077-8.077-21.172-8.077-29.249,0L6.058,476.693c-8.077,8.077-8.077,21.172,0,29.249C10.096,509.982,15.39,512,20.683,512c5.293,0,10.586-2.019,14.625-6.059L505.943,35.306C514.019,27.23,514.019,14.135,505.943,6.058z"/></g></g><g><g><path d="M505.942,476.694L35.306,6.059c-8.076-8.077-21.172-8.077-29.248,0c-8.077,8.076-8.077,21.171,0,29.248l470.636,470.636c4.038,4.039,9.332,6.058,14.625,6.058c5.293,0,10.587-2.019,14.624-6.057C514.018,497.866,514.018,484.771,505.942,476.694z"/></g></g></svg>',
        next: '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 477.175 477.175" xml:space="preserve"> <g><path d="M360.731,229.075l-225.1-225.1c-5.3-5.3-13.8-5.3-19.1,0s-5.3,13.8,0,19.1l215.5,215.5l-215.5,215.5c-5.3,5.3-5.3,13.8,0,19.1c2.6,2.6,6.1,4,9.5,4c3.4,0,6.9-1.3,9.5-4l225.1-225.1C365.931,242.875,365.931,234.275,360.731,229.075z"/></g></svg>',
        prev: '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 477.175 477.175" xml:space="preserve"><g><path d="M145.188,238.575l215.5-215.5c5.3-5.3,5.3-13.8,0-19.1s-13.8-5.3-19.1,0l-225.1,225.1c-5.3,5.3-5.3,13.8,0,19.1l225.1,225c2.6,2.6,6.1,4,9.5,4s6.9-1.3,9.5-4c5.3-5.3,5.3-13.8,0-19.1L145.188,238.575z"/></g></svg>'
      },
      slideHTML: '<div class="gslide">\n    <div class="gslide-inner-content">\n        <div class="ginner-container">\n            <div class="gslide-media">\n            </div>\n            <div class="gslide-description">\n                <div class="gdesc-inner">\n                    <h4 class="gslide-title"></h4>\n                    <div class="gslide-desc"></div>\n                </div>\n            </div>\n        </div>\n    </div>\n</div>',
      lightboxHTML: '<div id="glightbox-body" class="glightbox-container" tabindex="-1" role="dialog" aria-hidden="false">\n    <div class="gloader visible"></div>\n    <div class="goverlay"></div>\n    <div class="gcontainer">\n    <div id="glightbox-slider" class="gslider"></div>\n    <button class="gclose gbtn" aria-label="Close" data-taborder="3">{closeSVG}</button>\n    <button class="gprev gbtn" aria-label="Previous" data-taborder="2">{prevSVG}</button>\n    <button class="gnext gbtn" aria-label="Next" data-taborder="1">{nextSVG}</button>\n</div>\n</div>'
    },
    te = function () {
      function e() {
        var i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        t(this, e), this.customOptions = i, this.settings = l(ee, i), this.effectsClasses = this.getAnimationClasses(), this.videoPlayers = {}, this.apiEvents = [], this.fullElementsList = !1
      }
      return n(e, [{
        key: "init",
        value: function () {
          var e = this,
            t = this.getSelector();
          t && (this.baseEvents = a("click", {
            onElement: t,
            withCallback: function (t, i) {
              t.preventDefault(), e.open(i)
            }
          })), this.elements = this.getElements()
        }
      }, {
        key: "open",
        value: function () {
          var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
            t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
          if (0 === this.elements.length) return !1;
          this.activeSlide = null, this.prevActiveSlideIndex = null, this.prevActiveSlide = null;
          var i = M(t) ? t : this.settings.startAt;
          if (k(e)) {
            var n = e.getAttribute("data-gallery");
            n && (this.fullElementsList = this.elements, this.elements = this.getGalleryElements(this.elements, n)), I(i) && (i = this.getElementIndex(e)) < 0 && (i = 0)
          }
          M(i) || (i = 0), this.build(), g(this.overlay, "none" === this.settings.openEffect ? "none" : this.settings.cssEfects.fade.in);
          var s = document.body,
            l = window.innerWidth - document.documentElement.clientWidth;
          if (l > 0) {
            var o = document.createElement("style");
            o.type = "text/css", o.className = "gcss-styles", o.innerText = ".gscrollbar-fixer {margin-right: ".concat(l, "px}"), document.head.appendChild(o), h(s, "gscrollbar-fixer")
          }
          h(s, "glightbox-open"), h(Q, "glightbox-open"), J && (h(document.body, "glightbox-mobile"), this.settings.slideEffect = "slide"), this.showSlide(i, !0), 1 === this.elements.length ? (h(this.prevButton, "glightbox-button-hidden"), h(this.nextButton, "glightbox-button-hidden")) : (d(this.prevButton, "glightbox-button-hidden"), d(this.nextButton, "glightbox-button-hidden")), this.lightboxOpen = !0, this.trigger("open"), T(this.settings.onOpen) && this.settings.onOpen(), K && this.settings.touchNavigation && B(this), this.settings.keyboardNavigation && X(this)
        }
      }, {
        key: "openAt",
        value: function () {
          var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
          this.open(null, e)
        }
      }, {
        key: "showSlide",
        value: function () {
          var e = this,
            t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
            i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          f(this.loader), this.index = parseInt(t);
          var n = this.slidesContainer.querySelector(".current");
          n && d(n, "current"), this.slideAnimateOut();
          var s = this.slidesContainer.querySelectorAll(".gslide")[t];
          if (c(s, "loaded")) this.slideAnimateIn(s, i), p(this.loader);
          else {
            f(this.loader);
            var l = this.elements[t],
              o = {
                index: this.index,
                slide: s,
                slideNode: s,
                slideConfig: l.slideConfig,
                slideIndex: this.index,
                trigger: l.node,
                player: null
              };
            this.trigger("slide_before_load", o), l.instance.setContent(s, (function () {
              p(e.loader), e.resize(), e.slideAnimateIn(s, i), e.trigger("slide_after_load", o)
            }))
          }
          this.slideDescription = s.querySelector(".gslide-description"), this.slideDescriptionContained = this.slideDescription && c(this.slideDescription.parentNode, "gslide-media"), this.settings.preload && (this.preloadSlide(t + 1), this.preloadSlide(t - 1)), this.updateNavigationClasses(), this.activeSlide = s
        }
      }, {
        key: "preloadSlide",
        value: function (e) {
          var t = this;
          if (e < 0 || e > this.elements.length - 1) return !1;
          if (I(this.elements[e])) return !1;
          var i = this.slidesContainer.querySelectorAll(".gslide")[e];
          if (c(i, "loaded")) return !1;
          var n = this.elements[e],
            s = n.type,
            l = {
              index: e,
              slide: i,
              slideNode: i,
              slideConfig: n.slideConfig,
              slideIndex: e,
              trigger: n.node,
              player: null
            };
          this.trigger("slide_before_load", l), "video" === s || "external" === s ? setTimeout((function () {
            n.instance.setContent(i, (function () {
              t.trigger("slide_after_load", l)
            }))
          }), 200) : n.instance.setContent(i, (function () {
            t.trigger("slide_after_load", l)
          }))
        }
      }, {
        key: "prevSlide",
        value: function () {
          this.goToSlide(this.index - 1)
        }
      }, {
        key: "nextSlide",
        value: function () {
          this.goToSlide(this.index + 1)
        }
      }, {
        key: "goToSlide",
        value: function () {
          var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
          if (this.prevActiveSlide = this.activeSlide, this.prevActiveSlideIndex = this.index, !this.loop() && (e < 0 || e > this.elements.length - 1)) return !1;
          e < 0 ? e = this.elements.length - 1 : e >= this.elements.length && (e = 0), this.showSlide(e)
        }
      }, {
        key: "insertSlide",
        value: function () {
          var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
            t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1;
          t < 0 && (t = this.elements.length);
          var i = new $(e, this, t),
            n = i.getConfig(),
            s = l({}, n),
            o = i.create(),
            r = this.elements.length - 1;
          s.index = t, s.node = !1, s.instance = i, s.slideConfig = n, this.elements.splice(t, 0, s);
          var a = null,
            h = null;
          if (this.slidesContainer) {
            if (t > r) this.slidesContainer.appendChild(o);
            else {
              var d = this.slidesContainer.querySelectorAll(".gslide")[t];
              this.slidesContainer.insertBefore(o, d)
            }(this.settings.preload && 0 == this.index && 0 == t || this.index - 1 == t || this.index + 1 == t) && this.preloadSlide(t), 0 === this.index && 0 === t && (this.index = 1), this.updateNavigationClasses(), a = this.slidesContainer.querySelectorAll(".gslide")[t], h = this.getSlidePlayerInstance(t), s.slideNode = a
          }
          this.trigger("slide_inserted", {
            index: t,
            slide: a,
            slideNode: a,
            slideConfig: n,
            slideIndex: t,
            trigger: null,
            player: h
          }), T(this.settings.slideInserted) && this.settings.slideInserted({
            index: t,
            slide: a,
            player: h
          })
        }
      }, {
        key: "removeSlide",
        value: function () {
          var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : -1;
          if (e < 0 || e > this.elements.length - 1) return !1;
          var t = this.slidesContainer && this.slidesContainer.querySelectorAll(".gslide")[e];
          t && (this.getActiveSlideIndex() == e && (e == this.elements.length - 1 ? this.prevSlide() : this.nextSlide()), t.parentNode.removeChild(t)), this.elements.splice(e, 1), this.trigger("slide_removed", e), T(this.settings.slideRemoved) && this.settings.slideRemoved(e)
        }
      }, {
        key: "slideAnimateIn",
        value: function (e, t) {
          var i = this,
            n = e.querySelector(".gslide-media"),
            s = e.querySelector(".gslide-description"),
            l = {
              index: this.prevActiveSlideIndex,
              slide: this.prevActiveSlide,
              slideNode: this.prevActiveSlide,
              slideIndex: this.prevActiveSlide,
              slideConfig: I(this.prevActiveSlideIndex) ? null : this.elements[this.prevActiveSlideIndex].slideConfig,
              trigger: I(this.prevActiveSlideIndex) ? null : this.elements[this.prevActiveSlideIndex].node,
              player: this.getSlidePlayerInstance(this.prevActiveSlideIndex)
            },
            o = {
              index: this.index,
              slide: this.activeSlide,
              slideNode: this.activeSlide,
              slideConfig: this.elements[this.index].slideConfig,
              slideIndex: this.index,
              trigger: this.elements[this.index].node,
              player: this.getSlidePlayerInstance(this.index)
            };
          if (n.offsetWidth > 0 && s && (p(s), s.style.display = ""), d(e, this.effectsClasses), t) g(e, this.settings.cssEfects[this.settings.openEffect].in, (function () {
            i.settings.autoplayVideos && i.slidePlayerPlay(e), i.trigger("slide_changed", {
              prev: l,
              current: o
            }), T(i.settings.afterSlideChange) && i.settings.afterSlideChange.apply(i, [l, o])
          }));
          else {
            var r = this.settings.slideEffect,
              a = "none" !== r ? this.settings.cssEfects[r].in : r;
            this.prevActiveSlideIndex > this.index && "slide" == this.settings.slideEffect && (a = this.settings.cssEfects.slideBack.in), g(e, a, (function () {
              i.settings.autoplayVideos && i.slidePlayerPlay(e), i.trigger("slide_changed", {
                prev: l,
                current: o
              }), T(i.settings.afterSlideChange) && i.settings.afterSlideChange.apply(i, [l, o])
            }))
          }
          setTimeout((function () {
            i.resize(e)
          }), 100), h(e, "current")
        }
      }, {
        key: "slideAnimateOut",
        value: function () {
          if (!this.prevActiveSlide) return !1;
          var e = this.prevActiveSlide;
          d(e, this.effectsClasses), h(e, "prev");
          var t = this.settings.slideEffect,
            i = "none" !== t ? this.settings.cssEfects[t].out : t;
          this.slidePlayerPause(e), this.trigger("slide_before_change", {
            prev: {
              index: this.prevActiveSlideIndex,
              slide: this.prevActiveSlide,
              slideNode: this.prevActiveSlide,
              slideIndex: this.prevActiveSlideIndex,
              slideConfig: I(this.prevActiveSlideIndex) ? null : this.elements[this.prevActiveSlideIndex].slideConfig,
              trigger: I(this.prevActiveSlideIndex) ? null : this.elements[this.prevActiveSlideIndex].node,
              player: this.getSlidePlayerInstance(this.prevActiveSlideIndex)
            },
            current: {
              index: this.index,
              slide: this.activeSlide,
              slideNode: this.activeSlide,
              slideIndex: this.index,
              slideConfig: this.elements[this.index].slideConfig,
              trigger: this.elements[this.index].node,
              player: this.getSlidePlayerInstance(this.index)
            }
          }), T(this.settings.beforeSlideChange) && this.settings.beforeSlideChange.apply(this, [{
            index: this.prevActiveSlideIndex,
            slide: this.prevActiveSlide,
            player: this.getSlidePlayerInstance(this.prevActiveSlideIndex)
          }, {
            index: this.index,
            slide: this.activeSlide,
            player: this.getSlidePlayerInstance(this.index)
          }]), this.prevActiveSlideIndex > this.index && "slide" == this.settings.slideEffect && (i = this.settings.cssEfects.slideBack.out), g(e, i, (function () {
            var t = e.querySelector(".ginner-container"),
              i = e.querySelector(".gslide-media"),
              n = e.querySelector(".gslide-description");
            t.style.transform = "", i.style.transform = "", d(i, "greset"), i.style.opacity = "", n && (n.style.opacity = ""), d(e, "prev")
          }))
        }
      }, {
        key: "getAllPlayers",
        value: function () {
          return this.videoPlayers
        }
      }, {
        key: "getSlidePlayerInstance",
        value: function (e) {
          var t = "gvideo" + e,
            i = this.getAllPlayers();
          return !(!O(i, t) || !i[t]) && i[t]
        }
      }, {
        key: "stopSlideVideo",
        value: function (e) {
          if (k(e)) {
            var t = e.querySelector(".gvideo-wrapper");
            t && (e = t.getAttribute("data-index"))
          }
          console.log("stopSlideVideo is deprecated, use slidePlayerPause");
          var i = this.getSlidePlayerInstance(e);
          i && i.playing && i.pause()
        }
      }, {
        key: "slidePlayerPause",
        value: function (e) {
          if (k(e)) {
            var t = e.querySelector(".gvideo-wrapper");
            t && (e = t.getAttribute("data-index"))
          }
          var i = this.getSlidePlayerInstance(e);
          i && i.playing && i.pause()
        }
      }, {
        key: "playSlideVideo",
        value: function (e) {
          if (k(e)) {
            var t = e.querySelector(".gvideo-wrapper");
            t && (e = t.getAttribute("data-index"))
          }
          console.log("playSlideVideo is deprecated, use slidePlayerPlay");
          var i = this.getSlidePlayerInstance(e);
          i && !i.playing && i.play()
        }
      }, {
        key: "slidePlayerPlay",
        value: function (e) {
          var t;
          if (!J || null !== (t = this.settings.plyr.config) && void 0 !== t && t.muted) {
            if (k(e)) {
              var i = e.querySelector(".gvideo-wrapper");
              i && (e = i.getAttribute("data-index"))
            }
            var n = this.getSlidePlayerInstance(e);
            n && !n.playing && (n.play(), this.settings.autofocusVideos && n.elements.container.focus())
          }
        }
      }, {
        key: "setElements",
        value: function (e) {
          var t = this;
          this.settings.elements = !1;
          var i = [];
          e && e.length && o(e, (function (e, n) {
            var s = new $(e, t, n),
              o = s.getConfig(),
              r = l({}, o);
            r.slideConfig = o, r.instance = s, r.index = n, i.push(r)
          })), this.elements = i, this.lightboxOpen && (this.slidesContainer.innerHTML = "", this.elements.length && (o(this.elements, (function () {
            var e = m(t.settings.slideHTML);
            t.slidesContainer.appendChild(e)
          })), this.showSlide(0, !0)))
        }
      }, {
        key: "getElementIndex",
        value: function (e) {
          var t = !1;
          return o(this.elements, (function (i, n) {
            if (O(i, "node") && i.node == e) return t = n, !0
          })), t
        }
      }, {
        key: "getElements",
        value: function () {
          var e = this,
            t = [];
          this.elements = this.elements ? this.elements : [], !I(this.settings.elements) && E(this.settings.elements) && this.settings.elements.length && o(this.settings.elements, (function (i, n) {
            var s = new $(i, e, n),
              o = s.getConfig(),
              r = l({}, o);
            r.node = !1, r.index = n, r.instance = s, r.slideConfig = o, t.push(r)
          }));
          var i = !1;
          return this.getSelector() && (i = document.querySelectorAll(this.getSelector())), i ? (o(i, (function (i, n) {
            var s = new $(i, e, n),
              o = s.getConfig(),
              r = l({}, o);
            r.node = i, r.index = n, r.instance = s, r.slideConfig = o, r.gallery = i.getAttribute("data-gallery"), t.push(r)
          })), t) : t
        }
      }, {
        key: "getGalleryElements",
        value: function (e, t) {
          return e.filter((function (e) {
            return e.gallery == t
          }))
        }
      }, {
        key: "getSelector",
        value: function () {
          return !this.settings.elements && (this.settings.selector && "data-" == this.settings.selector.substring(0, 5) ? "*[".concat(this.settings.selector, "]") : this.settings.selector)
        }
      }, {
        key: "getActiveSlide",
        value: function () {
          return this.slidesContainer.querySelectorAll(".gslide")[this.index]
        }
      }, {
        key: "getActiveSlideIndex",
        value: function () {
          return this.index
        }
      }, {
        key: "getAnimationClasses",
        value: function () {
          var e = [];
          for (var t in this.settings.cssEfects)
            if (this.settings.cssEfects.hasOwnProperty(t)) {
              var i = this.settings.cssEfects[t];
              e.push("g".concat(i.in)), e.push("g".concat(i.out))
            } return e.join(" ")
        }
      }, {
        key: "build",
        value: function () {
          var e = this;
          if (this.built) return !1;
          var t = document.body.childNodes,
            i = [];
          o(t, (function (e) {
            e.parentNode == document.body && "#" !== e.nodeName.charAt(0) && e.hasAttribute && !e.hasAttribute("aria-hidden") && (i.push(e), e.setAttribute("aria-hidden", "true"))
          }));
          var n = O(this.settings.svg, "next") ? this.settings.svg.next : "",
            s = O(this.settings.svg, "prev") ? this.settings.svg.prev : "",
            l = O(this.settings.svg, "close") ? this.settings.svg.close : "",
            r = this.settings.lightboxHTML;
          r = m(r = (r = (r = r.replace(/{nextSVG}/g, n)).replace(/{prevSVG}/g, s)).replace(/{closeSVG}/g, l)), document.body.appendChild(r);
          var d = document.getElementById("glightbox-body");
          this.modal = d;
          var g = d.querySelector(".gclose");
          this.prevButton = d.querySelector(".gprev"), this.nextButton = d.querySelector(".gnext"), this.overlay = d.querySelector(".goverlay"), this.loader = d.querySelector(".gloader"), this.slidesContainer = document.getElementById("glightbox-slider"), this.bodyHiddenChildElms = i, this.events = {}, h(this.modal, "glightbox-" + this.settings.skin), this.settings.closeButton && g && (this.events.close = a("click", {
            onElement: g,
            withCallback: function (t, i) {
              t.preventDefault(), e.close()
            }
          })), g && !this.settings.closeButton && g.parentNode.removeChild(g), this.nextButton && (this.events.next = a("click", {
            onElement: this.nextButton,
            withCallback: function (t, i) {
              t.preventDefault(), e.nextSlide()
            }
          })), this.prevButton && (this.events.prev = a("click", {
            onElement: this.prevButton,
            withCallback: function (t, i) {
              t.preventDefault(), e.prevSlide()
            }
          })), this.settings.closeOnOutsideClick && (this.events.outClose = a("click", {
            onElement: d,
            withCallback: function (t, i) {
              e.preventOutsideClick || c(document.body, "glightbox-mobile") || u(t.target, ".ginner-container") || u(t.target, ".gbtn") || c(t.target, "gnext") || c(t.target, "gprev") || e.close()
            }
          })), o(this.elements, (function (t, i) {
            e.slidesContainer.appendChild(t.instance.create()), t.slideNode = e.slidesContainer.querySelectorAll(".gslide")[i]
          })), K && h(document.body, "glightbox-touch"), this.events.resize = a("resize", {
            onElement: window,
            withCallback: function () {
              e.resize()
            }
          }), this.built = !0
        }
      }, {
        key: "resize",
        value: function () {
          var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
          if ((e = e || this.activeSlide) && !c(e, "zoomed")) {
            var t = y(),
              i = e.querySelector(".gvideo-wrapper"),
              n = e.querySelector(".gslide-image"),
              s = this.slideDescription,
              l = t.width,
              o = t.height;
            if (l <= 768 ? h(document.body, "glightbox-mobile") : d(document.body, "glightbox-mobile"), i || n) {
              var r = !1;
              if (s && (c(s, "description-bottom") || c(s, "description-top")) && !c(s, "gabsolute") && (r = !0), n)
                if (l <= 768) n.querySelector("img");
                else if (r) {
                var a = s.offsetHeight,
                  u = n.querySelector("img");
                u.setAttribute("style", "max-height: calc(100vh - ".concat(a, "px)")), s.setAttribute("style", "max-width: ".concat(u.offsetWidth, "px;"))
              }
              if (i) {
                var g = O(this.settings.plyr.config, "ratio") ? this.settings.plyr.config.ratio : "";
                if (!g) {
                  var v = i.clientWidth,
                    f = i.clientHeight,
                    p = v / f;
                  g = "".concat(v / p, ":").concat(f / p)
                }
                var m = g.split(":"),
                  x = this.settings.videosWidth,
                  b = this.settings.videosWidth,
                  S = (b = M(x) || -1 !== x.indexOf("px") ? parseInt(x) : -1 !== x.indexOf("vw") ? l * parseInt(x) / 100 : -1 !== x.indexOf("vh") ? o * parseInt(x) / 100 : -1 !== x.indexOf("%") ? l * parseInt(x) / 100 : parseInt(i.clientWidth)) / (parseInt(m[0]) / parseInt(m[1]));
                if (S = Math.floor(S), r && (o -= s.offsetHeight), b > l || S > o || o < S && l > b) {
                  var w = i.offsetWidth,
                    T = i.offsetHeight,
                    C = o / T,
                    k = {
                      width: w * C,
                      height: T * C
                    };
                  i.parentNode.setAttribute("style", "max-width: ".concat(k.width, "px")), r && s.setAttribute("style", "max-width: ".concat(k.width, "px;"))
                } else i.parentNode.style.maxWidth = "".concat(x), r && s.setAttribute("style", "max-width: ".concat(x, ";"))
              }
            }
          }
        }
      }, {
        key: "reload",
        value: function () {
          this.init()
        }
      }, {
        key: "updateNavigationClasses",
        value: function () {
          var e = this.loop();
          d(this.nextButton, "disabled"), d(this.prevButton, "disabled"), 0 == this.index && this.elements.length - 1 == 0 ? (h(this.prevButton, "disabled"), h(this.nextButton, "disabled")) : 0 !== this.index || e ? this.index !== this.elements.length - 1 || e || h(this.nextButton, "disabled") : h(this.prevButton, "disabled")
        }
      }, {
        key: "loop",
        value: function () {
          var e = O(this.settings, "loopAtEnd") ? this.settings.loopAtEnd : null;
          return e = O(this.settings, "loop") ? this.settings.loop : e, e
        }
      }, {
        key: "close",
        value: function () {
          var e = this;
          if (!this.lightboxOpen) {
            if (this.events) {
              for (var t in this.events) this.events.hasOwnProperty(t) && this.events[t].destroy();
              this.events = null
            }
            return !1
          }
          if (this.closing) return !1;
          this.closing = !0, this.slidePlayerPause(this.activeSlide), this.fullElementsList && (this.elements = this.fullElementsList), this.bodyHiddenChildElms.length && o(this.bodyHiddenChildElms, (function (e) {
            e.removeAttribute("aria-hidden")
          })), h(this.modal, "glightbox-closing"), g(this.overlay, "none" == this.settings.openEffect ? "none" : this.settings.cssEfects.fade.out), g(this.activeSlide, this.settings.cssEfects[this.settings.closeEffect].out, (function () {
            if (e.activeSlide = null, e.prevActiveSlideIndex = null, e.prevActiveSlide = null, e.built = !1, e.events) {
              for (var t in e.events) e.events.hasOwnProperty(t) && e.events[t].destroy();
              e.events = null
            }
            var i = document.body;
            d(Q, "glightbox-open"), d(i, "glightbox-open touching gdesc-open glightbox-touch glightbox-mobile gscrollbar-fixer"), e.modal.parentNode.removeChild(e.modal), e.trigger("close"), T(e.settings.onClose) && e.settings.onClose();
            var n = document.querySelector(".gcss-styles");
            n && n.parentNode.removeChild(n), e.lightboxOpen = !1, e.closing = null
          }))
        }
      }, {
        key: "destroy",
        value: function () {
          this.close(), this.clearAllEvents(), this.baseEvents && this.baseEvents.destroy()
        }
      }, {
        key: "on",
        value: function (e, t) {
          var i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
          if (!e || !T(t)) throw new TypeError("Event name and callback must be defined");
          this.apiEvents.push({
            evt: e,
            once: i,
            callback: t
          })
        }
      }, {
        key: "once",
        value: function (e, t) {
          this.on(e, t, !0)
        }
      }, {
        key: "trigger",
        value: function (e) {
          var t = this,
            i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
            n = [];
          o(this.apiEvents, (function (t, s) {
            var l = t.evt,
              o = t.once,
              r = t.callback;
            l == e && (r(i), o && n.push(s))
          })), n.length && o(n, (function (e) {
            return t.apiEvents.splice(e, 1)
          }))
        }
      }, {
        key: "clearAllEvents",
        value: function () {
          this.apiEvents.splice(0, this.apiEvents.length)
        }
      }, {
        key: "version",
        value: function () {
          return "3.1.0"
        }
      }]), e
    }();
  return function () {
    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
      t = new te(e);
    return t.init(), t
  }
}));
/*!
 * OverlayScrollbars
 * https://github.com/KingSora/OverlayScrollbars
 *
 * Version: 1.13.3
 *
 * Copyright KingSora | Rene Haas.
 * https://github.com/KingSora
 *
 * Released under the MIT license.
 * Date: 20.07.2022
 */
! function (n, t) {
  "function" == typeof define && define.amd ? define(function () {
    return t(n, n.document, undefined)
  }) : "object" == typeof module && "object" == typeof module.exports ? module.exports = t(n, n.document, undefined) : t(n, n.document, undefined)
}("undefined" != typeof window ? window : this, function (vi, hi, di) {
  "use strict";
  var o, l, a, u, pi = "object",
    bi = "function",
    mi = "array",
    gi = "string",
    wi = "boolean",
    yi = "number",
    f = "undefined",
    n = "null",
    xi = {
      c: "class",
      s: "style",
      i: "id",
      l: "length",
      p: "prototype",
      ti: "tabindex",
      oH: "offsetHeight",
      cH: "clientHeight",
      sH: "scrollHeight",
      oW: "offsetWidth",
      cW: "clientWidth",
      sW: "scrollWidth",
      hOP: "hasOwnProperty",
      bCR: "getBoundingClientRect"
    },
    _i = (o = {}, l = {}, {
      e: a = ["-webkit-", "-moz-", "-o-", "-ms-"],
      u: u = ["WebKit", "Moz", "O", "MS"],
      v: function (n) {
        var t = l[n];
        if (l[xi.hOP](n)) return t;
        for (var r, e, i, o = c(n), u = hi.createElement("div")[xi.s], f = 0; f < a.length; f++)
          for (i = a[f].replace(/-/g, ""), r = [n, a[f] + n, i + o, c(i) + o], e = 0; e < r[xi.l]; e++)
            if (u[r[e]] !== di) {
              t = r[e];
              break
            } return l[n] = t
      },
      d: function (n, t, r) {
        var e = n + " " + t,
          i = l[e];
        if (l[xi.hOP](e)) return i;
        for (var o, u = hi.createElement("div")[xi.s], f = t.split(" "), a = r || "", c = 0, s = -1; c < f[xi.l]; c++)
          for (; s < _i.e[xi.l]; s++)
            if (o = s < 0 ? f[c] : _i.e[s] + f[c], u.cssText = n + ":" + o + a, u[xi.l]) {
              i = o;
              break
            } return l[e] = i
      },
      m: function (n, t, r) {
        var e = 0,
          i = o[n];
        if (!o[xi.hOP](n)) {
          for (i = vi[n]; e < u[xi.l]; e++) i = i || vi[(t ? u[e] : u[e].toLowerCase()) + c(n)];
          o[n] = i
        }
        return i || r
      }
    });

  function c(n) {
    return n.charAt(0).toUpperCase() + n.slice(1)
  }
  var Oi = {
    wW: r(t, 0, !0),
    wH: r(t, 0),
    mO: r(_i.m, 0, "MutationObserver", !0),
    rO: r(_i.m, 0, "ResizeObserver", !0),
    rAF: r(_i.m, 0, "requestAnimationFrame", !1, function (n) {
      return vi.setTimeout(n, 1e3 / 60)
    }),
    cAF: r(_i.m, 0, "cancelAnimationFrame", !1, function (n) {
      return vi.clearTimeout(n)
    }),
    now: function () {
      return Date.now && Date.now() || (new Date).getTime()
    },
    stpP: function (n) {
      n.stopPropagation ? n.stopPropagation() : n.cancelBubble = !0
    },
    prvD: function (n) {
      n.preventDefault && n.cancelable ? n.preventDefault() : n.returnValue = !1
    },
    page: function (n) {
      var t = ((n = n.originalEvent || n).target || n.srcElement || hi).ownerDocument || hi,
        r = t.documentElement,
        e = t.body;
      if (n.touches === di) return !n.pageX && n.clientX && null != n.clientX ? {
        x: n.clientX + (r && r.scrollLeft || e && e.scrollLeft || 0) - (r && r.clientLeft || e && e.clientLeft || 0),
        y: n.clientY + (r && r.scrollTop || e && e.scrollTop || 0) - (r && r.clientTop || e && e.clientTop || 0)
      } : {
        x: n.pageX,
        y: n.pageY
      };
      var i = n.touches[0];
      return {
        x: i.pageX,
        y: i.pageY
      }
    },
    mBtn: function (n) {
      var t = n.button;
      return n.which || t === di ? n.which : 1 & t ? 1 : 2 & t ? 3 : 4 & t ? 2 : 0
    },
    inA: function (n, t) {
      for (var r = 0; r < t[xi.l]; r++) try {
        if (t[r] === n) return r
      } catch (e) {}
      return -1
    },
    isA: function (n) {
      var t = Array.isArray;
      return t ? t(n) : this.type(n) == mi
    },
    type: function (n) {
      return n === di || null === n ? n + "" : Object[xi.p].toString.call(n).replace(/^\[object (.+)\]$/, "$1").toLowerCase()
    },
    bind: r
  };

  function t(n) {
    return n ? vi.innerWidth || hi.documentElement[xi.cW] || hi.body[xi.cW] : vi.innerHeight || hi.documentElement[xi.cH] || hi.body[xi.cH]
  }

  function r(n, t) {
    if (typeof n != bi) throw "Can't bind function!";
    var r = xi.p,
      e = Array[r].slice.call(arguments, 2),
      i = function () {},
      o = function () {
        return n.apply(this instanceof i ? this : t, e.concat(Array[r].slice.call(arguments)))
      };
    return n[r] && (i[r] = n[r]), o[r] = new i, o
  }
  var s, v, h, k, I, T, d, p, Si = Math,
    zi = vi.jQuery,
    A = (s = {
      p: Si.PI,
      c: Si.cos,
      s: Si.sin,
      w: Si.pow,
      t: Si.sqrt,
      n: Si.asin,
      a: Si.abs,
      o: 1.70158
    }, {
      swing: function (n, t, r, e, i) {
        return .5 - s.c(n * s.p) / 2
      },
      linear: function (n, t, r, e, i) {
        return n
      },
      easeInQuad: function (n, t, r, e, i) {
        return e * (t /= i) * t + r
      },
      easeOutQuad: function (n, t, r, e, i) {
        return -e * (t /= i) * (t - 2) + r
      },
      easeInOutQuad: function (n, t, r, e, i) {
        return (t /= i / 2) < 1 ? e / 2 * t * t + r : -e / 2 * (--t * (t - 2) - 1) + r
      },
      easeInCubic: function (n, t, r, e, i) {
        return e * (t /= i) * t * t + r
      },
      easeOutCubic: function (n, t, r, e, i) {
        return e * ((t = t / i - 1) * t * t + 1) + r
      },
      easeInOutCubic: function (n, t, r, e, i) {
        return (t /= i / 2) < 1 ? e / 2 * t * t * t + r : e / 2 * ((t -= 2) * t * t + 2) + r
      },
      easeInQuart: function (n, t, r, e, i) {
        return e * (t /= i) * t * t * t + r
      },
      easeOutQuart: function (n, t, r, e, i) {
        return -e * ((t = t / i - 1) * t * t * t - 1) + r
      },
      easeInOutQuart: function (n, t, r, e, i) {
        return (t /= i / 2) < 1 ? e / 2 * t * t * t * t + r : -e / 2 * ((t -= 2) * t * t * t - 2) + r
      },
      easeInQuint: function (n, t, r, e, i) {
        return e * (t /= i) * t * t * t * t + r
      },
      easeOutQuint: function (n, t, r, e, i) {
        return e * ((t = t / i - 1) * t * t * t * t + 1) + r
      },
      easeInOutQuint: function (n, t, r, e, i) {
        return (t /= i / 2) < 1 ? e / 2 * t * t * t * t * t + r : e / 2 * ((t -= 2) * t * t * t * t + 2) + r
      },
      easeInSine: function (n, t, r, e, i) {
        return -e * s.c(t / i * (s.p / 2)) + e + r
      },
      easeOutSine: function (n, t, r, e, i) {
        return e * s.s(t / i * (s.p / 2)) + r
      },
      easeInOutSine: function (n, t, r, e, i) {
        return -e / 2 * (s.c(s.p * t / i) - 1) + r
      },
      easeInExpo: function (n, t, r, e, i) {
        return 0 == t ? r : e * s.w(2, 10 * (t / i - 1)) + r
      },
      easeOutExpo: function (n, t, r, e, i) {
        return t == i ? r + e : e * (1 - s.w(2, -10 * t / i)) + r
      },
      easeInOutExpo: function (n, t, r, e, i) {
        return 0 == t ? r : t == i ? r + e : (t /= i / 2) < 1 ? e / 2 * s.w(2, 10 * (t - 1)) + r : e / 2 * (2 - s.w(2, -10 * --t)) + r
      },
      easeInCirc: function (n, t, r, e, i) {
        return -e * (s.t(1 - (t /= i) * t) - 1) + r
      },
      easeOutCirc: function (n, t, r, e, i) {
        return e * s.t(1 - (t = t / i - 1) * t) + r
      },
      easeInOutCirc: function (n, t, r, e, i) {
        return (t /= i / 2) < 1 ? -e / 2 * (s.t(1 - t * t) - 1) + r : e / 2 * (s.t(1 - (t -= 2) * t) + 1) + r
      },
      easeInElastic: function (n, t, r, e, i) {
        var o = s.o,
          u = 0,
          f = e;
        return 0 == t ? r : 1 == (t /= i) ? r + e : (u = u || .3 * i, o = f < s.a(e) ? (f = e, u / 4) : u / (2 * s.p) * s.n(e / f), -(f * s.w(2, 10 * --t) * s.s((t * i - o) * (2 * s.p) / u)) + r)
      },
      easeOutElastic: function (n, t, r, e, i) {
        var o = s.o,
          u = 0,
          f = e;
        return 0 == t ? r : 1 == (t /= i) ? r + e : (u = u || .3 * i, o = f < s.a(e) ? (f = e, u / 4) : u / (2 * s.p) * s.n(e / f), f * s.w(2, -10 * t) * s.s((t * i - o) * (2 * s.p) / u) + e + r)
      },
      easeInOutElastic: function (n, t, r, e, i) {
        var o = s.o,
          u = 0,
          f = e;
        return 0 == t ? r : 2 == (t /= i / 2) ? r + e : (u = u || i * (.3 * 1.5), o = f < s.a(e) ? (f = e, u / 4) : u / (2 * s.p) * s.n(e / f), t < 1 ? f * s.w(2, 10 * --t) * s.s((t * i - o) * (2 * s.p) / u) * -.5 + r : f * s.w(2, -10 * --t) * s.s((t * i - o) * (2 * s.p) / u) * .5 + e + r)
      },
      easeInBack: function (n, t, r, e, i, o) {
        return e * (t /= i) * t * (((o = o || s.o) + 1) * t - o) + r
      },
      easeOutBack: function (n, t, r, e, i, o) {
        return e * ((t = t / i - 1) * t * (((o = o || s.o) + 1) * t + o) + 1) + r
      },
      easeInOutBack: function (n, t, r, e, i, o) {
        return o = o || s.o, (t /= i / 2) < 1 ? e / 2 * (t * t * ((1 + (o *= 1.525)) * t - o)) + r : e / 2 * ((t -= 2) * t * ((1 + (o *= 1.525)) * t + o) + 2) + r
      },
      easeInBounce: function (n, t, r, e, i) {
        return e - this.easeOutBounce(n, i - t, 0, e, i) + r
      },
      easeOutBounce: function (n, t, r, e, i) {
        var o = 7.5625;
        return (t /= i) < 1 / 2.75 ? e * (o * t * t) + r : t < 2 / 2.75 ? e * (o * (t -= 1.5 / 2.75) * t + .75) + r : t < 2.5 / 2.75 ? e * (o * (t -= 2.25 / 2.75) * t + .9375) + r : e * (o * (t -= 2.625 / 2.75) * t + .984375) + r
      },
      easeInOutBounce: function (n, t, r, e, i) {
        return t < i / 2 ? .5 * this.easeInBounce(n, 2 * t, 0, e, i) + r : .5 * this.easeOutBounce(n, 2 * t - i, 0, e, i) + .5 * e + r
      }
    }),
    Ci = (v = /[^\x20\t\r\n\f]+/g, h = " ", k = "scrollLeft", I = "scrollTop", T = [], d = Oi.type, p = {
      animationIterationCount: !0,
      columnCount: !0,
      fillOpacity: !0,
      flexGrow: !0,
      flexShrink: !0,
      fontWeight: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0
    }, M[xi.p] = {
      on: function (t, r) {
        var e, i = (t = (t || "").match(v) || [""])[xi.l],
          o = 0;
        return this.each(function () {
          e = this;
          try {
            if (e.addEventListener)
              for (; o < i; o++) e.addEventListener(t[o], r);
            else if (e.detachEvent)
              for (; o < i; o++) e.attachEvent("on" + t[o], r)
          } catch (n) {}
        })
      },
      off: function (t, r) {
        var e, i = (t = (t || "").match(v) || [""])[xi.l],
          o = 0;
        return this.each(function () {
          e = this;
          try {
            if (e.removeEventListener)
              for (; o < i; o++) e.removeEventListener(t[o], r);
            else if (e.detachEvent)
              for (; o < i; o++) e.detachEvent("on" + t[o], r)
          } catch (n) {}
        })
      },
      one: function (n, i) {
        return n = (n || "").match(v) || [""], this.each(function () {
          var e = M(this);
          M.each(n, function (n, t) {
            var r = function (n) {
              i.call(this, n), e.off(t, r)
            };
            e.on(t, r)
          })
        })
      },
      trigger: function (n) {
        var t, r;
        return this.each(function () {
          t = this, hi.createEvent ? ((r = hi.createEvent("HTMLEvents")).initEvent(n, !0, !1), t.dispatchEvent(r)) : t.fireEvent("on" + n)
        })
      },
      append: function (n) {
        return this.each(function () {
          i(this, "beforeend", n)
        })
      },
      prepend: function (n) {
        return this.each(function () {
          i(this, "afterbegin", n)
        })
      },
      before: function (n) {
        return this.each(function () {
          i(this, "beforebegin", n)
        })
      },
      after: function (n) {
        return this.each(function () {
          i(this, "afterend", n)
        })
      },
      remove: function () {
        return this.each(function () {
          var n = this.parentNode;
          null != n && n.removeChild(this)
        })
      },
      unwrap: function () {
        var n, t, r, e = [];
        for (this.each(function () {
            -1 === H(r = this.parentNode, e) && e.push(r)
          }), n = 0; n < e[xi.l]; n++) {
          for (t = e[n], r = t.parentNode; t.firstChild;) r.insertBefore(t.firstChild, t);
          r.removeChild(t)
        }
        return this
      },
      wrapAll: function (n) {
        for (var t, r = this, e = M(n)[0], i = e, o = r[0].parentNode, u = r[0].previousSibling; 0 < i.childNodes[xi.l];) i = i.childNodes[0];
        for (t = 0; r[xi.l] - t; i.firstChild === r[0] && t++) i.appendChild(r[t]);
        var f = u ? u.nextSibling : o.firstChild;
        return o.insertBefore(e, f), this
      },
      wrapInner: function (r) {
        return this.each(function () {
          var n = M(this),
            t = n.contents();
          t[xi.l] ? t.wrapAll(r) : n.append(r)
        })
      },
      wrap: function (n) {
        return this.each(function () {
          M(this).wrapAll(n)
        })
      },
      css: function (n, t) {
        var r, e, i, o = vi.getComputedStyle;
        return d(n) == gi ? t === di ? (r = this[0], i = o ? o(r, null) : r.currentStyle[n], o ? null != i ? i.getPropertyValue(n) : r[xi.s][n] : i) : this.each(function () {
          y(this, n, t)
        }) : this.each(function () {
          for (e in n) y(this, e, n[e])
        })
      },
      hasClass: function (n) {
        for (var t, r, e = 0, i = h + n + h; t = this[e++];) {
          if ((r = t.classList) && r.contains(n)) return !0;
          if (1 === t.nodeType && -1 < (h + g(t.className + "") + h).indexOf(i)) return !0
        }
        return !1
      },
      addClass: function (n) {
        var t, r, e, i, o, u, f, a, c = 0,
          s = 0;
        if (n)
          for (t = n.match(v) || []; r = this[c++];)
            if (a = r.classList, f === di && (f = a !== di), f)
              for (; o = t[s++];) a.add(o);
            else if (i = r.className + "", e = 1 === r.nodeType && h + g(i) + h) {
          for (; o = t[s++];) e.indexOf(h + o + h) < 0 && (e += o + h);
          i !== (u = g(e)) && (r.className = u)
        }
        return this
      },
      removeClass: function (n) {
        var t, r, e, i, o, u, f, a, c = 0,
          s = 0;
        if (n)
          for (t = n.match(v) || []; r = this[c++];)
            if (a = r.classList, f === di && (f = a !== di), f)
              for (; o = t[s++];) a.remove(o);
            else if (i = r.className + "", e = 1 === r.nodeType && h + g(i) + h) {
          for (; o = t[s++];)
            for (; - 1 < e.indexOf(h + o + h);) e = e.replace(h + o + h, h);
          i !== (u = g(e)) && (r.className = u)
        }
        return this
      },
      hide: function () {
        return this.each(function () {
          this[xi.s].display = "none"
        })
      },
      show: function () {
        return this.each(function () {
          this[xi.s].display = "block"
        })
      },
      attr: function (n, t) {
        for (var r, e = 0; r = this[e++];) {
          if (t === di) return r.getAttribute(n);
          r.setAttribute(n, t)
        }
        return this
      },
      removeAttr: function (n) {
        return this.each(function () {
          this.removeAttribute(n)
        })
      },
      offset: function () {
        var n = this[0][xi.bCR](),
          t = vi.pageXOffset || hi.documentElement[k],
          r = vi.pageYOffset || hi.documentElement[I];
        return {
          top: n.top + r,
          left: n.left + t
        }
      },
      position: function () {
        var n = this[0];
        return {
          top: n.offsetTop,
          left: n.offsetLeft
        }
      },
      scrollLeft: function (n) {
        for (var t, r = 0; t = this[r++];) {
          if (n === di) return t[k];
          t[k] = n
        }
        return this
      },
      scrollTop: function (n) {
        for (var t, r = 0; t = this[r++];) {
          if (n === di) return t[I];
          t[I] = n
        }
        return this
      },
      val: function (n) {
        var t = this[0];
        return n ? (t.value = n, this) : t.value
      },
      first: function () {
        return this.eq(0)
      },
      last: function () {
        return this.eq(-1)
      },
      eq: function (n) {
        return M(this[0 <= n ? n : this[xi.l] + n])
      },
      find: function (t) {
        var r, e = [];
        return this.each(function () {
          var n = this.querySelectorAll(t);
          for (r = 0; r < n[xi.l]; r++) e.push(n[r])
        }), M(e)
      },
      children: function (n) {
        var t, r, e, i = [];
        return this.each(function () {
          for (r = this.children, e = 0; e < r[xi.l]; e++) t = r[e], (!n || t.matches && t.matches(n) || w(t, n)) && i.push(t)
        }), M(i)
      },
      parent: function (n) {
        var t, r = [];
        return this.each(function () {
          t = this.parentNode, n && !M(t).is(n) || r.push(t)
        }), M(r)
      },
      is: function (n) {
        var t, r;
        for (r = 0; r < this[xi.l]; r++) {
          if (t = this[r], ":visible" === n) return _(t);
          if (":hidden" === n) return !_(t);
          if (t.matches && t.matches(n) || w(t, n)) return !0
        }
        return !1
      },
      contents: function () {
        var n, t, r = [];
        return this.each(function () {
          for (n = this.childNodes, t = 0; t < n[xi.l]; t++) r.push(n[t])
        }), M(r)
      },
      each: function (n) {
        return e(this, n)
      },
      animate: function (n, t, r, e) {
        return this.each(function () {
          x(this, n, t, r, e)
        })
      },
      stop: function (n, t) {
        return this.each(function () {
          ! function f(n, t, r) {
            for (var e, i, o, u = 0; u < T[xi.l]; u++)
              if ((e = T[u]).el === n) {
                if (0 < e.q[xi.l]) {
                  if ((i = e.q[0]).stop = !0, Oi.cAF()(i.frame), e.q.splice(0, 1), r)
                    for (o in i.props) W(n, o, i.props[o]);
                  t ? e.q = [] : N(e, !1)
                }
                break
              }
          }(this, n, t)
        })
      }
    }, b(M, {
      extend: b,
      inArray: H,
      isEmptyObject: L,
      isPlainObject: R,
      each: e
    }), M);

  function b() {
    var n, t, r, e, i, o, u = arguments[0] || {},
      f = 1,
      a = arguments[xi.l],
      c = !1;
    for (d(u) == wi && (c = u, u = arguments[1] || {}, f = 2), d(u) != pi && !d(u) == bi && (u = {}), a === f && (u = M, --f); f < a; f++)
      if (null != (i = arguments[f]))
        for (e in i) n = u[e], u !== (r = i[e]) && (c && r && (R(r) || (t = Oi.isA(r))) ? (o = t ? (t = !1, n && Oi.isA(n) ? n : []) : n && R(n) ? n : {}, u[e] = b(c, o, r)) : r !== di && (u[e] = r));
    return u
  }

  function H(n, t, r) {
    for (var e = r || 0; e < t[xi.l]; e++)
      if (t[e] === n) return e;
    return -1
  }

  function E(n) {
    return d(n) == bi
  }

  function L(n) {
    for (var t in n) return !1;
    return !0
  }

  function R(n) {
    if (!n || d(n) != pi) return !1;
    var t, r = xi.p,
      e = Object[r].hasOwnProperty,
      i = e.call(n, "constructor"),
      o = n.constructor && n.constructor[r] && e.call(n.constructor[r], "isPrototypeOf");
    if (n.constructor && !i && !o) return !1;
    for (t in n);
    return d(t) == f || e.call(n, t)
  }

  function e(n, t) {
    var r = 0;
    if (m(n))
      for (; r < n[xi.l] && !1 !== t.call(n[r], r, n[r]); r++);
    else
      for (r in n)
        if (!1 === t.call(n[r], r, n[r])) break;
    return n
  }

  function m(n) {
    var t = !!n && [xi.l] in n && n[xi.l],
      r = d(n);
    return !E(r) && (r == mi || 0 === t || d(t) == yi && 0 < t && t - 1 in n)
  }

  function g(n) {
    return (n.match(v) || []).join(h)
  }

  function w(n, t) {
    for (var r = (n.parentNode || hi).querySelectorAll(t) || [], e = r[xi.l]; e--;)
      if (r[e] == n) return 1
  }

  function i(n, t, r) {
    if (Oi.isA(r))
      for (var e = 0; e < r[xi.l]; e++) i(n, t, r[e]);
    else d(r) == gi ? n.insertAdjacentHTML(t, r) : n.insertAdjacentElement(t, r.nodeType ? r : r[0])
  }

  function y(n, t, r) {
    try {
      n[xi.s][t] !== di && (n[xi.s][t] = function e(n, t) {
        p[n.toLowerCase()] || d(t) != yi || (t += "px");
        return t
      }(t, r))
    } catch (i) {}
  }

  function N(n, t) {
    var r, e;
    !1 !== t && n.q.splice(0, 1), 0 < n.q[xi.l] ? (e = n.q[0], x(n.el, e.props, e.duration, e.easing, e.complete, !0)) : -1 < (r = H(n, T)) && T.splice(r, 1)
  }

  function W(n, t, r) {
    t === k || t === I ? n[t] = r : y(n, t, r)
  }

  function x(n, t, r, e, i, o) {
    var u, f, a, c, s, l, v = R(r),
      h = {},
      d = {},
      p = 0;
    for (l = v ? (e = r.easing, r.start, a = r.progress, c = r.step, s = r.specialEasing, i = r.complete, r.duration) : r, s = s || {}, l = l || 400, e = e || "swing", o = o || !1; p < T[xi.l]; p++)
      if (T[p].el === n) {
        f = T[p];
        break
      } for (u in f || (f = {
        el: n,
        q: []
      }, T.push(f)), t) h[u] = u === k || u === I ? n[u] : M(n).css(u);
    for (u in h) h[u] !== t[u] && t[u] !== di && (d[u] = t[u]);
    if (L(d)) o && N(f);
    else {
      var b, m, g, w, y, x, _, O, S, z = o ? 0 : H(C, f.q),
        C = {
          props: d,
          duration: v ? r : l,
          easing: e,
          complete: i
        };
      if (-1 === z && (z = f.q[xi.l], f.q.push(C)), 0 === z)
        if (0 < l) _ = Oi.now(), O = function () {
          for (u in b = Oi.now(), S = b - _, m = C.stop || l <= S, g = 1 - (Si.max(0, _ + l - b) / l || 0), d) w = parseFloat(h[u]), y = parseFloat(d[u]), x = (y - w) * A[s[u] || e](g, g * l, 0, 1, l) + w, W(n, u, x), E(c) && c(x, {
            elem: n,
            prop: u,
            start: w,
            now: x,
            end: y,
            pos: g,
            options: {
              easing: e,
              speacialEasing: s,
              duration: l,
              complete: i,
              step: c
            },
            startTime: _
          });
          E(a) && a({}, g, Si.max(0, l - S)), m ? (N(f), E(i) && i()) : C.frame = Oi.rAF()(O)
        }, C.frame = Oi.rAF()(O);
        else {
          for (u in d) W(n, u, d[u]);
          N(f)
        }
    }
  }

  function _(n) {
    return !!(n[xi.oW] || n[xi.oH] || n.getClientRects()[xi.l])
  }

  function M(n) {
    if (0 === arguments[xi.l]) return this;
    var t, r, e = new M,
      i = n,
      o = 0;
    if (d(n) == gi)
      for (i = [], t = "<" === n.charAt(0) ? ((r = hi.createElement("div")).innerHTML = n, r.children) : hi.querySelectorAll(n); o < t[xi.l]; o++) i.push(t[o]);
    if (i) {
      for (d(i) == gi || m(i) && i !== vi && i !== i.self || (i = [i]), o = 0; o < i[xi.l]; o++) e[o] = i[o];
      e[xi.l] = i[xi.l]
    }
    return e
  }
  var O, S, ki, z, C, D, F, P, j, B, Q, U, V, $, Ii, Ti = (O = [], S = "__overlayScrollbars__", function (n, t) {
      var r = arguments[xi.l];
      if (r < 1) return O;
      if (t) n[S] = t, O.push(n);
      else {
        var e = Oi.inA(n, O);
        if (-1 < e) {
          if (!(1 < r)) return O[e][S];
          delete n[S], O.splice(e, 1)
        }
      }
    }),
    q = ($ = [], D = Oi.type, U = {
      className: ["os-theme-dark", [n, gi]],
      resize: ["none", "n:none b:both h:horizontal v:vertical"],
      sizeAutoCapable: P = [!0, wi],
      clipAlways: P,
      normalizeRTL: P,
      paddingAbsolute: j = [!(F = [wi, yi, gi, mi, pi, bi, n]), wi],
      autoUpdate: [null, [n, wi]],
      autoUpdateInterval: [33, yi],
      updateOnLoad: [
        ["img"],
        [gi, mi, n]
      ],
      nativeScrollbarsOverlaid: {
        showNativeScrollbars: j,
        initialize: P
      },
      overflowBehavior: {
        x: ["scroll", Q = "v-h:visible-hidden v-s:visible-scroll s:scroll h:hidden"],
        y: ["scroll", Q]
      },
      scrollbars: {
        visibility: ["auto", "v:visible h:hidden a:auto"],
        autoHide: ["never", "n:never s:scroll l:leave m:move"],
        autoHideDelay: [800, yi],
        dragScrolling: P,
        clickScrolling: j,
        touchSupport: P,
        snapHandle: j
      },
      textarea: {
        dynWidth: j,
        dynHeight: j,
        inheritedAttrs: [
          ["style", "class"],
          [gi, mi, n]
        ]
      },
      callbacks: {
        onInitialized: B = [null, [n, bi]],
        onInitializationWithdrawn: B,
        onDestroyed: B,
        onScrollStart: B,
        onScroll: B,
        onScrollStop: B,
        onOverflowChanged: B,
        onOverflowAmountChanged: B,
        onDirectionChanged: B,
        onContentSizeChanged: B,
        onHostSizeChanged: B,
        onUpdated: B
      }
    }, Ii = {
      g: (V = function (i) {
        var o = function (n) {
          var t, r, e;
          for (t in n) n[xi.hOP](t) && (r = n[t], (e = D(r)) == mi ? n[t] = r[i ? 1 : 0] : e == pi && (n[t] = o(r)));
          return n
        };
        return o(Ci.extend(!0, {}, U))
      })(),
      _: V(!0),
      O: function (n, t, I, r) {
        var e = {},
          i = {},
          o = Ci.extend(!0, {}, n),
          T = Ci.inArray,
          A = Ci.isEmptyObject,
          H = function (n, t, r, e, i, o) {
            for (var u in t)
              if (t[xi.hOP](u) && n[xi.hOP](u)) {
                var f, a, c, s, l, v, h, d, p = !1,
                  b = !1,
                  m = t[u],
                  g = D(m),
                  w = g == pi,
                  y = Oi.isA(m) ? m : [m],
                  x = r[u],
                  _ = n[u],
                  O = D(_),
                  S = o ? o + "." : "",
                  z = 'The option "' + S + u + "\" wasn't set, because",
                  C = [],
                  k = [];
                if (x = x === di ? {} : x, w && O == pi) e[u] = {}, i[u] = {}, H(_, m, x, e[u], i[u], S + u), Ci.each([n, e, i], function (n, t) {
                  A(t[u]) && delete t[u]
                });
                else if (!w) {
                  for (v = 0; v < y[xi.l]; v++)
                    if (l = y[v], c = (g = D(l)) == gi && -1 === T(l, F))
                      for (C.push(gi), f = l.split(" "), k = k.concat(f), h = 0; h < f[xi.l]; h++) {
                        for (s = (a = f[h].split(":"))[0], d = 0; d < a[xi.l]; d++)
                          if (_ === a[d]) {
                            p = !0;
                            break
                          } if (p) break
                      } else if (C.push(l), O === l) {
                        p = !0;
                        break
                      } p ? ((b = _ !== x) && (e[u] = _), (c ? T(x, a) < 0 : b) && (i[u] = c ? s : _)) : I && console.warn(z + " it doesn't accept the type [ " + O.toUpperCase() + ' ] with the value of "' + _ + '".\r\nAccepted types are: [ ' + C.join(", ").toUpperCase() + " ]." + (0 < k[length] ? "\r\nValid strings are: [ " + k.join(", ").split(":").join(", ") + " ]." : "")), delete n[u]
                }
              }
          };
        return H(o, t, r || {}, e, i), !A(o) && I && console.warn("The following options are discarded due to invalidity:\r\n" + vi.JSON.stringify(o, null, 2)), {
          S: e,
          z: i
        }
      }
    }, (ki = vi.OverlayScrollbars = function (n, r, e) {
      if (0 === arguments[xi.l]) return this;
      var i, t, o = [],
        u = Ci.isPlainObject(r);
      return n ? (n = n[xi.l] != di ? n : [n[0] || n], X(), 0 < n[xi.l] && (u ? Ci.each(n, function (n, t) {
        (i = t) !== di && o.push(K(i, r, e, z, C))
      }) : Ci.each(n, function (n, t) {
        i = Ti(t), ("!" === r && ki.valid(i) || Oi.type(r) == bi && r(t, i) || r === di) && o.push(i)
      }), t = 1 === o[xi.l] ? o[0] : o), t) : u || !r ? t : o
    }).globals = function () {
      X();
      var n = Ci.extend(!0, {}, z);
      return delete n.msie, n
    }, ki.defaultOptions = function (n) {
      X();
      var t = z.defaultOptions;
      if (n === di) return Ci.extend(!0, {}, t);
      z.defaultOptions = Ci.extend(!0, {}, t, Ii.O(n, Ii._, !0, t).S)
    }, ki.valid = function (n) {
      return n instanceof ki && !n.getState().destroyed
    }, ki.extension = function (n, t, r) {
      var e = Oi.type(n) == gi,
        i = arguments[xi.l],
        o = 0;
      if (i < 1 || !e) return Ci.extend(!0, {
        length: $[xi.l]
      }, $);
      if (e)
        if (Oi.type(t) == bi) $.push({
          name: n,
          extensionFactory: t,
          defaultOptions: r
        });
        else
          for (; o < $[xi.l]; o++)
            if ($[o].name === n) {
              if (!(1 < i)) return Ci.extend(!0, {}, $[o]);
              $.splice(o, 1)
            }
    }, ki);

  function X() {
    z = z || new Y(Ii.g), C = C || new G(z)
  }

  function Y(n) {
    var _ = this,
      i = "overflow",
      O = Ci("body"),
      S = Ci('<div id="os-dummy-scrollbar-size"><div></div></div>'),
      o = S[0],
      e = Ci(S.children("div").eq(0));
    O.append(S), S.hide().show();
    var t, r, u, f, a, c, s, l, v, h = z(o),
      d = {
        x: 0 === h.x,
        y: 0 === h.y
      },
      p = (r = vi.navigator.userAgent, f = "substring", a = r[u = "indexOf"]("MSIE "), c = r[u]("Trident/"), s = r[u]("Edge/"), l = r[u]("rv:"), v = parseInt, 0 < a ? t = v(r[f](a + 5, r[u](".", a)), 10) : 0 < c ? t = v(r[f](l + 3, r[u](".", l)), 10) : 0 < s && (t = v(r[f](s + 5, r[u](".", s)), 10)), t);

    function z(n) {
      return {
        x: n[xi.oH] - n[xi.cH],
        y: n[xi.oW] - n[xi.cW]
      }
    }
    Ci.extend(_, {
        defaultOptions: n,
        msie: p,
        autoUpdateLoop: !1,
        autoUpdateRecommended: !Oi.mO(),
        nativeScrollbarSize: h,
        nativeScrollbarIsOverlaid: d,
        nativeScrollbarStyling: function () {
          var n = !1;
          S.addClass("os-viewport-native-scrollbars-invisible");
          try {
            n = "none" === S.css("scrollbar-width") && (9 < p || !p) || "none" === vi.getComputedStyle(o, "::-webkit-scrollbar").getPropertyValue("display")
          } catch (t) {}
          return n
        }(),
        overlayScrollbarDummySize: {
          x: 30,
          y: 30
        },
        cssCalc: _i.d("width", "calc", "(1px)") || null,
        restrictedMeasuring: function () {
          S.css(i, "hidden");
          var n = o[xi.sW],
            t = o[xi.sH];
          S.css(i, "visible");
          var r = o[xi.sW],
            e = o[xi.sH];
          return n - r != 0 || t - e != 0
        }(),
        rtlScrollBehavior: function () {
          S.css({
            "overflow-y": "hidden",
            "overflow-x": "scroll",
            direction: "rtl"
          }).scrollLeft(0);
          var n = S.offset(),
            t = e.offset();
          S.scrollLeft(-999);
          var r = e.offset();
          return {
            i: n.left === t.left,
            n: t.left !== r.left
          }
        }(),
        supportTransform: !!_i.v("transform"),
        supportTransition: !!_i.v("transition"),
        supportPassiveEvents: function () {
          var n = !1;
          try {
            vi.addEventListener("test", null, Object.defineProperty({}, "passive", {
              get: function () {
                n = !0
              }
            }))
          } catch (t) {}
          return n
        }(),
        supportResizeObserver: !!Oi.rO(),
        supportMutationObserver: !!Oi.mO()
      }), S.removeAttr(xi.s).remove(),
      function () {
        if (!d.x || !d.y) {
          var m = Si.abs,
            g = Oi.wW(),
            w = Oi.wH(),
            y = x();
          Ci(vi).on("resize", function () {
            if (0 < Ti().length) {
              var n = Oi.wW(),
                t = Oi.wH(),
                r = n - g,
                e = t - w;
              if (0 == r && 0 == e) return;
              var i, o = Si.round(n / (g / 100)),
                u = Si.round(t / (w / 100)),
                f = m(r),
                a = m(e),
                c = m(o),
                s = m(u),
                l = x(),
                v = 2 < f && 2 < a,
                h = ! function b(n, t) {
                  var r = m(n),
                    e = m(t);
                  return r !== e && r + 1 !== e && r - 1 !== e
                }(c, s),
                d = v && h && (l !== y && 0 < y),
                p = _.nativeScrollbarSize;
              d && (O.append(S), i = _.nativeScrollbarSize = z(S[0]), S.remove(), p.x === i.x && p.y === i.y || Ci.each(Ti(), function () {
                Ti(this) && Ti(this).update("zoom")
              })), g = n, w = t, y = l
            }
          })
        }

        function x() {
          var n = vi.screen.deviceXDPI || 0,
            t = vi.screen.logicalXDPI || 1;
          return vi.devicePixelRatio || n / t
        }
      }()
  }

  function G(r) {
    var c, e = Ci.inArray,
      s = Oi.now,
      l = "autoUpdate",
      v = xi.l,
      h = [],
      d = [],
      p = !1,
      b = 33,
      m = s(),
      g = function () {
        if (0 < h[v] && p) {
          c = Oi.rAF()(function () {
            g()
          });
          var n, t, r, e, i, o, u = s(),
            f = u - m;
          if (b < f) {
            m = u - f % b, n = 33;
            for (var a = 0; a < h[v]; a++)(t = h[a]) !== di && (e = (r = t.options())[l], i = Si.max(1, r.autoUpdateInterval), o = s(), (!0 === e || null === e) && o - d[a] > i && (t.update("auto"), d[a] = new Date(o += i)), n = Si.max(1, Si.min(n, i)));
            b = n
          }
        } else b = 33
      };
    this.add = function (n) {
      -1 === e(n, h) && (h.push(n), d.push(s()), 0 < h[v] && !p && (p = !0, r.autoUpdateLoop = p, g()))
    }, this.remove = function (n) {
      var t = e(n, h); - 1 < t && (d.splice(t, 1), h.splice(t, 1), 0 === h[v] && p && (p = !1, r.autoUpdateLoop = p, c !== di && (Oi.cAF()(c), c = -1)))
    }
  }

  function K(r, n, t, xt, _t) {
    var cn = Oi.type,
      sn = Ci.inArray,
      h = Ci.each,
      Ot = new ki,
      e = Ci[xi.p];
    if (ht(r)) {
      if (Ti(r)) {
        var i = Ti(r);
        return i.options(n), i
      }
      var St, zt, Ct, kt, D, It, Tt, At, F, ln, w, T, d, Ht, Et, Lt, Rt, y, p, Nt, Wt, Mt, Dt, Ft, Pt, jt, Bt, Qt, Ut, o, u, Vt, $t, qt, f, P, c, j, Xt, Yt, Gt, Kt, Jt, Zt, nr, tr, rr, er, ir, a, s, l, v, b, m, x, A, or, ur, fr, H, ar, cr, sr, lr, vr, hr, dr, pr, br, mr, gr, wr, yr, xr, _r, E, Or, Sr, zr, Cr, kr, Ir, Tr, Ar, g, _, Hr, Er, Lr, Rr, Nr, Wr, Mr, Dr, Fr, Pr, jr, Br, Qr, Ur, O, S, z, C, Vr, $r, k, I, qr, Xr, Yr, Gr, Kr, B, Q, Jr, Zr, ne, te, re = {},
        vn = {},
        hn = {},
        ee = {},
        ie = {},
        L = "-hidden",
        oe = "margin-",
        ue = "padding-",
        fe = "border-",
        ae = "top",
        ce = "right",
        se = "bottom",
        le = "left",
        ve = "min-",
        he = "max-",
        de = "width",
        pe = "height",
        be = "float",
        me = "",
        ge = "auto",
        dn = "sync",
        we = "scroll",
        ye = "100%",
        pn = "x",
        bn = "y",
        R = ".",
        xe = " ",
        N = "scrollbar",
        W = "-horizontal",
        M = "-vertical",
        _e = we + "Left",
        Oe = we + "Top",
        U = "mousedown touchstart",
        V = "mouseup touchend touchcancel",
        $ = "mousemove touchmove",
        q = "mouseenter",
        X = "mouseleave",
        Y = "keydown",
        G = "keyup",
        K = "selectstart",
        J = "transitionend webkitTransitionEnd oTransitionEnd",
        Z = "__overlayScrollbarsRO__",
        nn = "os-",
        tn = "os-html",
        rn = "os-host",
        en = rn + "-foreign",
        on = rn + "-textarea",
        un = rn + "-" + N + W + L,
        fn = rn + "-" + N + M + L,
        an = rn + "-transition",
        Se = rn + "-rtl",
        ze = rn + "-resize-disabled",
        Ce = rn + "-scrolling",
        ke = rn + "-overflow",
        Ie = (ke = rn + "-overflow") + "-x",
        Te = ke + "-y",
        mn = "os-textarea",
        gn = mn + "-cover",
        wn = "os-padding",
        yn = "os-viewport",
        Ae = yn + "-native-scrollbars-invisible",
        xn = yn + "-native-scrollbars-overlaid",
        _n = "os-content",
        He = "os-content-arrange",
        Ee = "os-content-glue",
        Le = "os-size-auto-observer",
        On = "os-resize-observer",
        Sn = "os-resize-observer-item",
        zn = Sn + "-final",
        Cn = "os-text-inherit",
        kn = nn + N,
        In = kn + "-track",
        Tn = In + "-off",
        An = kn + "-handle",
        Hn = An + "-off",
        En = kn + "-unusable",
        Ln = kn + "-" + ge + L,
        Rn = kn + "-corner",
        Re = Rn + "-resize",
        Ne = Re + "-both",
        We = Re + W,
        Me = Re + M,
        Nn = kn + W,
        Wn = kn + M,
        Mn = "os-dragging",
        De = "os-theme-none",
        Dn = [Ae, xn, Tn, Hn, En, Ln, Re, Ne, We, Me, Mn].join(xe),
        Fn = [],
        Pn = [xi.ti],
        jn = {},
        Fe = {},
        Pe = 42,
        Bn = "load",
        Qn = [],
        Un = {},
        Vn = ["wrap", "cols", "rows"],
        $n = [xi.i, xi.c, xi.s, "open"].concat(Pn),
        qn = [];
      return Ot.sleep = function () {
        Ut = !0
      }, Ot.update = function (n) {
        var t, r, e, i, o;
        if (!Et) return cn(n) == gi ? n === ge ? (t = function u() {
          if (!Ut && !Vr) {
            var r, e, i, o = [],
              n = [{
                C: Yt,
                k: $n.concat(":visible")
              }, {
                C: Lt ? Xt : di,
                k: Vn
              }];
            return h(n, function (n, t) {
              (r = t.C) && h(t.k, function (n, t) {
                e = ":" === t.charAt(0) ? r.is(t) : r.attr(t), i = Un[t], fi(e, i) && o.push(t), Un[t] = e
              })
            }), it(o), 0 < o[xi.l]
          }
        }(), r = function a() {
          if (Ut) return !1;
          var n, t, r, e, i = oi(),
            o = Lt && br && !Fr ? Xt.val().length : 0,
            u = !Vr && br && !Lt,
            f = {};
          return u && (n = nr.css(be), f[be] = Qt ? ce : le, f[de] = ge, nr.css(f)), e = {
            w: i[xi.sW] + o,
            h: i[xi.sH] + o
          }, u && (f[be] = n, f[de] = ye, nr.css(f)), t = Ve(), r = fi(e, g), g = e, r || t
        }(), (e = t || r) && qe({
          I: r,
          T: Ht ? di : Vt
        })) : n === dn ? Vr ? (i = z(O.takeRecords()), o = C(S.takeRecords())) : i = Ot.update(ge) : "zoom" === n && qe({
          A: !0,
          I: !0
        }) : (n = Ut || n, Ut = !1, Ot.update(dn) && !n || qe({
          H: n
        })), Xe(), e || i || o
      }, Ot.options = function (n, t) {
        var r, e = {};
        if (Ci.isEmptyObject(n) || !Ci.isPlainObject(n)) {
          if (cn(n) != gi) return u;
          if (!(1 < arguments.length)) return bt(u, n);
          ! function a(n, t, r) {
            for (var e = t.split(R), i = e.length, o = 0, u = {}, f = u; o < i; o++) u = u[e[o]] = o + 1 < i ? {} : r;
            Ci.extend(n, f, !0)
          }(e, n, t), r = ot(e)
        } else r = ot(n);
        Ci.isEmptyObject(r) || qe({
          T: r
        })
      }, Ot.destroy = function () {
        if (!Et) {
          for (var n in _t.remove(Ot), Qe(), je(Kt), je(Gt), jn) Ot.removeExt(n);
          for (; 0 < qn[xi.l];) qn.pop()();
          Ue(!0), rr && gt(rr), tr && gt(tr), Wt && gt(Gt), at(!0), st(!0), ut(!0);
          for (var t = 0; t < Qn[xi.l]; t++) Ci(Qn[t]).off(Bn, rt);
          Qn = di, Ut = Et = !0, Ti(r, 0), ti("onDestroyed")
        }
      }, Ot.scroll = function (n, t, r, e) {
        if (0 === arguments.length || n === di) {
          var i = Wr && Qt && Ct.i,
            o = Wr && Qt && Ct.n,
            u = vn.L,
            f = vn.R,
            a = vn.N;
          return f = i ? 1 - f : f, u = i ? a - u : u, a *= o ? -1 : 1, {
            position: {
              x: u *= o ? -1 : 1,
              y: hn.L
            },
            ratio: {
              x: f,
              y: hn.R
            },
            max: {
              x: a,
              y: hn.N
            },
            handleOffset: {
              x: vn.W,
              y: hn.W
            },
            handleLength: {
              x: vn.M,
              y: hn.M
            },
            handleLengthRatio: {
              x: vn.D,
              y: hn.D
            },
            trackLength: {
              x: vn.F,
              y: hn.F
            },
            snappedHandleOffset: {
              x: vn.P,
              y: hn.P
            },
            isRTL: Qt,
            isRTLNormalized: Wr
          }
        }
        Ot.update(dn);
        var c, s, l, v, h, g, w, d, p, y = Wr,
          b = [pn, le, "l"],
          m = [bn, ae, "t"],
          x = ["+=", "-=", "*=", "/="],
          _ = cn(t) == pi,
          O = _ ? t.complete : e,
          S = {},
          z = {},
          C = "begin",
          k = "nearest",
          I = "never",
          T = "ifneeded",
          A = xi.l,
          H = [pn, bn, "xy", "yx"],
          E = [C, "end", "center", k],
          L = ["always", I, T],
          R = n[xi.hOP]("el"),
          N = R ? n.el : n,
          W = !!(N instanceof Ci || zi) && N instanceof zi,
          M = !W && ht(N),
          D = function () {
            s && Je(!0), l && Je(!1)
          },
          F = cn(O) != bi ? di : function () {
            D(), O()
          };

        function P(n, t) {
          for (c = 0; c < t[A]; c++)
            if (n === t[c]) return 1
        }

        function j(n, t) {
          var r = n ? b : m;
          if (t = cn(t) == gi || cn(t) == yi ? [t, t] : t, Oi.isA(t)) return n ? t[0] : t[1];
          if (cn(t) == pi)
            for (c = 0; c < r[A]; c++)
              if (r[c] in t) return t[r[c]]
        }

        function B(n, t) {
          var r, e, i, o, u = cn(t) == gi,
            f = n ? vn : hn,
            a = f.L,
            c = f.N,
            s = Qt && n,
            l = s && Ct.n && !y,
            v = "replace",
            h = eval;
          if ((e = u ? (2 < t[A] && (o = t.substr(0, 2), -1 < sn(o, x) && (r = o)), t = (t = r ? t.substr(2) : t)[v](/min/g, 0)[v](/</g, 0)[v](/max/g, (l ? "-" : me) + ye)[v](/>/g, (l ? "-" : me) + ye)[v](/px/g, me)[v](/%/g, " * " + c * (s && Ct.n ? -1 : 1) / 100)[v](/vw/g, " * " + ee.w)[v](/vh/g, " * " + ee.h), ii(isNaN(t) ? ii(h(t), !0).toFixed() : t)) : t) !== di && !isNaN(e) && cn(e) == yi) {
            var d = y && s,
              p = a * (d && Ct.n ? -1 : 1),
              b = d && Ct.i,
              m = d && Ct.n;
            switch (p = b ? c - p : p, r) {
              case "+=":
                i = p + e;
                break;
              case "-=":
                i = p - e;
                break;
              case "*=":
                i = p * e;
                break;
              case "/=":
                i = p / e;
                break;
              default:
                i = e
            }
            i = b ? c - i : i, i *= m ? -1 : 1, i = s && Ct.n ? Si.min(0, Si.max(c, i)) : Si.max(0, Si.min(c, i))
          }
          return i === a ? di : i
        }

        function Q(n, t, r, e) {
          var i, o, u = [r, r],
            f = cn(n);
          if (f == t) n = [n, n];
          else if (f == mi) {
            if (2 < (i = n[A]) || i < 1) n = u;
            else
              for (1 === i && (n[1] = r), c = 0; c < i; c++)
                if (o = n[c], cn(o) != t || !P(o, e)) {
                  n = u;
                  break
                }
          } else n = f == pi ? [n[pn] || r, n[bn] || r] : u;
          return {
            x: n[0],
            y: n[1]
          }
        }

        function U(n) {
          var t, r, e = [],
            i = [ae, ce, se, le];
          for (c = 0; c < n[A] && c !== i[A]; c++) t = n[c], (r = cn(t)) == wi ? e.push(t ? ii(p.css(oe + i[c])) : 0) : e.push(r == yi ? t : 0);
          return e
        }
        if (W || M) {
          var V, $ = R ? n.margin : 0,
            q = R ? n.axis : 0,
            X = R ? n.scroll : 0,
            Y = R ? n.block : 0,
            G = [0, 0, 0, 0],
            K = cn($);
          if (0 < (p = W ? N : Ci(N))[A]) {
            $ = K == yi || K == wi ? U([$, $, $, $]) : K == mi ? 2 === (V = $[A]) ? U([$[0], $[1], $[0], $[1]]) : 4 <= V ? U($) : G : K == pi ? U([$[ae], $[ce], $[se], $[le]]) : G, h = P(q, H) ? q : "xy", g = Q(X, gi, "always", L), w = Q(Y, gi, C, E), d = $;
            var J = vn.L,
              Z = hn.L,
              nn = Jt.offset(),
              tn = p.offset(),
              rn = {
                x: g.x == I || h == bn,
                y: g.y == I || h == pn
              };
            tn[ae] -= d[0], tn[le] -= d[3];
            var en = {
              x: Si.round(tn[le] - nn[le] + J),
              y: Si.round(tn[ae] - nn[ae] + Z)
            };
            if (Qt && (Ct.n || Ct.i || (en.x = Si.round(nn[le] - tn[le] + J)), Ct.n && y && (en.x *= -1), Ct.i && y && (en.x = Si.round(nn[le] - tn[le] + (vn.N - J)))), w.x != C || w.y != C || g.x == T || g.y == T || Qt) {
              var on = p[0],
                un = ln ? on[xi.bCR]() : {
                  width: on[xi.oW],
                  height: on[xi.oH]
                },
                fn = {
                  w: un[de] + d[3] + d[1],
                  h: un[pe] + d[0] + d[2]
                },
                an = function (n) {
                  var t = ni(n),
                    r = t.j,
                    e = t.B,
                    i = t.Q,
                    o = w[i] == (n && Qt ? C : "end"),
                    u = "center" == w[i],
                    f = w[i] == k,
                    a = g[i] == I,
                    c = g[i] == T,
                    s = ee[r],
                    l = nn[e],
                    v = fn[r],
                    h = tn[e],
                    d = u ? 2 : 1,
                    p = h + v / 2,
                    b = l + s / 2,
                    m = v <= s && l <= h && h + v <= l + s;
                  a ? rn[i] = !0 : rn[i] || ((f || c) && (rn[i] = c && m, o = v < s ? b < p : p < b), en[i] -= o || u ? (s / d - v / d) * (n && Qt && y ? -1 : 1) : 0)
                };
              an(!0), an(!1)
            }
            rn.y && delete en.y, rn.x && delete en.x, n = en
          }
        }
        S[_e] = B(!0, j(!0, n)), S[Oe] = B(!1, j(!1, n)), s = S[_e] !== di, l = S[Oe] !== di, (s || l) && (0 < t || _) ? _ ? (t.complete = F, Zt.animate(S, t)) : (v = {
          duration: t,
          complete: F
        }, Oi.isA(r) || Ci.isPlainObject(r) ? (z[_e] = r[0] || r.x, z[Oe] = r[1] || r.y, v.specialEasing = z) : v.easing = r, Zt.animate(S, v)) : (s && Zt[_e](S[_e]), l && Zt[Oe](S[Oe]), D())
      }, Ot.scrollStop = function (n, t, r) {
        return Zt.stop(n, t, r), Ot
      }, Ot.getElements = function (n) {
        var t = {
          target: or,
          host: ur,
          padding: ar,
          viewport: cr,
          content: sr,
          scrollbarHorizontal: {
            scrollbar: a[0],
            track: s[0],
            handle: l[0]
          },
          scrollbarVertical: {
            scrollbar: v[0],
            track: b[0],
            handle: m[0]
          },
          scrollbarCorner: ir[0]
        };
        return cn(n) == gi ? bt(t, n) : t
      }, Ot.getState = function (n) {
        function t(n) {
          if (!Ci.isPlainObject(n)) return n;
          var r = ai({}, n),
            t = function (n, t) {
              r[xi.hOP](n) && (r[t] = r[n], delete r[n])
            };
          return t("w", de), t("h", pe), delete r.c, r
        }
        var r = {
          destroyed: !!t(Et),
          sleeping: !!t(Ut),
          autoUpdate: t(!Vr),
          widthAuto: t(br),
          heightAuto: t(mr),
          padding: t(wr),
          overflowAmount: t(kr),
          hideOverflow: t(pr),
          hasOverflow: t(dr),
          contentScrollSize: t(vr),
          viewportSize: t(ee),
          hostSize: t(lr),
          documentMixed: t(y)
        };
        return cn(n) == gi ? bt(r, n) : r
      }, Ot.ext = function (n) {
        var t, r = "added removed on contract".split(" "),
          e = 0;
        if (cn(n) == gi) {
          if (jn[xi.hOP](n))
            for (t = ai({}, jn[n]); e < r.length; e++) delete t[r[e]]
        } else
          for (e in t = {}, jn) t[e] = ai({}, Ot.ext(e));
        return t
      }, Ot.addExt = function (n, t) {
        var r, e, i, o, u = ki.extension(n),
          f = !0;
        if (u) {
          if (jn[xi.hOP](n)) return Ot.ext(n);
          if ((r = u.extensionFactory.call(Ot, ai({}, u.defaultOptions), Ci, Oi)) && (i = r.contract, cn(i) == bi && (o = i(vi), f = cn(o) == wi ? o : f), f)) return e = (jn[n] = r).added, cn(e) == bi && e(t), Ot.ext(n)
        } else console.warn('A extension with the name "' + n + "\" isn't registered.")
      }, Ot.removeExt = function (n) {
        var t, r = jn[n];
        return !!r && (delete jn[n], t = r.removed, cn(t) == bi && t(), !0)
      }, ki.valid(function yt(n, t, r) {
        var e, i;
        return o = xt.defaultOptions, It = xt.nativeScrollbarStyling, At = ai({}, xt.nativeScrollbarSize), St = ai({}, xt.nativeScrollbarIsOverlaid), zt = ai({}, xt.overlayScrollbarDummySize), Ct = ai({}, xt.rtlScrollBehavior), ot(ai({}, o, t)), Tt = xt.cssCalc, D = xt.msie, kt = xt.autoUpdateRecommended, F = xt.supportTransition, ln = xt.supportTransform, w = xt.supportPassiveEvents, T = xt.supportResizeObserver, d = xt.supportMutationObserver, xt.restrictedMeasuring, P = Ci(n.ownerDocument), A = P[0], f = Ci(A.defaultView || A.parentWindow), x = f[0], c = wt(P, "html"), j = wt(c, "body"), Xt = Ci(n), or = Xt[0], Lt = Xt.is("textarea"), Rt = Xt.is("body"), y = A !== hi, p = Lt ? Xt.hasClass(mn) && Xt.parent().hasClass(_n) : Xt.hasClass(rn) && Xt.children(R + wn)[xi.l], St.x && St.y && !Vt.nativeScrollbarsOverlaid.initialize ? (Ht = !0, ti("onInitializationWithdrawn"), p && (ut(!0), at(!0), st(!0)), Ut = Et = !(Ht = !1)) : (Rt && ((e = {}).l = Si.max(Xt[_e](), c[_e](), f[_e]()), e.t = Si.max(Xt[Oe](), c[Oe](), f[Oe]()), i = function () {
          Zt.removeAttr(xi.ti), Xn(Zt, U, i, !0, !0)
        }), ut(), at(), st(), ft(), ct(!0), ct(!1), function s() {
          var r, t = x.top !== x,
            e = {},
            i = {},
            o = {};

          function u(n) {
            if (a(n)) {
              var t = c(n),
                r = {};
              (ne || Zr) && (r[de] = i.w + (t.x - e.x) * o.x), (te || Zr) && (r[pe] = i.h + (t.y - e.y) * o.y), Yt.css(r), Oi.stpP(n)
            } else f(n)
          }

          function f(n) {
            var t = n !== di;
            Xn(P, [K, $, V], [tt, u, f], !0), si(j, Mn), ir.releaseCapture && ir.releaseCapture(), t && (r && Be(), Ot.update(ge)), r = !1
          }

          function a(n) {
            var t = (n.originalEvent || n).touches !== di;
            return !Ut && !Et && (1 === Oi.mBtn(n) || t)
          }

          function c(n) {
            return D && t ? {
              x: n.screenX,
              y: n.screenY
            } : Oi.page(n)
          }
          Yn(ir, U, function (n) {
            a(n) && !Jr && (Vr && (r = !0, Qe()), e = c(n), i.w = ur[xi.oW] - (Nt ? 0 : Mt), i.h = ur[xi.oH] - (Nt ? 0 : Dt), o = vt(), Xn(P, [K, $, V], [tt, u, f]), ci(j, Mn), ir.setCapture && ir.setCapture(), Oi.prvD(n), Oi.stpP(n))
          })
        }(), Gn(), je(Kt, Kn), Rt && (Zt[_e](e.l)[Oe](e.t), hi.activeElement == n && cr.focus && (Zt.attr(xi.ti, "-1"), cr.focus(), Xn(Zt, U, i, !1, !0))), Ot.update(ge), Ht = !0, ti("onInitialized"), h(Fn, function (n, t) {
          ti(t.n, t.a)
        }), Fn = [], cn(r) == gi && (r = [r]), Oi.isA(r) ? h(r, function (n, t) {
          Ot.addExt(t)
        }) : Ci.isPlainObject(r) && h(r, function (n, t) {
          Ot.addExt(n, t)
        }), setTimeout(function () {
          F && !Et && ci(Yt, an)
        }, 333)), Ot
      }(r, n, t)) && Ti(r, Ot), Ot
    }

    function Xn(n, t, r, e, i) {
      var o = Oi.isA(t) && Oi.isA(r),
        u = e ? "removeEventListener" : "addEventListener",
        f = e ? "off" : "on",
        a = !o && t.split(xe),
        c = 0,
        s = Ci.isPlainObject(i),
        l = w && (s ? i.U : i) || !1,
        v = s && (i.V || !1),
        h = w ? {
          passive: l,
          capture: v
        } : v;
      if (o)
        for (; c < t[xi.l]; c++) Xn(n, t[c], r[c], e, i);
      else
        for (; c < a[xi.l]; c++) w ? n[0][u](a[c], r, h) : n[f](a[c], r)
    }

    function Yn(n, t, r, e) {
      Xn(n, t, r, !1, e), qn.push(Oi.bind(Xn, 0, n, t, r, !0, e))
    }

    function je(n, t) {
      if (n) {
        var r = Oi.rO(),
          e = "animationstart mozAnimationStart webkitAnimationStart MSAnimationStart",
          i = "childNodes",
          o = 3333333,
          u = function () {
            n[Oe](o)[_e](Qt ? Ct.n ? -o : Ct.i ? 0 : o : o), t()
          };
        if (t) {
          if (T)((k = n.addClass("observed").append(ui(On)).contents()[0])[Z] = new r(u)).observe(k);
          else if (9 < D || !kt) {
            n.prepend(ui(On, ui({
              c: Sn,
              dir: "ltr"
            }, ui(Sn, ui(zn)) + ui(Sn, ui({
              c: zn,
              style: "width: 200%; height: 200%"
            })))));
            var f, a, c, s, l = n[0][i][0][i][0],
              v = Ci(l[i][1]),
              h = Ci(l[i][0]),
              d = Ci(h[0][i][0]),
              p = l[xi.oW],
              b = l[xi.oH],
              m = xt.nativeScrollbarSize,
              g = function () {
                h[_e](o)[Oe](o), v[_e](o)[Oe](o)
              },
              w = function () {
                a = 0, f && (p = c, b = s, u())
              },
              y = function (n) {
                return c = l[xi.oW], s = l[xi.oH], f = c != p || s != b, n && f && !a ? (Oi.cAF()(a), a = Oi.rAF()(w)) : n || w(), g(), n && (Oi.prvD(n), Oi.stpP(n)), !1
              },
              x = {},
              _ = {};
            ri(_, me, [-2 * (m.y + 1), -2 * m.x, -2 * m.y, -2 * (m.x + 1)]), Ci(l).css(_), h.on(we, y), v.on(we, y), n.on(e, function () {
              y(!1)
            }), x[de] = o, x[pe] = o, d.css(x), g()
          } else {
            var O = A.attachEvent,
              S = D !== di;
            if (O) n.prepend(ui(On)), wt(n, R + On)[0].attachEvent("onresize", u);
            else {
              var z = A.createElement(pi);
              z.setAttribute(xi.ti, "-1"), z.setAttribute(xi.c, On), z.onload = function () {
                var n = this.contentDocument.defaultView;
                n.addEventListener("resize", u), n.document.documentElement.style.display = "none"
              }, z.type = "text/html", S && n.prepend(z), z.data = "about:blank", S || n.prepend(z), n.on(e, u)
            }
          }
          if (n[0] === H) {
            var C = function () {
              var n = Yt.css("direction"),
                t = {},
                r = 0,
                e = !1;
              return n !== E && (r = "ltr" === n ? (t[le] = 0, t[ce] = ge, o) : (t[le] = ge, t[ce] = 0, Ct.n ? -o : Ct.i ? 0 : o), Kt.children().eq(0).css(t), Kt[_e](r)[Oe](o), E = n, e = !0), e
            };
            C(), Yn(n, we, function (n) {
              return C() && qe(), Oi.prvD(n), Oi.stpP(n), !1
            })
          }
        } else if (T) {
          var k, I = (k = n.contents()[0])[Z];
          I && (I.disconnect(), delete k[Z])
        } else gt(n.children(R + On).eq(0))
      }
    }

    function Gn() {
      if (d) {
        var o, u, f, a, c, s, r, e, i, l, n = Oi.mO(),
          v = Oi.now();
        C = function (n) {
          var t = !1;
          return Ht && !Ut && (h(n, function () {
            return !(t = function o(n) {
              var t = n.attributeName,
                r = n.target,
                e = n.type,
                i = "closest";
              if (r === sr) return null === t;
              if ("attributes" === e && (t === xi.c || t === xi.s) && !Lt) {
                if (t === xi.c && Ci(r).hasClass(rn)) return et(n.oldValue, r.className);
                if (typeof r[i] != bi) return !0;
                if (null !== r[i](R + On) || null !== r[i](R + kn) || null !== r[i](R + Rn)) return !1
              }
              return !0
            }(this))
          }), t && (e = Oi.now(), i = mr || br, l = function () {
            Et || (v = e, Lt && $e(), i ? qe() : Ot.update(ge))
          }, clearTimeout(r), 11 < e - v || !i ? l() : r = setTimeout(l, 11))), t
        }, O = new n(z = function (n) {
          var t, r = !1,
            e = !1,
            i = [];
          return Ht && !Ut && (h(n, function () {
            o = (t = this).target, u = t.attributeName, f = u === xi.c, a = t.oldValue, c = o.className, p && f && !e && -1 < a.indexOf(en) && c.indexOf(en) < 0 && (s = lt(!0), ur.className = c.split(xe).concat(a.split(xe).filter(function (n) {
              return n.match(s)
            })).join(xe), r = e = !0), r = r || (f ? et(a, c) : u !== xi.s || a !== o[xi.s].cssText), i.push(u)
          }), it(i), r && Ot.update(e || ge)), r
        }), S = new n(C)
      }
    }

    function Be() {
      d && !Vr && (O.observe(ur, {
        attributes: !0,
        attributeOldValue: !0,
        attributeFilter: $n
      }), S.observe(Lt ? or : sr, {
        attributes: !0,
        attributeOldValue: !0,
        subtree: !Lt,
        childList: !Lt,
        characterData: !Lt,
        attributeFilter: Lt ? Vn : $n
      }), Vr = !0)
    }

    function Qe() {
      d && Vr && (O.disconnect(), S.disconnect(), Vr = !1)
    }

    function Kn() {
      if (!Ut) {
        var n, t = {
          w: H[xi.sW],
          h: H[xi.sH]
        };
        n = fi(t, _), _ = t, n && qe({
          A: !0
        })
      }
    }

    function Jn() {
      Kr && Ge(!0)
    }

    function Zn() {
      Kr && !j.hasClass(Mn) && Ge(!1)
    }

    function nt() {
      Gr && (Ge(!0), clearTimeout(I), I = setTimeout(function () {
        Gr && !Et && Ge(!1)
      }, 100))
    }

    function tt(n) {
      return Oi.prvD(n), !1
    }

    function rt(n) {
      if (!Et) {
        var t = n.target,
          r = Ci(n.target),
          e = Ci.inArray(t, Qn); - 1 < e && Qn.splice(e, 1), mt(function (n, t) {
          r.is(t) && qe({
            I: !0
          })
        })
      }
    }

    function Ue(n) {
      n || Ue(!0), Xn(Yt, $.split(xe)[0], nt, !Gr || n, !0), Xn(Yt, [q, X], [Jn, Zn], !Kr || n, !0), Ht || n || Yt.one("mouseover", Jn)
    }

    function Ve() {
      var n = {};
      return Rt && tr && (n.w = ii(tr.css(ve + de)), n.h = ii(tr.css(ve + pe)), n.c = fi(n, Ur), n.f = !0), !!(Ur = n).c
    }

    function et(n, t) {
      var r, e, i = typeof t == gi ? t.split(xe) : [],
        o = function f(n, t) {
          var r, e, i = [],
            o = [];
          for (r = 0; r < n.length; r++) i[n[r]] = !0;
          for (r = 0; r < t.length; r++) i[t[r]] ? delete i[t[r]] : i[t[r]] = !0;
          for (e in i) o.push(e);
          return o
        }(typeof n == gi ? n.split(xe) : [], i),
        u = sn(De, o);
      if (-1 < u && o.splice(u, 1), 0 < o[xi.l])
        for (e = lt(!0, !0), r = 0; r < o.length; r++)
          if (!o[r].match(e)) return !0;
      return !1
    }

    function it(n) {
      h(n = n || Pn, function (n, t) {
        if (-1 < Oi.inA(t, Pn)) {
          var r = Xt.attr(t);
          cn(r) == gi ? Zt.attr(t, r) : Zt.removeAttr(t)
        }
      })
    }

    function $e() {
      if (!Ut) {
        var n, t, r, e, i = !Fr,
          o = ee.w,
          u = ee.h,
          f = {},
          a = br || i;
        return f[ve + de] = me, f[ve + pe] = me, f[de] = ge, Xt.css(f), n = or[xi.oW], t = a ? Si.max(n, or[xi.sW] - 1) : 1, f[de] = br ? ge : ye, f[ve + de] = ye, f[pe] = ge, Xt.css(f), r = or[xi.oH], e = Si.max(r, or[xi.sH] - 1), f[de] = t, f[pe] = e, er.css(f), f[ve + de] = o, f[ve + pe] = u, Xt.css(f), {
          $: n,
          X: r,
          Y: t,
          G: e
        }
      }
    }

    function qe(n) {
      clearTimeout(qt), n = n || {}, Fe.A |= n.A, Fe.I |= n.I, Fe.H |= n.H;
      var t, r = Oi.now(),
        e = !!Fe.A,
        i = !!Fe.I,
        o = !!Fe.H,
        u = n.T,
        f = 0 < Pe && Ht && !Et && !o && !u && r - $t < Pe && !mr && !br;
      if (f && (qt = setTimeout(qe, Pe)), !(Et || f || Ut && !u || Ht && !o && (t = Yt.is(":hidden")) || "inline" === Yt.css("display"))) {
        $t = r, Fe = {}, !It || St.x && St.y ? At = ai({}, xt.nativeScrollbarSize) : (At.x = 0, At.y = 0), ie = {
          x: 3 * (At.x + (St.x ? 0 : 3)),
          y: 3 * (At.y + (St.y ? 0 : 3))
        }, u = u || {};
        var a = function () {
            return fi.apply(this, [].slice.call(arguments).concat([o]))
          },
          c = {
            x: Zt[_e](),
            y: Zt[Oe]()
          },
          s = Vt.scrollbars,
          l = Vt.textarea,
          v = s.visibility,
          h = a(v, Hr),
          d = s.autoHide,
          p = a(d, Er),
          b = s.clickScrolling,
          m = a(b, Lr),
          g = s.dragScrolling,
          w = a(g, Rr),
          y = Vt.className,
          x = a(y, Mr),
          _ = Vt.resize,
          O = a(_, Nr) && !Rt,
          S = Vt.paddingAbsolute,
          z = a(S, Or),
          C = Vt.clipAlways,
          k = a(C, Sr),
          I = Vt.sizeAutoCapable && !Rt,
          T = a(I, Ar),
          A = Vt.nativeScrollbarsOverlaid.showNativeScrollbars,
          H = a(A, Ir),
          E = Vt.autoUpdate,
          L = a(E, Tr),
          R = Vt.overflowBehavior,
          N = a(R, Cr, o),
          W = l.dynWidth,
          M = a(Qr, W),
          D = l.dynHeight,
          F = a(Br, D);
        if (Xr = "n" === d, Yr = "s" === d, Gr = "m" === d, Kr = "l" === d, qr = s.autoHideDelay, Dr = Mr, Jr = "n" === _, Zr = "b" === _, ne = "h" === _, te = "v" === _, Wr = Vt.normalizeRTL, A = A && St.x && St.y, Hr = v, Er = d, Lr = b, Rr = g, Mr = y, Nr = _, Or = S, Sr = C, Ar = I, Ir = A, Tr = E, Cr = ai({}, R), Qr = W, Br = D, dr = dr || {
            x: !1,
            y: !1
          }, x && (si(Yt, Dr + xe + De), ci(Yt, y !== di && null !== y && 0 < y.length ? y : De)), L && (!0 === E || null === E && kt ? (Qe(), _t.add(Ot)) : (_t.remove(Ot), Be())), T)
          if (I)
            if (rr ? rr.show() : (rr = Ci(ui(Ee)), Jt.before(rr)), Wt) Gt.show();
            else {
              Gt = Ci(ui(Le)), fr = Gt[0], rr.before(Gt);
              var P = {
                w: -1,
                h: -1
              };
              je(Gt, function () {
                var n = {
                  w: fr[xi.oW],
                  h: fr[xi.oH]
                };
                fi(n, P) && (Ht && mr && 0 < n.h || br && 0 < n.w || Ht && !mr && 0 === n.h || !br && 0 === n.w) && qe(), P = n
              }), Wt = !0, null !== Tt && Gt.css(pe, Tt + "(100% + 1px)")
            }
        else Wt && Gt.hide(), rr && rr.hide();
        o && (Kt.find("*").trigger(we), Wt && Gt.find("*").trigger(we)), t = t === di ? Yt.is(":hidden") : t;
        var j, B = !!Lt && "off" !== Xt.attr("wrap"),
          Q = a(B, Fr),
          U = Yt.css("direction"),
          V = a(U, _r),
          $ = Yt.css("box-sizing"),
          q = a($, gr),
          X = ei(ue);
        try {
          j = Wt ? fr[xi.bCR]() : null
        } catch (wt) {
          return
        }
        Nt = "border-box" === $;
        var Y = (Qt = "rtl" === U) ? le : ce,
          G = Qt ? ce : le,
          K = !1,
          J = !(!Wt || "none" === Yt.css(be)) && (0 === Si.round(j.right - j.left) && (!!S || 0 < ur[xi.cW] - Mt));
        if (I && !J) {
          var Z = ur[xi.oW],
            nn = rr.css(de);
          rr.css(de, ge);
          var tn = ur[xi.oW];
          rr.css(de, nn), (K = Z !== tn) || (rr.css(de, Z + 1), tn = ur[xi.oW], rr.css(de, nn), K = Z !== tn)
        }
        var rn = (J || K) && I && !t,
          en = a(rn, br),
          on = !rn && br,
          un = !(!Wt || !I || t) && 0 === Si.round(j.bottom - j.top),
          fn = a(un, mr),
          an = !un && mr,
          cn = ei(fe, "-" + de, !(rn && Nt || !Nt), !(un && Nt || !Nt)),
          sn = ei(oe),
          ln = {},
          vn = {},
          hn = function () {
            return {
              w: ur[xi.cW],
              h: ur[xi.cH]
            }
          },
          dn = function () {
            return {
              w: ar[xi.oW] + Si.max(0, sr[xi.cW] - sr[xi.sW]),
              h: ar[xi.oH] + Si.max(0, sr[xi.cH] - sr[xi.sH])
            }
          },
          pn = Mt = X.l + X.r,
          bn = Dt = X.t + X.b;
        if (pn *= S ? 1 : 0, bn *= S ? 1 : 0, X.c = a(X, wr), Ft = cn.l + cn.r, Pt = cn.t + cn.b, cn.c = a(cn, yr), jt = sn.l + sn.r, Bt = sn.t + sn.b, sn.c = a(sn, xr), Fr = B, _r = U, gr = $, br = rn, mr = un, wr = X, yr = cn, xr = sn, V && Wt && Gt.css(be, G), X.c || V || z || en || fn || q || T) {
          var mn = {},
            gn = {},
            wn = [X.t, X.r, X.b, X.l];
          ri(vn, oe, [-X.t, -X.r, -X.b, -X.l]), S ? (ri(mn, me, wn), ri(Lt ? gn : ln, ue)) : (ri(mn, me), ri(Lt ? gn : ln, ue, wn)), Jt.css(mn), Xt.css(gn)
        }
        ee = dn();
        var yn = !!Lt && $e(),
          xn = Lt && a(yn, jr),
          _n = Lt && yn ? {
            w: W ? yn.Y : yn.$,
            h: D ? yn.G : yn.X
          } : {};
        if (jr = yn, un && (fn || z || q || X.c || cn.c) ? ln[pe] = ge : (fn || z) && (ln[pe] = ye), rn && (en || z || q || X.c || cn.c || V) ? (ln[de] = ge, vn[he + de] = ye) : (en || z) && (ln[de] = ye, ln[be] = me, vn[he + de] = me), rn ? (vn[de] = ge, ln[de] = _i.d(de, "max-content intrinsic") || ge, ln[be] = G) : vn[de] = me, vn[pe] = un ? _n.h || sr[xi.cH] : me, I && rr.css(vn), nr.css(ln), ln = {}, vn = {}, e || i || xn || V || q || z || en || rn || fn || un || H || N || k || O || h || p || w || m || M || F || Q) {
          var On = "overflow",
            Sn = On + "-x",
            zn = On + "-y";
          if (!It) {
            var Cn = {},
              kn = dr.y && pr.ys && !A ? St.y ? Zt.css(Y) : -At.y : 0,
              In = dr.x && pr.xs && !A ? St.x ? Zt.css(se) : -At.x : 0;
            ri(Cn, me), Zt.css(Cn)
          }
          var Tn = oi(),
            An = {
              w: _n.w || Tn[xi.cW],
              h: _n.h || Tn[xi.cH]
            },
            Hn = Tn[xi.sW],
            En = Tn[xi.sH];
          It || (Cn[se] = an ? me : In, Cn[Y] = on ? me : kn, Zt.css(Cn)), ee = dn();
          var Ln = hn(),
            Rn = {
              w: Ln.w - jt - Ft - (Nt ? 0 : Mt),
              h: Ln.h - Bt - Pt - (Nt ? 0 : Dt)
            },
            Nn = {
              w: Si.max((rn ? An.w : Hn) + pn, Rn.w),
              h: Si.max((un ? An.h : En) + bn, Rn.h)
            };
          if (Nn.c = a(Nn, zr), zr = Nn, I) {
            (Nn.c || un || rn) && (vn[de] = Nn.w, vn[pe] = Nn.h, Lt || (An = {
              w: Tn[xi.cW],
              h: Tn[xi.cH]
            }));
            var Wn = {},
              Mn = function (n) {
                var t = ni(n),
                  r = t.j,
                  e = t.K,
                  i = n ? rn : un,
                  o = n ? Ft : Pt,
                  u = n ? Mt : Dt,
                  f = n ? jt : Bt,
                  a = ee[r] - o - f - (Nt ? 0 : u);
                i && (i || !cn.c) || (vn[e] = Rn[r] - 1), !(i && An[r] < a) || n && Lt && B || (Lt && (Wn[e] = ii(er.css(e)) - 1), --vn[e]), 0 < An[r] && (vn[e] = Si.max(1, vn[e]))
              };
            Mn(!0), Mn(!1), Lt && er.css(Wn), rr.css(vn)
          }
          rn && (ln[de] = ye), !rn || Nt || Vr || (ln[be] = "none"), nr.css(ln), ln = {};
          var Dn = {
            w: Tn[xi.sW],
            h: Tn[xi.sH]
          };
          Dn.c = i = a(Dn, vr), vr = Dn, ee = dn(), e = a(Ln = hn(), lr), lr = Ln;
          var Fn = Lt && (0 === ee.w || 0 === ee.h),
            Pn = kr,
            jn = {},
            Bn = {},
            Qn = {},
            Un = {},
            Vn = {},
            $n = {},
            qn = {},
            Xn = ar[xi.bCR](),
            Yn = function (n) {
              var t = ni(n),
                r = ni(!n).Q,
                e = t.Q,
                i = t.j,
                o = t.K,
                u = we + t.J + "Max",
                f = Xn[o] ? Si.abs(Xn[o] - ee[i]) : 0,
                a = Pn && 0 < Pn[e] && 0 === cr[u];
              jn[e] = "v-s" === R[e], Bn[e] = "v-h" === R[e], Qn[e] = "s" === R[e], Un[e] = Si.max(0, Si.round(100 * (Dn[i] - ee[i])) / 100), Un[e] *= Fn || a && 0 < f && f < 1 ? 0 : 1, Vn[e] = 0 < Un[e], $n[e] = jn[e] || Bn[e] ? Vn[r] && !jn[r] && !Bn[r] : Vn[e], $n[e + "s"] = !!$n[e] && (Qn[e] || jn[e]), qn[e] = Vn[e] && $n[e + "s"]
            };
          if (Yn(!0), Yn(!1), Un.c = a(Un, kr), kr = Un, Vn.c = a(Vn, dr), dr = Vn, $n.c = a($n, pr), pr = $n, St.x || St.y) {
            var Gn, Kn = {},
              Jn = {},
              Zn = o;
            (Vn.x || Vn.y) && (Jn.w = St.y && Vn.y ? Dn.w + zt.y : me, Jn.h = St.x && Vn.x ? Dn.h + zt.x : me, Zn = a(Jn, hr), hr = Jn), (Vn.c || $n.c || Dn.c || V || en || fn || rn || un || H) && (ln[oe + G] = ln[fe + G] = me, Gn = function (n) {
              var t = ni(n),
                r = ni(!n),
                e = t.Q,
                i = n ? se : Y,
                o = n ? un : rn;
              St[e] && Vn[e] && $n[e + "s"] ? (ln[oe + i] = !o || A ? me : zt[e], ln[fe + i] = n && o || A ? me : zt[e] + "px solid transparent") : (Jn[r.j] = ln[oe + i] = ln[fe + i] = me, Zn = !0)
            }, It ? li(Zt, Ae, !A) : (Gn(!0), Gn(!1))), A && (Jn.w = Jn.h = me, Zn = !0), Zn && !It && (Kn[de] = $n.y ? Jn.w : me, Kn[pe] = $n.x ? Jn.h : me, tr || (tr = Ci(ui(He)), Zt.prepend(tr)), tr.css(Kn)), nr.css(ln)
          }
          var nt, tt = {};
          mn = {};
          if ((e || Vn.c || $n.c || Dn.c || N || q || H || V || k || fn) && (tt[G] = me, (nt = function (n) {
              var t = ni(n),
                r = ni(!n),
                e = t.Q,
                i = t.Z,
                o = n ? se : Y,
                u = function () {
                  tt[o] = me, re[r.j] = 0
                };
              Vn[e] && $n[e + "s"] ? (tt[On + i] = we, A || It ? u() : (tt[o] = -(St[e] ? zt[e] : At[e]), re[r.j] = St[e] ? zt[r.Q] : 0)) : (tt[On + i] = me, u())
            })(!0), nt(!1), !It && (ee.h < ie.x || ee.w < ie.y) && (Vn.x && $n.x && !St.x || Vn.y && $n.y && !St.y) ? (tt[ue + ae] = ie.x, tt[oe + ae] = -ie.x, tt[ue + G] = ie.y, tt[oe + G] = -ie.y) : tt[ue + ae] = tt[oe + ae] = tt[ue + G] = tt[oe + G] = me, tt[ue + Y] = tt[oe + Y] = me, Vn.x && $n.x || Vn.y && $n.y || Fn ? Lt && Fn && (mn[Sn] = mn[zn] = "hidden") : (!C || Bn.x || jn.x || Bn.y || jn.y) && (Lt && (mn[Sn] = mn[zn] = me), tt[Sn] = tt[zn] = "visible"), Jt.css(mn), Zt.css(tt), tt = {}, (Vn.c || q || en || fn) && (!St.x || !St.y))) {
            var rt = sr[xi.s];
            rt.webkitTransform = "scale(1)", rt.display = "run-in", sr[xi.oH], rt.display = me, rt.webkitTransform = me
          }
          if (ln = {}, V || en || fn)
            if (Qt && rn) {
              var et = nr.css(be),
                it = Si.round(nr.css(be, me).css(le, me).position().left);
              nr.css(be, et), it !== Si.round(nr.position().left) && (ln[le] = it)
            } else ln[le] = me;
          if (nr.css(ln), Lt && i) {
            var ot = function yt() {
              var n = or.selectionStart;
              if (n === di) return;
              var t, r, e = Xt.val(),
                i = e[xi.l],
                o = e.split("\n"),
                u = o[xi.l],
                f = e.substr(0, n).split("\n"),
                a = 0,
                c = 0,
                s = f[xi.l],
                l = f[f[xi.l] - 1][xi.l];
              for (r = 0; r < o[xi.l]; r++) t = o[r][xi.l], c < t && (a = r + 1, c = t);
              return {
                nn: s,
                tn: l,
                rn: u,
                en: c,
                "in": a,
                un: n,
                an: i
              }
            }();
            if (ot) {
              var ut = Pr === di || ot.rn !== Pr.rn,
                ft = ot.nn,
                at = ot.tn,
                ct = ot["in"],
                st = ot.rn,
                lt = ot.en,
                vt = ot.un,
                ht = ot.an <= vt && $r,
                dt = {
                  x: B || at !== lt || ft !== ct ? -1 : kr.x,
                  y: (B ? ht || ut && Pn && c.y === Pn.y : (ht || ut) && ft === st) ? kr.y : -1
                };
              c.x = -1 < dt.x ? Qt && Wr && Ct.i ? 0 : dt.x : c.x, c.y = -1 < dt.y ? dt.y : c.y
            }
            Pr = ot
          }
          Qt && Ct.i && St.y && Vn.x && Wr && (c.x += re.w || 0), rn && Yt[_e](0), un && Yt[Oe](0), Zt[_e](c.x)[Oe](c.y);
          var pt = "v" === v,
            bt = "h" === v,
            mt = "a" === v,
            gt = function (n, t) {
              t = t === di ? n : t, Ye(!0, n, qn.x), Ye(!1, t, qn.y)
            };
          li(Yt, ke, $n.x || $n.y), li(Yt, Ie, $n.x), li(Yt, Te, $n.y), V && !Rt && li(Yt, Se, Qt), Rt && ci(Yt, ze), O && (li(Yt, ze, Jr), li(ir, Re, !Jr), li(ir, Ne, Zr), li(ir, We, ne), li(ir, Me, te)), (h || N || $n.c || Vn.c || H) && (A ? H && (si(Yt, Ce), A && gt(!1)) : mt ? gt(qn.x, qn.y) : pt ? gt(!0) : bt && gt(!1)), (p || H) && (Ue(!Kr && !Gr), Ge(Xr, !Xr)), (e || Un.c || fn || en || O || q || z || H || V) && (Ke(!0), Je(!0), Ke(!1), Je(!1)), m && Ze(!0, b), w && Ze(!1, g), ti("onDirectionChanged", {
            isRTL: Qt,
            dir: U
          }, V), ti("onHostSizeChanged", {
            width: lr.w,
            height: lr.h
          }, e), ti("onContentSizeChanged", {
            width: vr.w,
            height: vr.h
          }, i), ti("onOverflowChanged", {
            x: Vn.x,
            y: Vn.y,
            xScrollable: $n.xs,
            yScrollable: $n.ys,
            clipped: $n.x || $n.y
          }, Vn.c || $n.c), ti("onOverflowAmountChanged", {
            x: Un.x,
            y: Un.y
          }, Un.c)
        }
        Rt && Ur && (dr.c || Ur.c) && (Ur.f || Ve(), St.y && dr.x && nr.css(ve + de, Ur.w + zt.y), St.x && dr.y && nr.css(ve + pe, Ur.h + zt.x), Ur.c = !1), Ht && u.updateOnLoad && Xe(), ti("onUpdated", {
          forced: o
        })
      }
    }

    function Xe() {
      Lt || mt(function (n, t) {
        nr.find(t).each(function (n, t) {
          Oi.inA(t, Qn) < 0 && (Qn.push(t), Ci(t).off(Bn, rt).on(Bn, rt))
        })
      })
    }

    function ot(n) {
      var t = Ii.O(n, Ii._, !0, u);
      return u = ai({}, u, t.S), Vt = ai({}, Vt, t.z), t.z
    }

    function ut(e) {
      var n = "parent",
        t = mn + xe + Cn,
        r = Lt ? xe + Cn : me,
        i = Vt.textarea.inheritedAttrs,
        o = {},
        u = function () {
          var r = e ? Xt : Yt;
          h(o, function (n, t) {
            cn(t) == gi && (n == xi.c ? r.addClass(t) : r.attr(n, t))
          })
        },
        f = [rn, en, on, ze, Se, un, fn, an, Ce, ke, Ie, Te, De, mn, Cn, Mr].join(xe),
        a = {};
      Yt = Yt || (Lt ? p ? Xt[n]()[n]()[n]()[n]() : Ci(ui(on)) : Xt), nr = nr || pt(_n + r), Zt = Zt || pt(yn + r), Jt = Jt || pt(wn + r), Kt = Kt || pt("os-resize-observer-host"), er = er || (Lt ? pt(gn) : di), p && ci(Yt, en), e && si(Yt, f), i = cn(i) == gi ? i.split(xe) : i, Oi.isA(i) && Lt && h(i, function (n, t) {
        cn(t) == gi && (o[t] = e ? Yt.attr(t) : Xt.attr(t))
      }), e ? (p && Ht ? (Kt.children().remove(), h([Jt, Zt, nr, er], function (n, t) {
        t && si(t.removeAttr(xi.s), Dn)
      }), ci(Yt, Lt ? on : rn)) : (gt(Kt), nr.contents().unwrap().unwrap().unwrap(), Lt && (Xt.unwrap(), gt(Yt), gt(er), u())), Lt && Xt.removeAttr(xi.s), Rt && si(c, tn)) : (Lt && (Vt.sizeAutoCapable || (a[de] = Xt.css(de), a[pe] = Xt.css(pe)), p || Xt.addClass(Cn).wrap(Yt), Yt = Xt[n]().css(a)), p || (ci(Xt, Lt ? t : rn), Yt.wrapInner(nr).wrapInner(Zt).wrapInner(Jt).prepend(Kt), nr = wt(Yt, R + _n), Zt = wt(Yt, R + yn), Jt = wt(Yt, R + wn), Lt && (nr.prepend(er), u())), It && ci(Zt, Ae), St.x && St.y && ci(Zt, xn), Rt && ci(c, tn), H = Kt[0], ur = Yt[0], ar = Jt[0], cr = Zt[0], sr = nr[0], it())
    }

    function ft() {
      var r, t, e = [112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 123, 33, 34, 37, 38, 39, 40, 16, 17, 18, 19, 20, 144],
        i = [],
        n = "focus";

      function o(n) {
        $e(), Ot.update(ge), n && kt && clearInterval(r)
      }
      Lt ? (9 < D || !kt ? Yn(Xt, "input", o) : Yn(Xt, [Y, G], [function u(n) {
        var t = n.keyCode;
        sn(t, e) < 0 && (i[xi.l] || (o(), r = setInterval(o, 1e3 / 60)), sn(t, i) < 0 && i.push(t))
      }, function f(n) {
        var t = n.keyCode,
          r = sn(t, i);
        sn(t, e) < 0 && (-1 < r && i.splice(r, 1), i[xi.l] || o(!0))
      }]), Yn(Xt, [we, "drop", n, n + "out"], [function a(n) {
        return Xt[_e](Ct.i && Wr ? 9999999 : 0), Xt[Oe](0), Oi.prvD(n), Oi.stpP(n), !1
      }, function c(n) {
        setTimeout(function () {
          Et || o()
        }, 50)
      }, function s() {
        $r = !0, ci(Yt, n)
      }, function l() {
        $r = !1, i = [], si(Yt, n), o(!0)
      }])) : Yn(nr, J, function v(n) {
        !0 !== Tr && function l(n) {
          if (!Ht) return 1;
          var t = "flex-grow",
            r = "flex-shrink",
            e = "flex-basis",
            i = [de, ve + de, he + de, oe + le, oe + ce, le, ce, "font-weight", "word-spacing", t, r, e],
            o = [ue + le, ue + ce, fe + le + de, fe + ce + de],
            u = [pe, ve + pe, he + pe, oe + ae, oe + se, ae, se, "line-height", t, r, e],
            f = [ue + ae, ue + se, fe + ae + de, fe + se + de],
            a = "s" === Cr.x || "v-s" === Cr.x,
            c = !1,
            s = function (n, t) {
              for (var r = 0; r < n[xi.l]; r++)
                if (n[r] === t) return !0;
              return !1
            };
          return ("s" === Cr.y || "v-s" === Cr.y) && ((c = s(u, n)) || Nt || (c = s(f, n))), a && !c && ((c = s(i, n)) || Nt || (c = s(o, n))), c
        }((n = n.originalEvent || n).propertyName) && Ot.update(ge)
      }), Yn(Zt, we, function h(n) {
        Ut || (t !== di ? clearTimeout(t) : ((Yr || Gr) && Ge(!0), dt() || ci(Yt, Ce), ti("onScrollStart", n)), Q || (Je(!0), Je(!1)), ti("onScroll", n), t = setTimeout(function () {
          Et || (clearTimeout(t), t = di, (Yr || Gr) && Ge(!1), dt() || si(Yt, Ce), ti("onScrollStop", n))
        }, 175))
      }, !0)
    }

    function at(i) {
      var n, t, o = function (n) {
        var t = pt(kn + xe + (n ? Nn : Wn), !0),
          r = pt(In, t),
          e = pt(An, t);
        return p || i || (t.append(r), r.append(e)), {
          cn: t,
          sn: r,
          ln: e
        }
      };

      function r(n) {
        var t = ni(n),
          r = t.cn,
          e = t.sn,
          i = t.ln;
        p && Ht ? h([r, e, i], function (n, t) {
          si(t.removeAttr(xi.s), Dn)
        }) : gt(r || o(n).cn)
      }
      i ? (r(!0), r()) : (n = o(!0), t = o(), a = n.cn, s = n.sn, l = n.ln, v = t.cn, b = t.sn, m = t.ln, p || (Jt.after(v), Jt.after(a)))
    }

    function ct(S) {
      var z, i, C, k, e = ni(S),
        I = e.vn,
        t = x.top !== x,
        T = e.Q,
        r = e.Z,
        A = we + e.J,
        o = "active",
        u = "snapHandle",
        f = "click",
        H = 1,
        a = [16, 17];

      function c(n) {
        return D && t ? n["screen" + r] : Oi.page(n)[T]
      }

      function s(n) {
        return Vt.scrollbars[n]
      }

      function l() {
        H = .5
      }

      function v() {
        H = 1
      }

      function h(n) {
        Oi.stpP(n)
      }

      function E(n) {
        -1 < sn(n.keyCode, a) && l()
      }

      function L(n) {
        -1 < sn(n.keyCode, a) && v()
      }

      function R(n) {
        var t = (n.originalEvent || n).touches !== di;
        return !(Ut || Et || dt() || !Rr || t && !s("touchSupport")) && (1 === Oi.mBtn(n) || t)
      }

      function d(n) {
        if (R(n)) {
          var t = I.F,
            r = I.M,
            e = I.N * ((c(n) - C) * k / (t - r));
          e = isFinite(e) ? e : 0, Qt && S && !Ct.i && (e *= -1), Zt[A](Si.round(i + e)), Q && Je(S, i + e), w || Oi.prvD(n)
        } else N(n)
      }

      function N(n) {
        if (n = n || n.originalEvent, Xn(P, [$, V, Y, G, K], [d, N, E, L, tt], !0), Oi.rAF()(function () {
            Xn(P, f, h, !0, {
              V: !0
            })
          }), Q && Je(S, !0), Q = !1, si(j, Mn), si(e.ln, o), si(e.sn, o), si(e.cn, o), k = 1, v(), z !== (C = i = di) && (Ot.scrollStop(), clearTimeout(z), z = di), n) {
          var t = ur[xi.bCR]();
          n.clientX >= t.left && n.clientX <= t.right && n.clientY >= t.top && n.clientY <= t.bottom || Zn(), (Yr || Gr) && Ge(!1)
        }
      }

      function W(n) {
        i = Zt[A](), i = isNaN(i) ? 0 : i, (Qt && S && !Ct.n || !Qt) && (i = i < 0 ? 0 : i), k = vt()[T], C = c(n), Q = !s(u), ci(j, Mn), ci(e.ln, o), ci(e.cn, o), Xn(P, [$, V, K], [d, N, tt]), Oi.rAF()(function () {
          Xn(P, f, h, !1, {
            V: !0
          })
        }), !D && y || Oi.prvD(n), Oi.stpP(n)
      }
      Yn(e.ln, U, function p(n) {
        R(n) && W(n)
      }), Yn(e.sn, [U, q, X], [function M(n) {
        if (R(n)) {
          var h, t = e.vn.M / Math.round(Si.min(1, ee[e.j] / vr[e.j]) * e.vn.F),
            d = Si.round(ee[e.j] * t),
            p = 270 * t,
            b = 400 * t,
            m = e.sn.offset()[e.B],
            r = n.ctrlKey,
            g = n.shiftKey,
            w = g && r,
            y = !0,
            x = function (n) {
              Q && Je(S, n)
            },
            _ = function () {
              x(), W(n)
            },
            O = function () {
              if (!Et) {
                var n = (C - m) * k,
                  t = I.W,
                  r = I.F,
                  e = I.M,
                  i = I.N,
                  o = I.L,
                  u = p * H,
                  f = y ? Si.max(b, u) : u,
                  a = i * ((n - e / 2) / (r - e)),
                  c = Qt && S && (!Ct.i && !Ct.n || Wr),
                  s = c ? t < n : n < t,
                  l = {},
                  v = {
                    easing: "linear",
                    step: function (n) {
                      Q && (Zt[A](n), Je(S, n))
                    }
                  };
                a = isFinite(a) ? a : 0, a = Qt && S && !Ct.i ? i - a : a, g ? (Zt[A](a), w ? (a = Zt[A](), Zt[A](o), a = c && Ct.i ? i - a : a, a = c && Ct.n ? -a : a, l[T] = a, Ot.scroll(l, ai(v, {
                  duration: 130,
                  complete: _
                }))) : _()) : (h = y ? s : h, (c ? h ? n <= t + e : t <= n : h ? t <= n : n <= t + e) ? (clearTimeout(z), Ot.scrollStop(), z = di, x(!0)) : (z = setTimeout(O, f), l[T] = (h ? "-=" : "+=") + d, Ot.scroll(l, ai(v, {
                  duration: u
                }))), y = !1)
              }
            };
          r && l(), k = vt()[T], C = Oi.page(n)[T], Q = !s(u), ci(j, Mn), ci(e.sn, o), ci(e.cn, o), Xn(P, [V, Y, G, K], [N, E, L, tt]), O(), Oi.prvD(n), Oi.stpP(n)
        }
      }, function b(n) {
        B = !0, (Yr || Gr) && Ge(!0)
      }, function m(n) {
        B = !1, (Yr || Gr) && Ge(!1)
      }]), Yn(e.cn, U, function g(n) {
        Oi.stpP(n)
      }), F && Yn(e.cn, J, function (n) {
        n.target === e.cn[0] && (Ke(S), Je(S))
      })
    }

    function Ye(n, t, r) {
      var e = n ? a : v;
      li(Yt, n ? un : fn, !t), li(e, En, !r)
    }

    function Ge(n, t) {
      if (clearTimeout(k), n) si(a, Ln), si(v, Ln);
      else {
        var r, e = function () {
          B || Et || (!(r = l.hasClass("active") || m.hasClass("active")) && (Yr || Gr || Kr) && ci(a, Ln), !r && (Yr || Gr || Kr) && ci(v, Ln))
        };
        0 < qr && !0 !== t ? k = setTimeout(e, qr) : e()
      }
    }

    function Ke(n) {
      var t = {},
        r = ni(n),
        e = r.vn,
        i = Si.min(1, ee[r.j] / vr[r.j]);
      t[r.K] = Si.floor(100 * i * 1e6) / 1e6 + "%", dt() || r.ln.css(t), e.M = r.ln[0]["offset" + r.hn], e.D = i
    }

    function Je(n, t) {
      var r, e, i = cn(t) == wi,
        o = Qt && n,
        u = ni(n),
        f = u.vn,
        a = "translate(",
        c = _i.v("transform"),
        s = _i.v("transition"),
        l = n ? Zt[_e]() : Zt[Oe](),
        v = t === di || i ? l : t,
        h = f.M,
        d = u.sn[0]["offset" + u.hn],
        p = d - h,
        b = {},
        m = (cr[we + u.hn] - cr["client" + u.hn]) * (Ct.n && o ? -1 : 1),
        g = function (n) {
          return isNaN(n / m) ? 0 : Si.max(0, Si.min(1, n / m))
        },
        w = function (n) {
          var t = p * n;
          return t = isNaN(t) ? 0 : t, t = o && !Ct.i ? d - h - t : t, t = Si.max(0, t)
        },
        y = g(l),
        x = w(g(v)),
        _ = w(y);
      f.N = m, f.L = l, f.R = y, ln ? (r = o ? -(d - h - x) : x, e = n ? a + r + "px, 0)" : a + "0, " + r + "px)", b[c] = e, F && (b[s] = i && 1 < Si.abs(x - f.W) ? function O(n) {
        var t = _i.v("transition"),
          r = n.css(t);
        if (r) return r;
        for (var e, i, o, u = "\\s*(([^,(]+(\\(.+?\\))?)+)[\\s,]*", f = new RegExp(u), a = new RegExp("^(" + u + ")+$"), c = "property duration timing-function delay".split(" "), s = [], l = 0, v = function (n) {
            if (e = [], !n.match(a)) return n;
            for (; n.match(f);) e.push(RegExp.$1), n = n.replace(f, me);
            return e
          }; l < c[xi.l]; l++)
          for (i = v(n.css(t + "-" + c[l])), o = 0; o < i[xi.l]; o++) s[o] = (s[o] ? s[o] + xe : me) + i[o];
        return s.join(", ")
      }(u.ln) + ", " + (c + xe + 250) + "ms" : me)) : b[u.B] = x, dt() || (u.ln.css(b), ln && F && i && u.ln.one(J, function () {
        Et || u.ln.css(s, me)
      })), f.W = x, f.P = _, f.F = d
    }

    function Ze(n, t) {
      var r = t ? "removeClass" : "addClass",
        e = n ? b : m,
        i = n ? Tn : Hn;
      (n ? s : l)[r](i), e[r](i)
    }

    function ni(n) {
      return {
        K: n ? de : pe,
        hn: n ? "Width" : "Height",
        B: n ? le : ae,
        J: n ? "Left" : "Top",
        Q: n ? pn : bn,
        Z: n ? "X" : "Y",
        j: n ? "w" : "h",
        dn: n ? "l" : "t",
        sn: n ? s : b,
        ln: n ? l : m,
        cn: n ? a : v,
        vn: n ? vn : hn
      }
    }

    function st(n) {
      ir = ir || pt(Rn, !0), n ? p && Ht ? si(ir.removeAttr(xi.s), Dn) : gt(ir) : p || Yt.append(ir)
    }

    function ti(n, t, r) {
      if (!1 !== r)
        if (Ht) {
          var e, i = Vt.callbacks[n],
            o = n;
          "on" === o.substr(0, 2) && (o = o.substr(2, 1).toLowerCase() + o.substr(3)), cn(i) == bi && i.call(Ot, t), h(jn, function () {
            cn((e = this).on) == bi && e.on(o, t)
          })
        } else Et || Fn.push({
          n: n,
          a: t
        })
    }

    function ri(n, t, r) {
      r = r || [me, me, me, me], n[(t = t || me) + ae] = r[0], n[t + ce] = r[1], n[t + se] = r[2], n[t + le] = r[3]
    }

    function ei(n, t, r, e) {
      return t = t || me, n = n || me, {
        t: e ? 0 : ii(Yt.css(n + ae + t)),
        r: r ? 0 : ii(Yt.css(n + ce + t)),
        b: e ? 0 : ii(Yt.css(n + se + t)),
        l: r ? 0 : ii(Yt.css(n + le + t))
      }
    }

    function lt(n, t) {
      var r, e, i, o = function (n, t) {
        if (i = "", t && typeof n == gi)
          for (e = n.split(xe), r = 0; r < e[xi.l]; r++) i += "|" + e[r] + "$";
        return i
      };
      return new RegExp("(^" + rn + "([-_].+|)$)" + o(Mr, n) + o(Dr, t), "g")
    }

    function vt() {
      var n = ar[xi.bCR]();
      return {
        x: ln && 1 / (Si.round(n.width) / ar[xi.oW]) || 1,
        y: ln && 1 / (Si.round(n.height) / ar[xi.oH]) || 1
      }
    }

    function ht(n) {
      var t = "ownerDocument",
        r = "HTMLElement",
        e = n && n[t] && n[t].parentWindow || vi;
      return typeof e[r] == pi ? n instanceof e[r] : n && typeof n == pi && null !== n && 1 === n.nodeType && typeof n.nodeName == gi
    }

    function ii(n, t) {
      var r = t ? parseFloat(n) : parseInt(n, 10);
      return isNaN(r) ? 0 : r
    }

    function dt() {
      return Ir && St.x && St.y
    }

    function oi() {
      return Lt ? er[0] : sr
    }

    function ui(r, n) {
      return "<div " + (r ? cn(r) == gi ? 'class="' + r + '"' : function () {
        var n, t = me;
        if (Ci.isPlainObject(r))
          for (n in r) t += ("c" === n ? "class" : n) + '="' + r[n] + '" ';
        return t
      }() : me) + ">" + (n || me) + "</div>"
    }

    function pt(n, t) {
      var r = cn(t) == wi,
        e = !r && t || Yt;
      return p && !e[xi.l] ? null : p ? e[r ? "children" : "find"](R + n.replace(/\s/g, R)).eq(0) : Ci(ui(n))
    }

    function bt(n, t) {
      for (var r, e = t.split(R), i = 0; i < e.length; i++) {
        if (!n[xi.hOP](e[i])) return;
        r = n[e[i]], i < e.length && cn(r) == pi && (n = r)
      }
      return r
    }

    function mt(n) {
      var t = Vt.updateOnLoad;
      t = cn(t) == gi ? t.split(xe) : t, Oi.isA(t) && !Et && h(t, n)
    }

    function fi(n, t, r) {
      if (r) return r;
      if (cn(n) != pi || cn(t) != pi) return n !== t;
      for (var e in n)
        if ("c" !== e) {
          if (!n[xi.hOP](e) || !t[xi.hOP](e)) return !0;
          if (fi(n[e], t[e])) return !0
        } return !1
    }

    function ai() {
      return Ci.extend.apply(this, [!0].concat([].slice.call(arguments)))
    }

    function ci(n, t) {
      return e.addClass.call(n, t)
    }

    function si(n, t) {
      return e.removeClass.call(n, t)
    }

    function li(n, t, r) {
      return (r ? ci : si)(n, t)
    }

    function gt(n) {
      return e.remove.call(n)
    }

    function wt(n, t) {
      return e.find.call(n, t).eq(0)
    }
  }
  return zi && zi.fn && (zi.fn.overlayScrollbars = function (n, t) {
    return zi.isPlainObject(n) ? (zi.each(this, function () {
      q(this, n, t)
    }), this) : q(this, n)
  }), q
});